<html>
<head>
<meta http-equiv="Content-Language" content="en-gb">
<meta name="Generator" content="Microsoft FrontPage 4.0">
<title>Definition of S-code</title>
</head>
<body TEXT="#000000" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" BGCOLOR="#FFFFFF">

<h1><center><strong>S - P O R T:</center>
</strong></h1>

<p><center><u>Definition of S-code V3.0</u></center>
</p>

<p><center>by</center>
</p>

<p><center>Peter Jensen, Simula a.s.<br>
Stein Krogdahl, Simula a.s.<br>
&Oslash;ystein  Myhre, Simula a.s.<br>
Peter S. Robertson, Program Library Unit, Edinburgh<br>
Gunnar Syrrist, Simula a.s.</center>
</p>

<p>	This document is under supervision of the Standards Group for the Portable
SIMULA System (SG/PSS). The statutes of the Standards Group are found in
appendix D.</p>

<p>	The document contains all decisions taken by the SG/PSS, whose last meeting was
held in Edinburgh 1st and 2nd March 1983.</p>

<p>									Simula a.s.,<br>
									21st June 1985</p>

<hr>

<p><u>Preface to third edition</u></p>

<p>This report describes version 3 of S-code. Numerous changes of an editorial nature has
been made, too many to mention. The language itself has to some extent been revised,
due to the experience that we have had with the use of the language since September
1980. The most significant of these changes are</p>

<ul>
  <li>The introduction of a macro facility in the S-code.</li>
  <li>Introduction of instructions for fetching values directly.</li>
  <li>A total revision of the chapter describing intermediate results, chapter 7, since the
previous one contained serious errors.</li>
  <li>Removal of the instructions <u>sconvert</u> and <u>endifc</u>.</li>
  <li>Restrictions in connection with the segmentation control.</li>
  <li>A simplification of the routine definition.</li>
  <li>In case a profile is made visible, the parameter tags may also occur in the tag list
(14.1).</li>
  <li>The concept of an interface module is introduced (14.2). In this module all global
variables as well as the environment interface is collected.</li>
  <li>The following new symbols are added to the language:
    <ul>
      <li>	<u>fixrep</u> (8), <u>c-size</u> (14), <u>c-raddr</u> (22), <u>nobody</u> (23), <u>range</u> (49), <u>asscall</u> (136), <u>call-tos</u>
(137), <u>dinitarea</u> (138), <u>nosize</u> (139), <u>popall</u> (140), <u>repcall</u> (141), <u>interface</u> (142),
<u>macro</u> (143), <u>mark</u> (144), <u>mpar</u> (145), <u>endmacro</u> (146), <u>mcall</u> (147), <u>pushv</u> (148),
<u>selectv</u> (149), <u>remotev</u> (150), <u>indexv</u> (151), <u>accessv</u> (152) and the predefined tags
RADDR (11) and SIZE (12).</li>
    </ul>
  </li>
</ul>

<p>The following S-code compilers are currently being implemented:</p>

<table border="1" width="100%">
  <tr>
    <td width="33%"> <b>Computer</b>		 </td>
    <td width="33%"><b>Implementer</b></td>
    <td width="34%"><b>Under contract to</b></td>
  </tr>
  <tr>
    <td width="33%">&nbsp;VAX 11/780 VMS</td>
    <td width="33%">		 PLU, Edinburgh</td>
    <td width="34%">	   Simula a.s.</td>
  </tr>
  <tr>
    <td width="33%"> HB level 66</td>
    <td width="33%">	 SZKI, Budapest</td>
    <td width="34%">	   Honeywell-Bull, Paris</td>
  </tr>
  <tr>
    <td width="33%"> NORD 500</td>
    <td width="33%">		 Univ. of Oslo</td>
    <td width="34%">		   Norsk Data A/S, Oslo</td>
  </tr>
  <tr>
    <td width="33%"> Univac 1100</td>
    <td width="33%">	 Simula a.s., Oslo</td>
    <td width="34%">	   Simula a.s.</td>
  </tr>
  <tr>
    <td width="33%"> PR1ME 750</td>
    <td width="33%">	 SIMPROG AB, Stockholm</td>
    <td width="34%"> PR1ME Computer, Stockholm</td>
  </tr>
  <tr>
    <td width="33%"> Motorola 68000</td>
    <td width="33%">		 SIMPROG AB, Stockholm</td>
    <td width="34%"> SIMPROG AB, Stockholm</td>
  </tr>
  <tr>
    <td width="33%"> CP/M 8086</td>
    <td width="33%">	 Simula a.s., Oslo</td>
    <td width="34%">	   Simula a.s.</td>
  </tr>
  <tr>
    <td width="33%"> Mach-S</td>
    <td width="33%">		 Simula a.s., Oslo</td>
    <td width="34%">	   Simula a.s.</td>
  </tr>
</table>

<p>For information on the availability of these SIMULA implementations please contact the
quoted parties or Simula a.s. Enquiries about the conditions for implementations on other
computer systems should be directed to</p>

<p>						Simula a.s.<br>
Nedre Klekken vei 33<br>
N-3514 H&oslash;nefoss, Norway</p>

<p>&nbsp;</p>
<h2>1.  <strong>INTRODUCTION</strong></h2>

<p>In 1979 the Norwegian Computing Center (Oslo) and the Program Library Unit
(Edinburgh) initiated the &quot;S-PORT&quot; project: implementation of a portable SIMULA-system.
The system consists of three parts:</p>

<ul>
  <li>a portable front-end compiler,</li>
  <li>a portable run time support system, and</li>
  <li>a machine dependent code generator.</li>
</ul>
<p>The latter includes the interfaces to the compile and run time environment.</p>

<p>The present report defines the intermediate language &quot;S-code&quot; used to transmit an
analyzed Simula program from the front end compiler to the code generator.</p>

<p>Both the front end compiler and the run time system will be distributed in S-code. In order
to implement Simula it will be necessary to program the code generator (the S-compiler)
for the machine in question. This compiler will take care of two tasks:</p>

<ul>
  <li>it will produce code for the target machine corresponding to the S-program, and</li>
  <li>it will insert the necessary links to the operating system.</li>
</ul>
<p>This report is intended as an implementation independent definition, therefore the code
generation semantics are rather naive. A forthcoming report, &quot;S-compiler implementation
guide&quot;, will treat the implementation problems more in depth in view of our experience with
the S-PORT systems under way on HB DPS8, VAX, PR1ME, NORD 500 and Univac
1100.</p>

<p>The S-code has been designed by the authors. We acknowledge valuable criticism and
comment from Peter H&aring;ndlykken and H&aring;vard Hegna (NCC), who painstakingly read
through the draft of this report. Thanks are also due to Geoffrey E. Millard and Rob Pooley
(PLU), Georg P. Philippot (University of Oslo), Andras Gaspar and the rest of the team at
SZKI in Budapest, and Karel Babcicky and Birger M&oslash;ller Pedersen (NCC) for
contributions and ideas.</p>

<h3>1.1.  <u>References</u></h3>

<p></p>

<div align="left">
  <table border="0" cellspacing="3" width="80%" cellpadding="3">
    <tr>
      <td width="100%">
<p>1.	&quot;Simula Common Base&quot;<br>
	by O.-J. Dahl, B. Myhrhaug and K. Nygaard<br>
	Norwegian Computing Center, 1971.</p>

      </td>
    </tr>
    <tr>
      <td width="100%">
<p>2.	&quot;Simula Implementation Guide&quot;<br>
	by O.-J. Dahl and B. Myhrhaug<br>
	Norwegian Computing Center, 1973</p>

      </td>
    </tr>
    <tr>
      <td width="100%">3.	&quot;S-compiler Implementation Guide&quot;<br>
	Norwegian Computing Center (forthcoming)</td>
    </tr>
    <tr>
      <td width="100%">4.	&quot;The Environment Interface&quot;<br>
	by G. E. Millard, &oslash;. Myhre and G. Syrrist<br>
	Norwegian Computing Center, 1981.</td>
    </tr>
    <tr>
      <td width="100%">
<p>5.	&quot;Run Time System Definition.&quot;<br>
	by &oslash;ystein Myhre.<br>
	Norwegian Computing Center, 1982.<br>
	(restricted).</p>

      </td>
    </tr>
    <tr>
      <td width="100%">
<p>6.	&quot;Code Generation Schemes for Portable SIMULA.&quot;<br>
	by &oslash;ystein Myhre and Birger M&oslash;ller-Pedersen<br>
	Norwegian Computing Center, 1982.<br>
	(restricted).</p>

      </td>
    </tr>
  </table>
</div>
<h3>

<br WP="BR1">1.2.  <u>Philosophy of the design</u></h3>
<p>It is important to realise, that S-code is not seen as a set of instructions which can be
executed (or interpreted) to perform the task specified by the source program. Instead
S-code controls a compilation process, the outcome of which is an executable form of the
program. Thus S-code comprises the instruction set of a <u>compiler</u>, not a (Simula)
<u>machine</u>.</p>

<p>S-code has been designed as a practical tool to facilitate the production of Simula
compilers on as wide a range of computers as possible. In addition the language makes it
possible to generate efficient object code, where &quot;efficient&quot; can mean different things
depending on the context: fast, compact, highly diagnostic, etc.</p>

<p>In order to achieve these aims the language had to be flexible enough to cater to these
needs. Unfortunately this flexibility forces a certain vagueness in the definition of the
S-code, making precise statements difficult and even dangerous as they may invalidate
styles of implemen- tation for no better reason than that other possibilities were not
foreseen. Consequently this definition is only precise in terms of those parts of the
semantics which relate directly to the problems faced by the processor generating the
S-code.</p>

<p>It is appreciated that the task of producing an S-compiler is in many ways much simpler
than the task of maintaining such a compiler. The language has therefore been designed
so that errors in both the S-program and the S-compiler can be detected as close to the
point of error as possible.</p>

<p>To this end operations with far-reaching effects have been avoided as experience has
shown them to be excellent at covering up processing errors. A guiding principle adopted
is that it is better for the compiler to fail to compile a program (and inform the user of the
fact) than to purport to have compiled it but in reality to have generated faulty code. In the
former case there is no doubt as to where the problem lies (the compiler is wrong)
whereas in the latter vast amounts of time can be spent trying to find non-existent bugs in
user's programs.</p>

<p>In this report the language is presented using a conventional notation for the language
symbols as if S-programs were created as symbolic strings. This notation has been
chosen for publication purposes in order to make the report more readable. Actually all
S-programs will be byte encoded, i.e. a program will always be a string of (8-bit) bytes,
which encode the program according to the tables given in the appendix. No separating
spaces etc. are necessary, and will thus never occur.</p>

<h3>1.3.  <u>General overview</u></h3>

<p>A system programmed in S-code will in the general case consist of a main program, which
will receive control when the translated system is to begin execution, and several modules
which may provide type definitions, routine support (in the form of a run time system, as is
the case in S-PORT), etc.</p>

<p>Each program or module will contain three main classes of program elements:</p>

<ul>
  <li>type definitions (<u>record</u> descriptors) govern the structure and manipulation of data
quantities,</li>
  <li>data quantity declarations (<u>const</u>, <u>local</u>) control the actual (static) allocation and
identification of data, and</li>
  <li>statements and instructions, possibly grouped in <u>routines</u>, specify (together with the
type information) the target machine instructions to be generated.</li>
</ul>
<p>Unlike most assembly languages, S-code contains a number of structured statements
such as <u>if</u>-statement or <u>call</u>-statement. But unlike higher level languages (such as Simula)
any intermixture of the above elements is permitted, as long as a very few rules are
obeyed, the most significant being that</p>

<blockquote>

<p>	Any identifier (<u>tag</u>) must have been explicitly &quot;declared&quot; before it may be used in an
instruction.</p>

</blockquote>

<p>Data to be manipulated may be of one of the usual types, such as integer, or the
information may be structured as a <u>record</u> with named (tagged) components, or even into
higher order structures such as linked lists or networks. Instructions (such as <u>add</u>) are
included for the massage of primitive data, while pointer- and structure- manipulating
instructions (such as <u>select</u> component) are included to support general graph traversion.</p>

<p>In principle S-code is a typed language, but type compatibility is enforced only upon the
simple types; usually no checking is implied when manipulating the representation of
instances of structured types, in particular no qualification check is implied on access to
record components. It is considered the responsibility of the S-code generators (e.g. the
front-end compiler) to ensure consistent use of pointers.</p>

<p>The main control structuring tool is the routine concept. A routine is inherently
non-recursive, all parameter transmissions are by value (but it is possible to transfer
pointer values), and strict syntax rules ensure that a routine will exit only through its final
end. Unlike other languages, S-code permits explicit naming of the location, in which the
return address is saved, so that a routine not necessarily returns to its point-of-call.</p>

<p>Routines also establish name hiding: all names (tags) defined within the routine are
invisible from the outside, they lose their meaning when the routine is left. As a matter of
fact they may be reused in other routines or even at a later point in the enclosing program,
for quite different purposes.</p>

<p>A module defines a closed name scope (just like routines), it is however possible to
selectively open the scope, making certain aspects of a module accessible outwith the
module, while other aspects remain hidden. Type definitions, routine identifications,
labels, and named constants can be made visible in this manner.</p>

<p>The <u>interface</u> <u>module</u> specifies the assumptions made about the environment, in which the
translated program is to be executed. This special module also serves as a global area for
variables and constants.</p>

<h3>1.4.  <u>Terminology</u></h3>

<dl>
  <dt>Atomic unit</dt>
  <dd>A data storage unit. The size is the highest common factor of the sizes of
    all the data quantities which will be manipulated during the execution of a
    program. The size is implementation dependent. Atomic units may impose a
    finer resolution on the storage than the machine address allows.</dd>
  <dt>Area</dt>
	<dd>A vector of one or more consecutive atomic units.</dd>
  <dt>Object unit</dt>
	<dd>An area of implementation-defined fixed size; the size will always be an integral
number of machine addressable storage cells. This is the allocation unit (storage
cells may not be directly usable because of alignment problems).</dd>
<dt>Quantity</dt>
<dd>Used with the meaning: something that (at run time) may be manipulated by the
executing program.</dd>
<dt>Record</dt>
<dd>An area with a structure imposed by a structured type defined by a record
descriptor.</dd>
<dt>Object</dt>
<dd>A record which is not a component of any record. An object will always comprise an
integral number of object units.</dd>
<dt>Static quantity</dt>
<dd>The quantity exists throughout the program execution.</dd>
<dt>Dynamic quantity</dt>
<dd>The quantity is created during program execution.</dd>
<dt>Descriptor</dt>
<dd>	An abstraction used by the S-compiler to describe properties of quantities existing
at run-time. The exact formats of the different kinds of descriptors are
implementation dependent.</dd>
<dt>Complete descriptor</dt>
<dd>	A descriptor is said to be complete if the quantity described has been allocated, i.e.
the actual address is known (otherwise it is incomplete).</dd>
<dt>Segment</dt>
<dd>	A contiguous storage area containing machine instructions.</dd>
<dt>Current program point</dt>
<dd>The place which will contain the next target machine instruction generated is called
the current program point.</dd>
<dt>Constant area</dt>
<dd>A storage area used for the allocation of constants. Dependent upon the
architecture of the target machine constants may be allocated interspersed with
instructions (i.e. in program segments), in a separate storage area or elsewhere.</dd>
<dt>Stack</dt>
<dd>A data structure in the S-compiler used in this report as an explanatory tool. See
chapter 2.</dd>
<dt>S-program</dt>
<dd>A byte string to be interpreted according to the syntax. Note that since all symbols
are of fixed length (an integral number of bytes), no separators such as spaces or
line shifts are necessary nor will they occur.</dd>
</dl>
<h3>1.5.  <u>Description of syntax rules</u></h3>

<p>The S-code syntax is described in BNF with the following additions:</p>

<ul>
  <li>Meta symbols are written in lower case without brackets, terminal symbols are
underlined lower case, and upper case is used for pre- defined tags.</li>
  <li>Alternative right hand sides for a production may be separated by ::= as well as !.</li>
  <li>Productions may be annotated with comments enclosed in parentheses.</li>
  <li>Part of a right hand side may be enclosed in angular brackets followed by one of
the characters ?, *, or + with the following meanings:
    <ul>
      <li>	&lt; symbol string &gt;?	( &quot;symbol string&quot; is optional; it may occur zero times or once. )</li>
      <li>	&lt; symbol string &gt;*	( &quot;symbol string&quot; may occur zero or more times at this point. )</li>
      <li>	&lt; symbol string &gt;+	( &quot;symbol string&quot; must occur one or more times at this point. )</li>
    </ul>
  </li>
  <li>Spaces and line breaks are used simply to separate various parts of a production;
they have no other significance, in particular they will not occur in the S-program.</li>
  <li>Particular instances of a meta-symbol may be given a prefix, separated from the
symbol by a colon, e.g. body:tag. The prefix (body) has the sole purpose of
identifying the meta-symbol (tag) in the accompanying description; it has no
syntactical significance whatsoever.</li>
</ul>
<p>&nbsp;</p>
<p>	<img border="0" src="../compilation.gif" width="720" height="540"></p>

<p><center><u>General overview of an S-PORT system</u></center>
</p>

<h2>&nbsp;</h2>

<h2>2.  <strong>DESCRIPTORS AND THE COMPILE TIME STACK</strong></h2>

<p>The actions, which the S-compiler should take upon recognition of a specific program
element, are defined in terms of <u>descriptors</u>. These actions will in general involve both the
manipulation of descriptors and code generation for the target machine. Exactly <u>when</u>
such code generation should take place, as well as the generation <u>order</u>, is to a wide
extent left to the S-compiler to decide. However, at certain points in the program code
generation <u>must</u> take place. Such points are either implicit in the evaluation of certain
instructions, or they will be marked explicitly by the <u>eval</u> instruction (see chapter 16).</p>

<p>The descriptors contain information about various objects which will exist during the
computation. The descriptors themselves do not exist at run time; they are compile-time
objects used to control the generation of executable code. The exact form of descriptors
(and other data structures maintained during the compilation process) depends on both
the target machine and the implementation techniques, but for the purpose of explanation
we will assume that descriptors will contain at least three fields: MODE, TYPE, and
&quot;value&quot;.</p>

<p>Once a descriptor has been defined it remains unaltered, but the tagged descriptors are
used to create and modify anonymous descriptors held in a <u>stack</u>. This stack need not
have any existence in the compiled program, it is purely a device for describing the effect
of the S-instructions. At run time intermediate results will exist; such &quot;temporaries&quot; are
related to the state of the compile-time stack. In practice the stack will never be very deep,
a limit of about fifty descriptors should prove to be over-generous.</p>

<h3>2.1.  <u>The &quot;value&quot; field (BASE, OFFSET)</u></h3>

<p>This field may hold an address or a value - or even a specification of a computation that
will lead to either - depending upon the MODE field. For the purpose of explanation we
will adopt the very naive view that this field always contains either an address description
or a value. In the former case (when MODE is REF) we will consider this field to comprise
two subfields, refered to as BASE and OFFSET; they will contain descriptors of the
OADDR and the AADDR components of a general address respectively. Generally the
&quot;value&quot; field will be described in very loose terms.</p>

<h3>2.2.  <u>MODE, the access control field</u></h3>

<p>The MODE is an implementation-dependent specification of an algorithm or &quot;access rule&quot;
which, when applied to the rest of the descriptor, will yield the described quantity. Clearly,
as these access rules will vary from compiler to compiler it is impossible to give a rigorous
definition of them. However from the point of view of describing the effect of certain
S-code constructions, access rules can be grouped into two general modes, namely VAL
and REF.</p>

<table border="1" width="100%">
  <tr>
    <td width="8%" valign="top">VAL</td>
    <td width="92%">
  <df>VAL access rules describe <u>values</u>. In this case the &quot;value&quot; field may or may not
contain the actual value described. A descriptor with MODE VAL could specify that
a value is
<ul>
<li>the constant 137</li>
<li>contained in register 4</li>
<li>the address of label LAB1</li>
<li>contained in area X</li>
<li>or it could specify an algorithm for obtaining the value, such as &quot;add the
value in area X to index register 6&quot; etc.</li>
</ul>
    </td>
  </tr>
  <tr>
    <td width="8%" valign="top">REF&nbsp;</td>
    <td width="92%">
<p>	REF access rules describe references to areas which have an associated address
of some sort. In this case the &quot;value&quot; field may or may not hold this address. A
descriptor of MODE REF could specify that an area is</p>

      <ul>
        <li>	pointed at by index register 2</li>
        <li>	pointed at by the area X</li>
        <li>	starting at bit 5 of the area 300</li>
        <li>	at the address: displacement + (base)</li>
        <li>	at the address: (display(5)) + offset</li>
      </ul>
    </td>
  </tr>
</table>
<p>The main significance of this distinction may be stated:</p>

<blockquote>
<p>	An assignment of a quantity described by &quot;descr1&quot; to a quantity described by
&quot;descr2&quot; is not valid if descr2 do not have mode REF. The descriptor descr1 may
be of either mode, if it is REF, it is converted to VAL first.</p>

</blockquote>
<h3>2.3.  <u>TYPE, the data item type</u></h3>

<p>TYPE specifies the values that may be associated with the object described, and hence
also defines the interpretations of operations upon that object; the instruction <u>add</u> may
operate on integers or reals, and depending on the actual type either a real (floating point)
add or an integer add machine instruction may be generated.</p>

<p>Within a descriptor the TYPE field holds the tag of a descriptor defining the type. The
simple types refer to pre-defined descriptors, while structured types refer to record
descriptors. The descriptors refered to by TYPE have TYPE fields refering to themselves.
The TYPEs manipulated by S-code may be grouped as follows:</p>

<table border="1" width="100%">
  <tr>
    <td width="14%" valign="top">VOID&nbsp;</td>
    <td width="86%">	This type is used to restrict the operations on certain descriptors. The only general
operation permitted is <u>pop</u>, but other operations are defined on specific classes of
descriptors of type VOID. VOID is <u>not</u> a type of S-code, purely a convenient
specification for certain descriptors.</td>
  </tr>
  <tr>
    <td width="14%" valign="top">simple type</td>
    <td width="86%">		The simple types are BOOL, CHAR, INT, REAL, LREAL, SIZE,
      AADDR, OADDR, GADDR, PADDR, and RADDR, and are described in section 4.1.</td>
  </tr>
  <tr>
    <td width="14%" valign="top">structuredtypes</td>
    <td width="86%">		refer to type tags defined by record descriptors, see section 4.3.</td>
  </tr>
</table>
&nbsp;
<h3>2.4.  <u>Reference to descriptors (tags)</u></h3>

<p>During the compilation descriptors will be created and destroyed. With the exception of
stack items each descriptor is associated on creation with a unique identifying &quot;tag&quot;, on
destruction the tag becomes available for re-use.</p>

<p>In this document tags will be used in a manner similar to the use of identifiers in other
languages, that is they will represent either a particular descriptor or the object described
by that descriptor. In the hardware representation of S-code the tags will be positive
numbers.</p>

<p>Syntactically a distinction is made between &quot;tag&quot;, &quot;newtag&quot;, and &quot;spectag&quot;. Whenever
&quot;tag&quot; occurs the corresponding value must be defined, that is associated with a descriptor.
&quot;newtag&quot; signifies that the tag value is undefined, that is it has either never ocurred
previously in the program text, or the meaning has been (explicitly or implicitly) deleted. In
the case of &quot;spectag&quot;, the tag value may either be undefined, otherwise it must have
occurred previously in a specification of a routine, a constant, or a label.</p>

<h3>2.5.  <u>Stack semantics</u></h3>

<p>The effect of instructions upon the items in the stack is described using a procedural
notation, and marked with asterisks in the left margin. The following terms are used with a
specific meaning:</p>

<ul>
  <li>the term &quot;error&quot; means that the compilation should be abandoned with a minimum
of change to the controlling environment. A suitable error message should be
generated.</li>
  <li>&quot;check ...&quot; (e.g. check TOS ref;) means that if the condition is not fulfilled (in the
example: if TOS is not mode REF) the S-program is in error (see above).</li>
  <li>The top elements of the stack will be refered to as TOS (top of stack) and SOS
(second on stack). If any instruction refers to a non-existing item on the stack, the
S-program is in error.</li>
  <li>	<u>TOS</u> and <u>SOS</u> (underlined) refer to the elements <u>before the evaluation started</u>.</li>
  <li>the operation &quot;++&quot; implies the concatenation of two OFFSETs, the result (at run
time) being the OFFSET of the second operand relative to the BASE of the first
operand. This may imply code generation. For an example, see the <u>index</u>
instruction in chapter 6.</li>
  <li>&quot;force ... value&quot; means that a descriptor of mode REF is changed to describe the
contents of the referenced area, thereby becoming VAL. This may imply code
generation. If the mode was VAL, nothing is done.</li>
</ul>
<p>&nbsp;</p>
<h2>3.  <strong>GENERAL STRUCTURE OF S-PROGRAMS</strong></h2>

<p>	S-program</p>

<p>		::=	<u>program</u>  program_head:string</p>

<p>			  program_body  <u>endprogram</u></p>

<br WP="BR1">
<p>	program_body</p>

<p>		::=	interface_module</p>

<p>		::=	macro_definition_module</p>

<p>		::=	&lt;module_definition&gt;*</p>

<p>		::=	<u>main</u> &lt;local_quantity&gt;* &lt;program_element&gt;*</p>

<br WP="BR1"><br WP="BR2">
	program_element

<p>		::=	instruction</p>

<p>		::=	label_declaration</p>

<p>		::=	routine_profile		!   routine_definition</p>

<p>		::=	skip_statement			!   if_statement</p>

<p>		::=	protect_statement</p>

<p>		::=	insert_statement</p>

<p>		::=	delete_statement</p>

<br WP="BR2">
<p>	instruction</p>

<p>		::=	constant_declaration</p>

<p>		::=	record_descriptor		!   routine_specification</p>

<p>		::=	stack_instruction		!   assign_instruction</p>

<p>		::=	addressing_instruction	!   protect_instruction</p>

<p>		::=	temp_control			!   access_instruction</p>

<p>		::=	arithmetic_instruction	!   convert_instruction</p>

<p>		::=	jump_instruction</p>

<p>		::=	goto_instruction</p>

<p>		::=	if_instruction			!   skip_instruction</p>

<p>		::=	segment_instruction		!   call_instruction</p>

<p>		::=	area_initialisation		!   eval_instruction</p>

<p>		::=	info_setting			!   macro_call</p>

<p>&nbsp;      </p>

<p>The program head will contain the identification of the front-end compiler and other
information; the exact format is defined in (4). Program elements are not permitted within
routine bodies, while instructions are (see section 13.3).</p>

<p>The distinction between program elements and instructions is syntactically ambiguous in
the case of if-, skip-, protect- and segment-constructions; we emphasize that the syntax
given is intended to be descriptive rather than the base of an automatic compiler
generation scheme.</p>

<p>Any local quantities and descriptors are visible only from within the body of the main
program; all such tags are destroyed at <u>endprogram</u> and made available for re-use. They
are statically allocated and part of the main program throughout an execution, by analogy
with Algol's 'own'-variables. Their initial values are undefined.</p>

<h3>3.1.  <u>The primitive syntax symbols</u></h3>

<p>byte</p>

<p>	::=	an (8-bit) unsigned integer value in the range 0..255.</p>

<br WP="BR2">
<p>number</p>

<p>	::=	a two-byte value greater than or equal to zero. A number (or any other
multi-byte structure) will always be transmitted with the most significant byte
first. Let the bytes be &lt;B1&gt;&lt;B2&gt; in that sequence; the value will be 256 * B1
+ B2 .</p>

<br WP="BR1">
<p>ordinal</p>

<p>	::=	a number with value greater than zero.</p>

<br WP="BR1">
<p>tag</p>

<p>	::=	An ordinal (the &quot;tag-value&quot;) associated with a descriptor. See section 2.4.</p>

<p>	::=	The number zero followed by an ordinal (the &quot;tag value&quot;) and an identifying
string.</p>

<p>		The second form is intended for debugging purposes and is used to
associate an identification with the tag.</p>

<br WP="BR1">
<p>newtag</p>

<p>	::=	A tag-value with no association, see section 2.4.</p>

<br WP="BR1"><br WP="BR2">
spectag

<p>	::=	a tag-value which, if not undefined, must have been given an association in
a specification (<u>labelspec</u>, <u>constspec</u>, <u>routinespec</u>), see section 2.4.</p>

<p><br WP="BR2">
</p>
<p>index</p>

<p>	::=	a byte within an implementation-defined range which identifies an internal
label. An important side effect of its occurrence is that it looses its meaning.
Thus an internal label can be the destination of exactly one jump-instruction.
See section 11.2.</p>

<br WP="BR1">
<p>newindex</p>

<p>	::=	an index-byte which is undefined; it becomes defined as an internal label
through its occurrence. See section 11.2.</p>

<br WP="BR2">
<p>string</p>

<p>	::=	a byte with the value N followed by N &quot;data bytes&quot;. The character count N
must be greater than zero, thus a string cannot be empty.</p>

<p>Definition of S-code	<a HREF="#N_22_"><sup>(22)</sup></a>      </p>

<br WP="BR1"><br WP="BR2">
<br WP="BR1"><br WP="BR2">
<h2>4.  <strong>TYPES AND VALUES</strong></h2>

&nbsp;
<p>	type</p>

<p>		::=	structured_type   !   simple_type</p>

<br WP="BR1"><br WP="BR2">
	resolved_type

<p>		::=	resolved_structure</p>

<p>		::=	simple_type</p>

<p>		::=	INT Range lower:number upper:number</p>

<p>		::=	SINT</p>

<br WP="BR1"><br WP="BR2">
<br WP="BR1">Any data quantity must belong to some <u>type</u>. The type will define the internal structure of
the quantity as well as the operations that may be performed upon it. Types are used as
generators in global, constant, local or parameter definitions and as specificators in
quantity descriptors. Each type defines a descriptor (of the same type), this descriptor
cannot be used on the stack, thus types cannot be used dynamically as e.g. parameters.
<p>The distinction between resolved and non-resolved type is made because of the indefinite
repetition, which may occur in structured types. Such a type cannot be used as a
generator, or in further type definition, without determining the actual number of elements
in the repetition.</p>

<p>Whenever the S-compiler should perform type checking, neither the actual number of
elements in such an indefinite repetition, nor the actual range specified for an INT quantity
is of any significance, unless it is explicitly indicated in the text. A structured type can be
extended by using prefixing. Such two types are not type compatible (but note that the
S-code only imposes type checking in a very few cases such as in initialisation of
globals).</p>

<h3>4.1.  <u>Predefined types and their value ranges</u></h3>

<br WP="BR1">
<p>	simple_type</p>

<p>		::=	BOOL		!  CHAR</p>

<p>		::=	INT		!  REAL	!  LREAL	!  SIZE</p>

<p>		::=	OADDR	!  AADDR	!  GADDR	!  PADDR	!  RADDR</p>

<br WP="BR2">
<br WP="BR1">
<p>All simple types are predefined tags. The language offers no possibility to define new
simple types.</p>

<h4>4.1.1.  <u>Arithmetic types</u></h4>

<table border="1" width="100%">
  <tr>
    <td width="15%" valign="top">BOOL</td>
    <td width="85%">	Boolean. Takes the values <u>true</u> or <u>false</u>.</td>
  </tr>
  <tr>
    <td width="15%" valign="top">CHAR</td>
    <td width="85%">	Character. 256 different characters are defined (corresponding to an 8-bit
representation). The lower half of this ordered set is the ISO 646 character
set (encoded accordingly), the interpretation of the upper half is
implementation-dependent.</td>
  </tr>
  <tr>
    <td width="15%" valign="top">INT</td>
    <td width="85%">		Integer. Signed integer values with a machine dependent range and
representation. The range must correspond at least to a 16-bit
representation, but if possible it should be at least 32 bits.</td>
  </tr>
  <tr>
    <td width="15%" valign="top">REAL</td>
    <td width="85%">	A subset of the real values, which is representable on the target machine.</td>
  </tr>
  <tr>
    <td width="15%" valign="top">LREAL</td>
    <td width="85%">	Long real. A set of real values with greater precision than the REAL values.
The range of LREAL may differ from that of REAL. Restricted
implementations may choose to ignore the distinction between REAL and LREAL, treating both as REAL.</td>
  </tr>
  <tr>
    <td width="15%" valign="top">SIZE</td>
    <td width="85%">	Object size. Values of this type describe object sizes and distances between
objects, measured as the distance between two machine addresses. They may be
represented as integers (with sign), but they are not type compatible with INT. The
empty size (corresponding to zero) is <u>nosize</u>.</td>
  </tr>
</table>
<h4>&nbsp;<br WP="BR2">
4..1..2.  <u>Data address types</u></h4>

<p>Addresses in S-code are designed to permit the description of objects which are arranged
in implementation and machine-dependent ways. In particular it is envisaged that some
S-compilers may pack information into available storage in ways which require to be
described using complex addresses. These considerations have led to the following types
of address:</p>

<table border="1" width="100%">
  <tr>
    <td width="14%" valign="top">OADDR</td>
    <td width="86%">	Object address. Specifies the address of an object unit, in general the first
unit in an object. <u>onone</u> designates no object. All other values of type
OADDR will correspond to true machine addresses.</td>
  </tr>
  <tr>
    <td width="14%" valign="top">AADDR</td>
    <td width="86%">	Attribute address. Specifies the relative address of (the first atomic unit of) a
record component. This is of course not a true address in the machine sense
of the word, the component will not be accessible without the OADDR base.
<u>anone</u> designates no attribute.</td>
  </tr>
  <tr>
    <td width="14%" valign="top">GADDR</td>
    <td width="86%">	General address. A pair (OADDR,AADDR) which uniquely identifies a
particular atomic unit. The components of a GADDR value are not directly
accessible, but they may be extracted by means of convert instructions.
<u>gnone</u> designates no unit and is the pair (<u>onone</u>, <u>anone</u>). Values of this type
will not necessarily correspond to pure machine addresses.</td>
  </tr>
</table>
<br WP="BR2">

<br WP="BR1"><br WP="BR2">
<p>            (OADDR)&gt;</p>

<p>                              (AADDR)                     </p>

<p>                                                          </p>

<p>                                     V                     </p>

<p>            (GADDR)&gt;                     </p>

<p>                                                           </p>

<p>                                                           </p>

<br WP="BR2">
<p><center><u>Correspondence between the different data addresses</u></center>
</p>

<h4>

<br WP="BR1">4.1.3.  <u>Instruction address types</u></h4>
<table border="1" width="100%">
  <tr>
    <td width="17%" valign="top">PADDR</td>
    <td width="83%">	Program address. Specifies the address of an instruction. It is independent
of the other types of address. <u>nowhere</u> designates no program point.</td>
  </tr>
  <tr>
    <td width="17%" valign="top">RADDR</td>
    <td width="83%">	Routine address. Specifies the entry point address of a routine body. It is
independent of (and inconvertible to) the other address types. <u>nobody</u>
designates no entry point.</td>
  </tr>
</table>
<p>&nbsp;</p>

<h3>4.2.  <u>Quantity descriptors</u></h3>

<br WP="BR1">
<p>	quantity_descriptor</p>

<p>		::=	resolved_type &lt; Rep count:number &gt;?</p>

<br WP="BR1">Any quantity in the S-program is described by a quantity descriptor. The type will define
the internal structure of the quantity as well as the set of operations permitted.
<p><br WP="BR2">
<h4>4.2.1.  <u>Subrange of INT (range, SINT)</u></h4>

<p>Quantities of type INT may be restricted in range, as shown. A range has a contiguous
value domain which is part of the domain for INT.</p>

<p>The motivation for range is storage economy for variables with a restricted value domain.
Ranges are used extensively in the S-port run-time system, e.g. for some of the system
attributes present in all user-defined objects.</p>

<p>The S-compiler allocates a range to a storage unit which at least comprises the closed
interval (lower..upper) specified for the range. The value domain of a range is system
dependant and defined to be the domain of the storage unit allocated to the range.</p>

<p>The type SINT corresponds to the type of variables declared <u>short</u> <u>integer</u> in a Simula
program. The S-compiler treats SINT as a range specified with a suitable interval, at least
including (-32000,32000), and (almost) symmetrical around zero.</p>

<p>Although ranges occur in arithmetic S-code expressions, there is no arithmetic operations
(or relations) defined on ranges. It is the responsibility of the S-compiler to convert to INT
before the operation is performed, and to convert to range before assignment to a range.
(This scheme is consistent with the Common Base specification of <u>short</u> <u>integer</u> which
states that all operations on <u>short</u> <u>integer</u> should be performed in full integer arithmetic.)</p>

<p>One consequence of this is that intermediate results (see chapter 7) never can be range
restricted.</p>

<p>It is required that the S-compiler checks domain overflow for assignment to ranges
originating from SINTs, while such a check is not required for other ranges, e.g. ranges
declared in the run-time system. The S-compiler may choose to always generate domain
checks on assignment, hence treating any range as it must treat SINT.</p>

<p>The predefined range SINT is the only possible tagged quantity descriptor.</p>

&nbsp;
<h4>4.2.2.  <u>Repetitions (rep)</u></h4>

<p>A quantity may be defined as a repetition. If the count:number is greater than zero a
vector of identical elements is defined, containing that number of elements and accessed
through indexing (see <u>index</u>, chapter 6) with indices starting at zero. The allocation of the
elements must be done in such a way that the size of each element provides enough
information to permit access to one relative to another. A count of zero indicates that the
number of elements is indefinite. Such indefinite repetitions are only permitted in record
descriptors.</p>

<p>It is important to realise that the repetition concept does not impose any structure upon
the quantity (as e.g. an array declaration does). Whenever a repeated quantity is selected
(by <u>push</u>, <u>select</u>, or <u>remote</u>) the first element is selected directly.</p>

&nbsp;
<h3>4.3.  <u>Type definition</u></h3>

&nbsp;
<p>	record_descriptor</p>

<p>		::=	<u>record</u> record_tag:newtag &lt;record_info&gt;?</p>

<p>			&lt;prefix_part&gt;? common_part</p>

<p>			&lt;alternate_part&gt;* <u>endrecord</u></p>

<br WP="BR1">
<p>	record_info</p>

<p>		::=	<u>info</u> &quot;TYPE&quot;  !  <u>info</u> &quot;DYNAMIC&quot;</p>

<br WP="BR1">
<p>	prefix_part</p>

<p>		::=	<u>prefix</u>  resolved_structure</p>

<br WP="BR1">
<p>	common_part</p>

<p>		::=	&lt;attribute_definition&gt;*</p>

<br WP="BR2">
<p>	alternate_part</p>

<p>		::=	<u>alt</u>  &lt;attribute_definition&gt;*</p>

<br WP="BR1">
<p>	attribute_definition</p>

<p>		::=	<u>attr</u> attr:newtag quantity_descriptor</p>

<br WP="BR1">
<p>	resolved_structure</p>

<p>		::=	structured_type  &lt; <u>fixrep</u>  count:ordinal &gt;?</p>

<br WP="BR1"><br WP="BR2">
<p>	structured_type</p>

<p>		::=	record_tag:tag</p>

<br WP="BR1"><br WP="BR2">
A record descriptor defines a structured type with the tag 'record tag'. This new type may
then later be used either as a generator in variable or constant definitions, as a prefix or
as an attribute type in further record descriptors; in all these cases an indefinite repetition
must be resolved through the use of <u>fixrep</u>. Or the record tag may be used as a parameter
to some instructions, in which case an indefinite repetition need not be so resolved.
<p>  A set of incomplete type descriptors  will be associated with the record tag:newtag.
These descriptors may be divided into several subsets: one describing part of the type
with a fixed interpretation and the remainder describing a number of interpretations for the
rest of the type. The SIZE of the structure will be the SIZE of the prefix plus the SIZE of
the common part plus the SIZE of the &quot;largest&quot; alternative, that is the alternative
occupying the largest number of object units (disregarding a possible indefinite repetition).
Which of several alternatives determines the SIZE is implementation dependent.</p>

&nbsp;
<h4>4.3.1.  <u>Prefixing</u></h4>

&nbsp;
<p>If specified, the prefix must refer to a defined type descriptor, resulting in a type which is
the prefix type extended by the specified attributes (an indefinite repetition in the prefix
type must be resolved).</p>

<p>&nbsp;</p>
<h4>4.3.2.  <u>Attributes</u></h4>

<p>Each attribute definition defines the type of an accessible attribute of the structure. There
is no inherent correspondence between the order of the attributes in the record descriptor
and the allocation order inside a record, but when the record descriptor is processed by
the S-compiler, an AADDR value will be associated with each attribute tag defined. These
associations cannot later be changed, which implies that the order prefix...common part
must be preserved.</p>

&nbsp;
<h4>4.3.3.  <u>Indefinite repetitions and fixrep</u></h4>

<p>An indefinite repetition in the record descriptor must be the (lexically) very last attribute
defined, i.e. it occurs immediately before <u>endrecord</u>. The type so defined cannot generally
be used (except in a few instructions) without being resolved through the application of
the <u>fixrep</u> construction; this will determine the actual number of elements in the repetition.
Note however that type compatibility checking is connected to the record tag, so that
structures are of the same type even if they are resolved with different counts.</p>

&nbsp;
<h4>4.3.4.  <u>Alternatives (records with variants)</u></h4>

<p>If several alternate parts are given, it specifies alternative interpretations of the same
area, the correspondence between pairs of attributes from different alternatives is not
defined. The alternate part(s) must be allocated following the common part.</p>

&nbsp;
<h4>4.3.5.  <u>Allocation order</u></h4>

<p>The S-compiler is free to reorder or pack the attributes in any convenient way, as long as
the above mentioned restrictions are observed, in summary:</p>

<ul>
  <li>the order prefix...common part...alternatives must be preserved,</li>
  <li>once ordered and packed the order is invariant, that is a prefix cannot be
re-packed,</li>
  <li>an indefinite repetition must be allocated at the end of the structure,</li>
  <li>records are always allocated with a size corresponding to the largest alternative (at
allocation an indefinite repetition cannot occur).</li>
</ul>
&nbsp;
<p>Examples:		<u>record</u>  COMPLEX</p>

<p>				<u>attr</u>  RE  REAL  <u>attr</u>  IM  REAL</p>

<p>			<u>endrecord</u></p>

<p>			<u>record</u>  C</p>

<p>				<u>attr</u>  D  BOOL</p>

<p>				<u>attr</u>  E  COMPLEX  <u>rep</u>  2</p>

<p>			<u>endrecord</u></p>

<p>			<u>record</u>  F  <u>prefix</u>  C</p>

<p>				<u>alt</u> <u>attr</u>  G  REAL</p>

<p>				<u>alt</u> <u>attr</u>  H  PADDR</p>

<p>				<u>alt</u> <u>attr</u>  J  BOOL  <u>rep</u>  0</p>

<p>			<u>endrecord</u></p>

<br WP="BR1">The type F will have the common part as defined by C, and three alternative parts; one
contains an indefinite repetition. The indefinite repetition 'J' must be resolved whenever F
is used either in a record descriptor or as a generator for allocation.
<p>&nbsp;</p>
<h4>4.3.6.  <u>Record information</u></h4>

<p>The record info string is used to give information to the S-Compiler on the use of certain
records. Three classes of records are distinguished, any record descriptor will be in one of
these classes:</p>

<ul>
  <li> -	All structured types which may occur as TYPE in value mode stack descriptors
shall contain the record <u>info</u> &quot;TYPE&quot;. This may be usefull when processing the
protect construction.</li>
  <li> -	A small set of structured types are used as prefixes to every dynamic quantity
created by the run time system during execution; such types shall contain  <u>info</u>
&quot;DYNAMIC&quot;. This information may be necessary in order to determine the size,
since the target system may prohibit general use of the address space for such
objects, e.g. dynamic reference should be to an even byte address).<br>
	<u>dsize</u> is valid only for types in this set.</li>
  <li> -	If a record descriptor does not contain (either directly or through a prefix) any such
specification, the record will not be used for any of the two above mentioned
purposes.<br>
	It may not be necessary for the S-compiler to utilise the record information field; in
that case the specifications may be ignored and no distinction should be made by
the compiler.</li>
</ul>
<p>&nbsp;</p>
<h3>4.4.  <u>Constant values</u></h3>

&nbsp;
<p>	value</p>

<p>		::=  boolean_value			!   character_value</p>

<p>		::=  integer_value			!   size_value</p>

<p>		::=  real_value			!   longreal_value</p>

<p>		::=  attribute_address		!   object_address</p>

<p>		::=  general_address		!   program_address</p>

<p>		::=  routine_address		!   record_value</p>

<br WP="BR1"><br WP="BR2">
<p>	repetition_value</p>

<p>		::=  &lt;boolean_value&gt;+</p>

<p>		::=  &lt;character_value&gt;+		!   text_value</p>

<p>		::=  &lt;integer_value&gt;+		!   &lt;size_value&gt;+</p>

<p>		::=  &lt;real_value&gt;+			!   &lt;longreal_value&gt;+</p>

<p>		::=  &lt;attribute_address&gt;+	!   &lt;object_address&gt;+</p>

<p>		::=  &lt;general_address&gt;+		!   &lt;program_address&gt;+</p>

<p>		::=  &lt;routine_address&gt;+		!   &lt;record_value&gt;+</p>

<br WP="BR1">
<h4>4.4.1.  <u>Arithmetic values</u></h4>

<br WP="BR1">	text_value

<p>		::=	<u>text</u> long_string</p>

<br WP="BR1">
<p>	long_string</p>

<p>		::=	( an ordinal with value N followed by N &quot;data bytes&quot;.			  Note that a text value cannot be empty. )</p>

<br WP="BR2">
<p>A text value is understood as a repetition of characters, e.g.</p>

<br WP="BR1">
<p>	<u>text</u> &quot;abcd&quot;  ==  <u>c-char</u> 'a' <u>c-char</u> 'b' <u>c-char</u> 'c' <u>c-char</u> 'd'.</p>

<p><br WP="BR2">
</p>
<p>	boolean_value</p>

<p>		::=	<u>true</u>  !  <u>false</u></p>

<br WP="BR1"><br WP="BR2">
<p>	character_value</p>

<p>		::=	<u>c-char</u>  byte</p>

<br WP="BR1">
<p>	integer_value</p>

<p>		::=	<u>c-int</u>  integer_literal:string</p>

<br WP="BR1">
<p>An integer literal is a string:</p>

<blockquote>
<p>	&lt; &lt;radix&gt; R&gt;?  &lt;sign&gt;?  &lt;digit&gt;+</p>

</blockquote>
<p>where digit is one of the (ISO coded) decimal digits, and sign may be + or -. The letter R,
if included, signals that the integer is specified with a radix preceding R. The only legal
radices are 2, 4, 8 and 16. If the radix is 16, &lt;digit&gt; may also be one of the (ISO-coded)
letters A-F, with the obvious meaning.</p>

<p><br WP="BR2">
</p>
<p>	real_value</p>

<p>		::=	<u>c-real</u>  real_literal:string</p>

<br WP="BR1"><br WP="BR2">
	longreal_value

<p>		::=	<u>c-lreal</u>  real_literal:string</p>

<br WP="BR1"><br WP="BR2">
<p>A real literal is a string:</p>

<blockquote>
<p>	&lt;sign&gt;?  &lt;digit&gt;*  &lt; .  &lt;digit&gt;+ &gt;?  &lt; &amp;  &lt;sign&gt;?  &lt;digit&gt;+ &gt;?</p>

</blockquote>
<p>Note that neither an integer literal nor a real literal may contain spaces.</p>

<br WP="BR1"><br WP="BR2">
<p>	size_value</p>

<p>		::=	<u>c-size</u>  type   !   <u>nosize</u></p>

<br WP="BR1">
<p>If the type contains an indefinite repetition the size is measured as if this attribute is
absent, i.e. only the part(s) of the type preceding the indefinite repetition is measured.</p>

<p>The size of the type is measured as the distance (see <u>dist</u> chapter 6) <u>from</u> the first object
unit allocated <u>to</u> a record of the type to the first object unit following the record, i.e.</p>

<blockquote>
<p>		size = dist(first,next) .</p>

</blockquote>
<p>&nbsp;</p>
<h4>4.4.2.  <u>Data address values</u></h4>

&nbsp;
<p>	attribute_address</p>

<p>		::=	&lt; <u>c-dot</u>  attribute:tag &gt;*  <u>c-aaddr</u>  attribute:tag</p>

<p>		::=	<u>anone</u></p>

<br WP="BR1"><br WP="BR2">
<p>The value of an attribute address is the OFFSET of the attribute. This may be computed
relative to any surrounding record by means of the <u>c-dot</u> construction. <u>anone</u> is an empty
OFFSET, refering to no attribute. The interpretation of the construction</p>

<blockquote>
<p>	<u>c-dot</u> T1 <u>c-dot</u> T2 ... <u>c-aaddr</u> LT is &quot;T1.T2.. .LT&quot;.AADDR</p>

</blockquote>
<br WP="BR1"><br WP="BR2">
<p>	object_address</p>

<p>		::=	<u>c-oaddr</u>  global_or_const:tag</p>

<p>		::=	<u>onone</u></p>

<br WP="BR2">
<p>The value is the object address of the global or constant quantity given. <u>onone</u> refers to
no object unit.</p>

<br WP="BR1"><br WP="BR2">
<p>	general_address</p>

<p>		::=	&lt; <u>c-dot</u>  attr:tag &gt;*  <u>c-gaddr</u>  global_or_const:tag</p>

<p>		::=	<u>gnone</u></p>

<br WP="BR1">
<p>The value is the general address of the defined global or constant quantity designated by
the lexically first tag. The general address of a sub-component of a structure component
may be given by means of the <u>c-dot</u> construction; this is interpreted as for attribute
addresses. gnone is the address of no atomic unit. The interpretation of the construction</p>

<blockquote>
<p>	<u>c-dot</u> T1 <u>c-dot</u> T2 <u>c-gaddr</u> T3   is  &quot;T3.T2.T1&quot;.GADDR</p>

</blockquote>
<p><br WP="BR2">
</p>
<h4>4.4.3.  <u>Instruction address values</u></h4>

<br WP="BR1">	program_address

<p>		::=  <u>c-paddr</u>  label:tag	!   <u>nowhere</u></p>

<br WP="BR1"><br WP="BR2">
<br WP="BR1"><br WP="BR2">
<p>The value is the program point designated by the label. <u>nowhere</u> designates no program
point.</p>

<br WP="BR1"><br WP="BR2">
<p>	routine_address</p>

<p>		::=	<u>c-raddr</u>  body:tag	!   <u>nobody</u></p>

<br WP="BR1"><br WP="BR2">
<p>The value is (the entry point of) the routine specified; a peculiar routine cannot occur.
<u>nobody</u> designates no routine body.</p>

<br WP="BR1">
<h4>4.4.4.  <u>Structured values</u></h4>

&nbsp;
<p>	record_value</p>

<p>		::=	<u>c-record</u>  structured_type</p>

<p>			 &lt;attribute_value&gt;+  <u>endrecord</u></p>

<br WP="BR1">
<p>	attribute_value</p>

<p>		::=	<u>attr</u>  attribute:tag  type  repetition_value</p>

<br WP="BR1"><br WP="BR2">
<p>Strict type correspondence is required between an attribute, the given type and the
repetition value. The attribute:tag defines which attribute is to be of a given value, i.e. the
sequence need not be the same in the structured type and in the record value. With the
exception of alternatives (see below), all attribute tags of the record descriptor must occur
exactly once, otherwise: error.</p>

<p>An indefinite repetition is resolved by the number of values in the corresponding attribute
repetiton value.</p>

<p>If the type contains alternative parts, a specific alternative is selected by naming one of its
attributes. Once an alternative has been so selected, the S-program is in error if attributes
from any other alternative occur, or if any attribute from this alternative is missing. If no
alternative is selected then no alternative part is produced.</p>

<br WP="BR2">
<p>Example:		<u>c-record</u>  F  <u>attr</u>  E  COMPLEX</p>

<p>(cf. 4.3)			<u>c-record</u>  COMPLEX</p>

<p>					<u>attr</u>  IM  REAL  <u>c-real</u> &quot;0.0&quot;</p>

<p>					<u>attr</u>  RE  REAL  <u>c-real</u> &quot;0.0&quot;</p>

<p>				<u>endrecord</u> (first element of repetition E)</p>

<p>				<u>c-record</u>  COMPLEX</p>

<p>					<u>attr</u>  RE  REAL  <u>c-real</u> &quot;1.0&quot;</p>

<p>					<u>attr</u>  IM  REAL  <u>c-real</u> &quot;-1.0&quot;</p>

<p>				<u>endrecord</u> (second element of E)</p>

<p>				<u>attr</u>  H  PADDR  <u>c-paddr</u> LABEL27</p>

<p>				<u>attr</u>  D  BOOL   <u>true</u></p>

<p>			<u>endrecord</u></p>

<br WP="BR1">
<p>Note that the attributes may be given in any order with the exception that the repetition
elements must be given in sequence. Note also the specific selection of an alternative by
naming H.</p>

<br WP="BR2">
<h3>4.5.  <u>Tagged constants</u></h3>

&nbsp;
<p>	constant_declaration</p>

<p>		::=	constant_specification  !  constant_definition</p>

<br WP="BR1">
<p>	constant_specification</p>

<p>		::=	<u>constspec</u>  const:newtag  quantity_descriptor</p>

<br WP="BR1">
<p>	constant_definition</p>

<p>		::=	<u>const</u>  const:spectag</p>

<p>			 quantity_descriptor  repetition_value</p>

<br WP="BR1">
<p>A constant area is created to hold the specified value. A descriptor (identified by the given
tag) will represent this area, i.e. the descriptor will be of the general form (REF,
constant.TYPE, ...). In case it is necessary to refer to a tagged constant before it is
possible to give its value, the constant specification is used to bind the tag to a value of
the given type. This constant must be given a value later in the program through a
constant definition, and the types must be the same.</p>

<p>A constant is always allocated an integral number of object units.</p>

<br WP="BR2">
<p>Examples:		<u>constspec</u>  PI  REAL</p>

<p>			.</p>

<p>			.</p>

<p>			<u>const</u>  PI  REAL  <u>c-real</u>  &quot;+3.1416&quot;</p>

<br WP="BR2">
<p>			<u>const</u>  CZERO  COMPLEX</p>

<p>				<u>c-record</u>  COMPLEX</p>

<p>					<u>attr</u>  RE  REAL  <u>c-real</u>  &quot;0.0&quot;</p>

<p>					<u>attr</u>  IM  REAL  <u>c-real</u>  &quot;0.0&quot;</p>

<p>				<u>endrecord</u></p>

<p><br WP="BR2">
</p>
<h2>5.  <strong>STACK INSTRUCTIONS AND ASSIGNMENT</strong></h2>

&nbsp;
<p>	stack_instruction</p>

<p>		::=  <u>push</u>  obj:tag	!  <u>pushv</u>  obj:tag</p>

<p>		::=  <u>pushc</u>  value	!  <u>dup</u>	!  <u>pop</u>	!  <u>empty</u></p>

<p>		::=  <u>pushlen</u>  (see chapter 7)</p>

<p>		::=  <u>popall</u>  byte</p>

<br WP="BR2">
<p>	assign_instruction</p>

<p>		::=	<u>assign</u>		!   <u>update</u>	!   <u>rupdate</u></p>

<br WP="BR1"><br WP="BR2">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>push</u>  obj:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( REF, obj.TYPE, obj.BASE, obj.OFFSET );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	Obj must refer to a defined global, local or constant quantity, otherwise: error.
Observe that routine parameters and exit tags are local quantities.
      <p>A copy of the descriptor is pushed onto the stack.</td>
  </tr>
</table>
<br WP="BR2">
<br WP="BR2">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>pushv</u>  obj:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( REF, obj.TYPE, obj.BASE, obj.OFFSET );</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction has the same effect as a push obj:tag, followed by a <u>fetch</u>.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>pushc</u>  constant:value</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, constant.TYPE, &quot;value&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	A descriptor of the given value is pushed onto the stack.
      <p>	Note that on some machines it is possible to use certain values as part of the target
instruction (immediate operands), in which case the descriptor may hold the actual
value. On other machines or with more complex values, it may be necessary to
place the value in store. In either case the descriptor will be of mode VAL, thus the
value will not have an associated address. The syntax of values is given in section
4.4.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>dup</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( TOS );</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	A duplicate of TOS is pushed onto the stack and forced into value mode.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>pop</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	Pop off TOS;<br>
	This instruction is illegal if TOS is a profile description.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>popall</u>  N:byte</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	perform pop n times;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check stack empty;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	Pop N items off the stack. The stack should then be empty, otherwise: error.</p>

<p>	This instruction gives a short way of emptying the stack, together with the control of
the number of elements that was on the stack. Profiles cannot be deleted from the
stack by <u>pop</u>, only by deleting the complete stack through <u>popall</u>.</p>

    </td>
  </tr>
</table>

<br WP="BR1">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>empty</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check stack empty;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction is intended as a debugging aid, it is recommended that the
condition is checked always.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>assign</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check SOS ref;  check types identical;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;  pop;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	Code is generated to transfer the value described by TOS to the location
designated by SOS. This implies that the stack elements must be evaluated, and
that any code generation involving TOS or SOS, that has been deferred for
optimisation purposes, must take place before the assignment code is generated.
SOS and TOS are popped from the stack.</td>
  </tr>
</table>

<br WP="BR1"><br WP="BR2">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>update</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check SOS ref;  check types identical;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force SOS value;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	Code is generated to transfer the value described by TOS to the location
designated by SOS. TOS must be evaluated and any deferred code generation
involving TOS must take place before the update code is generated. Note that only
TOS is popped and the new TOS is modified to describe the value assigned.</td>
  </tr>
</table>
<p>

<br WP="BR1"></p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>rupdate</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check TOS ref;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">&nbsp;force SOS value;	check types identical;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction (&quot;reverse update&quot;) works almost like update with the sole exception
that the roles of TOS and SOS are interchanged, i.e. the value transfer is <u>from</u> SOS
<u>to</u> TOS.</td>
  </tr>
</table>
<br WP="BR2">
<h2>6.  <strong>ADDRESSING INSTRUCTIONS</strong></h2>

&nbsp;
<p>	addressing_instruction</p>

<p>		::=  <u>fetch</u>	!  <u>refer</u>  resolved_type	 !  <u>deref</u></p>

<p>		::=  <u>select</u>  attribute:tag	!  <u>selectv</u>  attribute:tag</p>

<p>		::=  <u>remote</u>  attribute:tag	!  <u>remotev</u>  attribute:tag</p>

<p>		::=  <u>index</u>	!  <u>indexv</u></p>

<p>		::=  <u>inco</u>		!  <u>deco</u></p>

<p>		::=  <u>dist</u>		!  <u>dsize</u>  structured_type</p>

<p>		::=  <u>locate</u></p>

<br WP="BR1"><br WP="BR2">
<p>The effect of the addressing instructions upon the stack will be illustrated by abstract
diagrams. Note that a mode REF stack item is depicted as if it actually pointed into
storage; this is of course not true during the compilation, where the address in most cases
will be unknown.</p>

&nbsp;
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>fetch</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">&nbsp;force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	TOS.MODE should be REF, otherwise <u>fetch</u> has no effect.</p>

<p>	TOS is modified to describe the contents of the area previously described.</p>

    </td>
  </tr>
</table>
<p><br WP="BR2">
<br WP="BR2">
</p>
<p>                    (<u>TOS</u>) </p>

<p>                                    </p>

<p>                                    V</p>

<p>                The resulting       </p>

<p>                     TOS  &gt; VALUE  </p>

<p>                 after <u>fetch</u>        </p>

<br WP="BR1"><br WP="BR2">

<br WP="BR1">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>refer</u>  resolved_type</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;  check TOS type(GADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	TOS.MODE := REF;  TOS.TYPE := type;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	TOS is modified to describe a quantity of the given type, at the address described
by TOS.</td>
  </tr>
</table>
<p><br WP="BR2">
<br WP="BR1"></p>

<p>          (<u>TOS</u>) &gt; GADDR VALUE </p>

<p>                          </p>

<p>                                              </p>

<p>      The resulting                           V</p>

<p>           TOS  &gt;</p>

<p>       after <u>refer</u>           REF                object   </p>

<p>                                                  of     </p>

<p>                                                &quot;type&quot;   </p>

<br WP="BR1"><br WP="BR2">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>deref</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check TOS ref;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	TOS.MODE := VAL;  TOS.TYPE := GADDR;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	TOS is modified to describe the address of the area.</td>
  </tr>
</table>

<br WP="BR1"><br WP="BR2">
<br WP="BR2">
<p>          (<u>TOS</u>) </p>

<p>                             REF               </p>

<p>                                               </p>

<p>      The resulting        V</p>

<p>           TOS  &gt; GADDR VALUE &gt; </p>

<p>       after <u>deref</u>                  </p>

<p>                                                        </p>

<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>select</u>  attr:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check TOS ref;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	TOS.TYPE := attr.TYPE;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	&quot;TOS.OFFSET := <u>TOS</u>.OFFSET ++ attr.OFFSET&quot;;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	(note that the BASE component of TOS is unchanged)</p>

<p>	The area described by TOS is considered to be holding a record of the type, say
'REC', in which the instruction argument attr is an attribute. TOS is modified to
describe the designated component of that record. Note that no qualification check
is implied, i.e. TOS.TYPE may be different from 'REC'.</p>

    </td>
  </tr>
</table>
<p>
<br WP="BR1"><br WP="BR2">
</p>
<p>          BASE &gt; </p>

<p>                                                         </p>

<p>                                      TOS.OFFSET         </p>

<p>                                                         </p>

<p>                        REF          V                    </p>

<p>          (<u>TOS</u>) &gt;    </p>

<p>                                                       </p>

<p>                                                       </p>

<p>                                        attr.OFFSET    </p>

<p>       The resulting       REF          V               </p>

<p>           TOS  &gt;        </p>

<p>        after <u>select</u>                     attr         </p>

<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>selectv</u>  attr:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check TOS ref;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	TOS.TYPE := attr.TYPE;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	&quot;TOS.OFFSET := <u>TOS</u>.OFFSET ++ attr.OFFSET&quot;;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	The instruction has the same effect as a <u>select</u> attr:tag followed by a <u>fetch</u>.</td>
  </tr>
</table>

<p>                                                </p>

<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>remote</u>  attr:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;   check TOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( REF, attr.TYPE,<br>
      &nbsp;&quot;BASE = value(<u>TOS</u>), OFFSET = attr.OFFSET&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction uses one step of indirection. The value is considered to be the
address of an object of the type 'REC' in which attr is an attribute. TOS is replaced
by a descriptor of the designated component of that object. Note again that no
qualification check is implied (neither could it be done).</td>
  </tr>
</table>
<p><br WP="BR2">
</p>

<p>          (<u>TOS</u>) &gt; OADDR VALUE &gt;</p>

<p>                                    </p>

<p>                                              attribute </p>

<p>                                              OFFSET    </p>

<p>      The resulting        REF               V           </p>

<p>           TOS  &gt;    </p>

<p>       after <u>remote</u>                           attr     </p>

<p>                                                 </p>

<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>remotev</u>  attr:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;   check TOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( REF, attr.TYPE,<br>
      &nbsp;&quot;BASE = value(<u>TOS</u>), OFFSET = attr.OFFSET&quot; );</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	The instruction has the same effect as a <u>remote</u> attr:tag followed by a <u>fetch</u>.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>index</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;   check TOS type(INT);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check SOS ref;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	TOS.OFFSET := <u>SOS</u>.OFFSET  ++  &quot;<u>SOS</u>.SIZE * value(<u>TOS</u>)&quot;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	SOS is considered to describe an element of a repetition, and the purpose of the
instruction is to select one of the components of the repetition by indexing relative
to the current position. The effect may perhaps best be understood by considering
an infinite array A with elements of SOS.TYPE. The array is placed so that element
A(0) is the quantity described by SOS. After <u>index</u> the stack top will describe
      A(N),
where N is the value of TOS. No bounds checking should be performed.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>indexv</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;   check TOS type(INT);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check SOS ref;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	TOS.OFFSET := <u>SOS</u>.OFFSET  ++  &quot;<u>SOS</u>.SIZE * value(<u>TOS</u>)&quot;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction has the same effect as an index followed by a <u>fetch</u>.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>inco</u>, <u>deco</u>  (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value; check TOS type(SIZE);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force SOS value; check SOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;  pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, OADDR, &quot;value(<u>SOS</u>) +/- value(<u>TOS</u>)&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	The two top elements are replaced by a descriptor of the object address RESULT
defined through the equation</p>

      <blockquote>
<p>		<u>dist</u>(RESULT,value(<u>SOS</u>)) = +/- value(<u>TOS</u>)</p>

      </blockquote>
<p>	where + corresponds to <u>inco</u> and - to <u>deco</u>.</p>

    </td>
  </tr>
</table>
<br WP="BR2">
<br WP="BR1">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>indexv</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;   check TOS type(INT);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check SOS ref;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	TOS.OFFSET := <u>SOS</u>.OFFSET  ++  &quot;<u>SOS</u>.SIZE * value(<u>TOS</u>)&quot;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction has the same effect as an index followed by a <u>fetch</u>.</td>
  </tr>
</table>

<br WP="BR1"><br WP="BR2">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>dist</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value; check TOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force SOS value; check SOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;  pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, SIZE, &quot;value(<u>SOS</u>) - value(<u>TOS</u>)&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	TOS and SOS are replaced by a description of the signed distance from TOS to
SOS.</td>
  </tr>
</table>
<p>&nbsp;</p>

<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>dsize</u>  structured_type</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;  check TOS type(INT);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, SIZE, &quot;size(type with mod. rep.count)&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	The structured type must be prefixed with a &quot;DYNAMIC&quot; type (see 4.3.6), and it
must contain an indefinite repetition, otherwise: error.
      <p>	This instruction is a dynamic version of the <u>c-size</u> value function (see section
4.4.1); it may be used to compute the actual size of an object of a type containing
an indefinite repetition. TOS describes a value, the actual repetition count to be
used in the size calculation, i.e. the size is computed <u>as if</u> the type had been
defined with this repetion count instead of zero. A description of the size thus
obtained replaces TOS. Observe that if the repetition occurs as the last of several
alternatives, the repeated alternative must be used to determine the size. This may
give a smaller size than if <u>c-size</u> of the type was requested.</td>
  </tr>
</table>

<br WP="BR1"><br WP="BR2">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>locate</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;  check TOS type(AADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force SOS value;  check SOS type(OADDR,GADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;  pop;</td>
  </tr>
  <tr>
    <td width="6%" valign="top">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, GADDR,<br>
      &nbsp;&quot;value(<u>SOS</u>).BASE, value(<u>SOS</u>).OFFSET++value(<u>TOS</u>)&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	SOS and TOS are replaced by a description of the general address value formed
by &quot;addition&quot; of the two original addresses.</td>
  </tr>
</table>
<p>

<br WP="BR1">
<br WP="BR1"><br WP="BR2">
</p>

<p>              (SOS) &gt;   </p>

<p>                                              </p>

<p>                                 (<u>TOS</u>)        </p>

<p>           The resulting         V             </p>

<p>               TOS  &gt; : :        </p>

<p>           after <u>locate</u>                        </p>

<p>                                               </p>

<p>                                   </p>

<p>                                                 </p>

<p>                                                 </p>

<br WP="BR1"><br WP="BR2">
<h2>7.  <strong>INTERMEDIATE RESULTS</strong></h2>

<br WP="BR1">
<p>	protect_statement</p>

<p>		::=	<u>save</u>  &lt;program_element&gt;*  <u>restore</u></p>

<br WP="BR1"><br WP="BR2">
<p>	protect_instruction</p>

<p>		::=	<u>save</u>  &lt;instruction&gt;*  <u>restore</u></p>

<br WP="BR1"><br WP="BR2">
<p>	temp_control</p>

<p>		::=	<u>t-inito</u>   !   <u>t-geto</u>   !   <u>t-seto</u></p>

<br WP="BR1">
<p>During the compilation the stack will regularly contain items, which describe partially
evaluated expressions such as e.g. incomplete address calculations. The execution of the
corresponding machine instructions will at run time give rise to intermediate results; of
necessity these must be held in some form of anonymous storage, <u>the temporary area</u>.
The actual implementation of this area should be highly target machine dependent, thus
the machine registers may be used if a sufficiently large number of registers are available.</p>

<p>At <u>save</u> the intermediate results are copied from the temporary area into some object, the
<u>save-object</u>, provided by the run time system, and at <u>restore</u> the temporary area is
reestablished from this object.A garbage collection might be invoked from a routine (but
never from the outermost program level), thus the values of type OADDR and GADDR in
the save-objects must be accessible (to the run time system). (We will in this chapter call
the OADDR part of such values <u>pointers</u>.)</p>

<p>For the purpose of explanation we assume that the S-compiler keeps track of two
attributes of the temporary area, namely ALLOCATED which is the SIZE of the used part
of the temporary area at any given program point, and MARKS which identify all
intermediate values of type OADDR or GADDR. The former must be available during the
processing of <u>pushlen</u> (q.v.), while some representation of the latter must be transferred to
the save-object (at <u>save</u>).</p>

<p>The temp control instructions are used as follows: <u>t-inito</u> is called in preparation of a
complete scan through the pointers of a save-object. During the scan <u>t-geto</u> will be called
repeatedly, yielding the pointers successively. If the pointer is to be updated, one <u>t-seto</u>
will follow the corresponding <u>t-geto</u>, so that the pointer just inspected will be updated.</p>

&nbsp;
<h3>7.1.  <u>Implementation directives</u></h3>

<p>Since the contents of a save-object always will be accessed through one of the
instructions to be defined below (<u>t-inito</u>, <u>t-geto</u>, <u>t-seto</u>) the internal structure is completely
implementation- dependent. The reason is, that the access must be as fast as possible on
any given architecture, since the garbage collector makes several scans over the existing
save-objects during the mark and the move phases.</p>

&nbsp;
<h4>7.1.1.  <u>The save object</u></h4>

<p>Apart from the actual temporaries saved, some additional information must be present in
the save-objects. For the purpose of explanation we will call this additional attribute
SAVE-MARKS. SAVE-MARKS is some representation of the MARKS attribute to the
temporary area, which allows for sequential access to all pointer values saved. (E.g. a bit
map indicating the positions of the pointers in the save object, or an address to a
description of the save object, or a value giving the number of pointers, provided they are
stored consecutively in the save object, from a fixed offset.)</p>

<p>All of the temporary area must be included in the save object, except those values which
are constants. This includes non-pointers as well as pointers, and includes REF items as
well as VAL items. All REF items, all GADDR items and all OADDR items must be
delivered as pointers with <u>t-geto</u> unless they are known to be <u>onone</u> or <u>gnone</u>, or are
known to point within global variables, local variables or constants. Pointers that are
attributes of records must be returned unless they are in an alternate part of the record.
Note that the requirements that REF pointers must be returned implies that in general the
run time representation of a REF item must be the same as that of a GADDR.</p>

&nbsp;
<h4>7.1.2.  <u>Temp-control</u></h4>

<p>The parameters to the instructions <u>t-geto</u> and <u>t-seto</u> are implicit, i.e. they refer to the
save-object referenced by the most recent call (at run time) on <u>t-inito</u>, successive calls on
<u>t-geto</u> scans through the pointers in the save object, and a call on <u>t-seto</u> refers to the
pointer accessed by the most recent call on <u>t-geto</u>.</p>

<p>For the purpose of explanation we introduce two anonymous variables, SAVE-OBJECT
and SAVE-INDEX. SAVE-OBJECT is set by <u>t-inito</u> and referenced by <u>t-geto</u> and <u>t-seto</u>.
SAVE-INDEX is initialized by <u>t-inito</u>, updated by <u>t-geto</u> and referenced by <u>t-seto</u>. In an
implementation some representation of SAVE-OBJECT and SAVE-INDEX could be kept in
dedicated registers or in main storage. The use of the variables is explained in detail
below.</p>

&nbsp;
<h3>7.2.  <u>The occurrence of the protect construction</u></h3>

<p>The construction will occur in S-programs in the following context alone:</p>

<table border="1" width="100%">
  <tr>
    <td width="23%"><u>pushlen</u>				</td>
    <td width="77%">				( parameter to a run time      )</td>
  </tr>
  <tr>
    <td width="23%"><u>asscall</u>  &quot;profile:tag&quot;</td>
    <td width="77%">	( system routine, which returns)</td>
  </tr>
  <tr>
    <td width="23%"><u>call</u>     &quot;body:tag&quot;</td>
    <td width="77%">		( the OADDR of a save-object   )</td>
  </tr>
  <tr>
    <td width="23%"><u>save</u></td>
    <td width="77%">&nbsp;</td>
  </tr>
  <tr>
    <td width="23%">	 ...</td>
    <td width="77%">
<p>	 ( some S-code sequence which will result in TOS describing an OADDR (mode REF), pointing to the object saved above )</p>

    </td>
  </tr>
  <tr>
    <td width="23%"><u>restore</u></td>
    <td width="77%">&nbsp;</td>
  </tr>
</table>

<br WP="BR1"><br WP="BR2">
The protect instruction is illegal within routine bodies.
<p>The <u>pushlen</u> instruction will occur only in this context. Furthermore the object address
returned from the run time system before <u>restore</u> will point to the object generated at the
corresponding <u>save</u>. Observe that the object <u>address</u> is not necessarily the same since a
garbage collection may have occurred between <u>save</u> and <u>restore</u>.</p>

<br WP="BR1">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>pushlen</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, SIZE, &quot;temporary area.LENGTH&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	An implicit <u>eval</u> is performed.</p>

<p>	The SIZE needed for the following <u>save</u>, that is the sum of the current value of
ALLOCATED and the number of object units, which is needed for SAVE-MARKS
and possibly other implementation-dependant information, is computed and the
value is pushed onto the stack.</p>

<p>For optimisation purposes, it is set to <u>nosize</u> in case ALLOCATED = <u>nosize</u> (i.e. if the
temporary area is empty). In this case the accompaning <u>save</u> and corresponding <u>restore</u>
will receive <u>onone</u> as parameter.</p>

<p>	An S-compiler may choose to skip code generation for the complete sequence
<u>pushlen</u>, <u>asscall</u>, <u>call</u>, and <u>save</u> in the case ALLOCATED = <u>nosize</u>. In that case the
processing of <u>restore</u> is changed, see below.</p>

    </td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>save</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;  check TOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	remember stack;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	purge stack;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	TOS describes the address of a save-object. The size of this object is as
determined by the preceding <u>pushlen</u>. The complete state of the stack is
remembered (together with the values of ALLOCATED and MARKS) and the
compilation continues with an empty stack.</p>

<p>	Code is generated, which - if TOS.VALUE &lt;&gt; <u>onone</u> (see note below) - at run time
will save the used part of the temporary area, and set the SAVE-MARKS attribute.</p>

<p>	TOS is popped.</p>

    </td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>restore</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check TOS ref;  check TOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">push(onone);  perform assign;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check stack empty;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	reestablish stack remembered at corresponding save;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	The stack remembered by the corresponding save is reestablished (together with
the attributes ALLOCATED and MARKS).</p>

<p>	Code is generated, which - if TOS.VALUE &lt;&gt; <u>onone</u> (see note below) - at run time
will copy the content of the specified save-object into the temporary area (the
save-object will be the one generated at the corresponding save). After the copy
has been taken, <u>onone</u> is assigned to what is referred by TOS.</p>

<p>	TOS is popped.</p>

    </td>
  </tr>
</table>

<br WP="BR1"><br WP="BR2">
Notes:
<ul>
  <li>Although the test TOS.VALUE = <u>onone</u> is a run time condition it may be deduced
by the S-compiler from the fact that <u>onone</u> will occur on the stack iff <u>pushlen</u>
resulted in <u>nosize</u> being pushed (and the latter condition is determinable at compile
time).</li>
  <li>The front end compilers do not generate the protect construction in case the
compile time stack is empty.</li>
</ul>

<br WP="BR1">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>t-inito</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;  check TOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	Code is generated to initialise a scan of the save-object described by TOS, i.e.
SAVE-OBJECT is set to refer to the object, and SAVE-INDEX is initialized.</p>

<p>	TOS is popped.</p>

    </td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>t-geto</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, OADDR, &quot;value of current pointer&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	Code is generated, which in case SAVE-INDEX refers to the &quot;last&quot; pointer of the
save object refered by SAVE-OBJECT or no pointer exists in the object, the value
<u>onone</u> is returned to signal that the scan of the object should be terminated.
Otherwise SAVE-INDEX is updated to describe the &quot;next&quot; pointer of the save
object. In case the value of the &quot;next&quot; pointer is <u>onone</u>, the pointer is skipped, i.e.
iterate this description, otherwise the value of the refered pointer is returned.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>t-seto</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;   check TOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	Code is generated that inserts the value described by TOS into the pointer variable
refered by SAVE-OBJECT and SAVE-INDEX. Note that <u>t-seto</u> does not update
SAVE-INDEX.</p>

<p>	TOS is popped.</p>

    </td>
  </tr>
</table>
<p><br WP="BR2">
<br WP="BR1">Important note:&nbsp;</p>
<ul>
  <li>	Only the OADDR part of a general address should be updated. This
instruction is issued by the garbage collector during the storage
compaction, and objects are always moved as a whole.</li>
</ul>
&nbsp;
<h2>8.  <strong>DYNAMIC QUANTITIES</strong></h2>

&nbsp;
<p>	access_instruction</p>

<p>		::=	<u>setobj</u>	!  <u>getobj</u></p>

<p>		::=	<u>access</u>  oindex:byte  attribute:tag</p>

<p>		::=	<u>accessv</u>  oindex:byte  attribute:tag</p>

<br WP="BR1"><br WP="BR2">
The addressing of dynamic quantities poses a problem as their descriptors are
incomplete. Dynamic quantities are continually being created and destroyed during
program execution, and the S-compiler is not in control of their creation and allocation in
storage; this task is the responsibility of the run time system.
<p>In order to complete the definition of descriptors of dynamic objects the S-compiler must
provide a mechanism for associating object addresses (to be generated at run time) with
natural numbers or object indices known at compile time. The access instructions
described below manipulate such associations.</p>

<p>The scheme adopted should give complete freedom to the S-compiler in choosing an
appropriate implementation strategy; this can have a considerable effect on run-time
performance. The upper bound on the indices is implementation-defined, but it must be
greater than 7.</p>

<p>A well-known implementation technique using a &quot;display vector&quot; being continually updated
during program execution is for instance catered for in this proposal; as a matter of fact
that is the reason why the numbers associated with the objects are called &quot;object indices&quot;.</p>

<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>setobj</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;	check TOS type(INT);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force SOS value;	check SOS type(OADDR);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;  pop;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	The object addressed by the value described by SOS will at run time be associated
with the value of TOS, destroying any previous association of TOS. TOS and SOS
are popped from the stack.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>getobj</u></td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;  check TOS type(INT);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">&nbsp;push( VAL, OADDR, &quot;value ass. with value(TOS)&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	The object address previously associated with TOS value (through <u>setobj</u>) is
retrieved, and a new descriptor is created to describe this object address. It
replaces TOS.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>access</u>  oindex:byte  attr:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( REF, attribute.TYPE,<br>
      &nbsp;&quot;OADDR associated with oindex&quot;, attribute.OFFSET);</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction may be approximately described as a <u>getobj</u> followed by a <u>select</u>. A
descriptor of the attribute, regarded as a component of the object associated with
      oindex, will be pushed onto the stack.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>accessv</u>  oindex:byte  attr:tag</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( REF, attribute.TYPE,<br>
      &nbsp;		&quot;OADDR associated with oindex&quot;, attribute.OFFSET);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value;</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	This instruction has the same effect as an <u>access</u> oindex:byte attr:tag followed by a
<u>fetch</u>.</td>
  </tr>
</table>
<p>&nbsp;</p>
<h2>9.  <strong>ARITHMETICAL AND BOOLEAN INSTRUCTIONS</strong></h2>

&nbsp;
<p>	arithmetic_instruction</p>

<p>		::=  <u>add</u>  !  <u>sub</u>  !  <u>mult</u>  !  <u>div</u>  !  <u>rem</u>  !  <u>neg</u></p>

<p>		::=	<u>and</u>  !  <u>or</u>   !  <u>xor</u>   !  <u>imp</u>  !  <u>eqv</u>  !  <u>not</u></p>

<p>		::=	<u>compare</u>  relation</p>

<br WP="BR1"><br WP="BR2">
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>add</u>, <u>sub</u>, <u>mult</u>, <u>div</u>  (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force TOS value; check TOS type(INT,REAL,LREAL);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	force SOS value; check SOS type(INT,REAL,LREAL);</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	check types equal;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	pop;  pop;</td>
  </tr>
  <tr>
    <td width="6%">
      <p align="center"> *</td>
    <td width="94%">	push( VAL, type, &quot;value(<u>SOS</u>) op value(<u>TOS</u>)&quot; );</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">	SOS and TOS are replaced by a description of the value of the application of the
operator. The type of the result is the same as the type of the operands. SOS is
always the <u>left</u> operand, i.e. SOS op TOS. All arithmetic on subranges of INT
should be performed in full integer arithmetic.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="2"><u>rem</u>   (dyadic)</td>
  </tr>
  <tr>
    <td width="6%">&nbsp;</td>
    <td width="94%">
<p>	Remainder, defined as &quot;SOS - (SOS//TOS)*TOS&quot;. Syntax and semantics as for
<u>mult</u> except that INT is the only legal type.</p>

<p>	Note that SIMULA demands &quot;truncation towards zero&quot; for integer division. Thus
(except for a zero remainder) the result of <u>rem</u> has the same sign as the result of
the division. In more formal terms:</p>

      <blockquote>
<p>		i <u>div</u> j  =  sign(i/j) * entier(abs(i/j))</p>

<p>		i <u>rem</u> j  =  i - (i <u>div</u> j) * j</p>

      </blockquote>
<p>	where '/' represents the exact mathematical division within the space of real
numbers.</p>

    </td>
  </tr>
</table>
<p><br WP="BR2">
<br WP="BR2">
<br WP="BR1"><br WP="BR2">
</p>
<p><u>neg</u></p>

<br WP="BR1"><br WP="BR2">
<p> *	force TOS value;  check TOS type(INT,REAL,LREAL);</p>

<p> *	value(TOS)  :=  - value(TOS);</p>

<br WP="BR1">	TOS is replaced by a description of the TOS value with its sign inverted.
<p>&nbsp;
<p>Note:	Arithmetic operations can result in an interrupt situation at run time. Handling of
such situations are treated in more detail in the document &quot;The Environment
Interface&quot; (4).</p>

&nbsp;
<p><u>and</u>, <u>or</u>, <u>xor</u>, <u>imp</u>, <u>eqv</u>  (dyadic)</p>

<br WP="BR1"><br WP="BR2">
<p> *	force TOS value;  check TOS type(BOOL);</p>

<p> *	force SOS value;  check SOS type(BOOL);</p>

<p> *	pop;  pop;</p>

<p> *	push( VAL, BOOL, &quot;value(<u>SOS</u>) op value(<u>TOS</u>)&quot; );</p>

<br WP="BR1">
<p>	TOS and SOS are replaced by a description of the result of applying the operator.
Note that SOS is the left operand.</p>

&nbsp;
<p>	(<u>xor</u>: exclusive or, <u>imp</u>: implies, <u>eqv</u>: equivalence)</p>

<br WP="BR2">
<p><u>not</u></p>

&nbsp;
<p> *	force TOS value;  check TOS type(BOOL);</p>

<p> *	value(TOS)  :=  not value(<u>TOS</u>);</p>

&nbsp;
<p>	TOS is replaced by a description of the negated TOS value.</p>

<br WP="BR1">
<p><u>compare</u>  relation   (dyadic)</p>

&nbsp;
<p> *	force TOS value;  force SOS value;</p>

<p> *	check relation;</p>

<p> *	pop;   pop;</p>

<p> *	push( VAL, BOOL, &quot;value(<u>SOS</u>) rel value(<u>TOS</u>)&quot; );</p>

<br WP="BR1"><br WP="BR2">
<p>	TOS and SOS replaced by a description of the boolean result of evaluating the
relation. SOS is always the left operand, i.e. SOS rel TOS. Valid type-relation
combinations are given in the table below.</p>

<p>&nbsp;</p>
<p> relation</p>

<p>			::=	<u>?lt</u>  !  <u>?le</u>  !  <u>?eq</u>  !  <u>?ge</u>  !  <u>?gt</u>  !  <u>?ne</u></p>

<br WP="BR1"><br WP="BR2">
<p>				<u>?lt</u>	   <u>?le</u>	 <u>?eq</u>	    <u>?ge</u>	  <u>?gt</u>	<u>?ne</u></p>

<br WP="BR1"><br WP="BR2">
<p>		BOOL					   +					  +</p>

<p>		CHAR		  +		+	   +		 +	    +	  +</p>

<p>		INT		  +		+	   +		 +	    +	  +</p>

<p>		REAL		  +		+	   +		 +	    +	  +</p>

<p>		LREAL	  +		+	   +		 +	    +	  +</p>

<p>		SIZE		  +		+	   +		 +	    +	  +</p>

<p>		AADDR				   +					  +</p>

<p>		OADDR	  +		+	   +		 +	    +	  +</p>

<p>		GADDR				   +					  +</p>

<p>		PADDR				   +					  +</p>

<p>		RADDR				   +					  +</p>

<p>		resolved_structure		   +					  +</p>

<br WP="BR1">
<p><center><u>Table of legal relational operations</u></center>
</p>

<p><center>(+ marks valid relation for the designated type)</center>
</p>

<br WP="BR1">
<p>SOS and TOS must be of the same resolved type (i.e. of the same type, possibly resolved
with the same fixref-count), otherwise: error.</p>

<p>SOS is compared with TOS (i.e. SOS rel TOS), yielding a boolean value. TOS and SOS
are then popped off the stack. In case a relation occurs in a <u>compare</u> statement, a
descriptor of the boolean value is pushed, in <u>if</u> and <u>skipif</u> statements the value is
incorporated in the conditional branch sequences generated.</p>

<p>Comparison between character values is done according to the ISO 646/2022 code (i.e.
the corresponding integer values are compared).</p>

<p>Remark:	ISO 646 is the 7-bit code, 2022 is the (full) 8-bit code. 2022 does not,
however, define the actual encoding but just refers to 646 for the subset
corresponding to the most significant bit being 0; the remainder is then
defined through structural equivalence. It is necessary to conform to 2022,
since CHAR is defined to ba 8 bits.</p>

<p>Assuming an integer representation of SIZE values, comparison is performed by
comparing the numerical values of this representation. OADDR values are compared by
comparing the corresponding machine addresses (regarded as ordinal numbers).</p>

<p>Comparison between quantities of structured types is performed component by
component.</p>

&nbsp;
<h2>10.  <strong>TYPE CONVERSION</strong></h2>

&nbsp;
<p>	convert_instruction</p>

<p>		::=	<u>convert</u>  simple_type</p>

&nbsp;
<p>TOS must be of simple type, otherwise: error.</p>

<p>The TYPE of TOS is changed to the type specified in the instruction, this may imply code
generation. Not all conversions are valid, see the table below. An attempt to perform an
invalid conversion is an error.</p>

<p>The conversion performed will in some cases be illegal because of the actual value; one
example would be to try to convert a REAL to an INT, if the actual value of the REAL is
outside the range of INT. Such errors should be checked for at run time, in the cases
where they can occur. These conversions are marked ? in the table. The handling of
these errors at run time are described in (4).</p>

<p>Conversion from a GADDR to OADDR (AADDR) means: take the object address (attribute
address) part of the general address and return as result. An object address OADDR may
be converted to a general address GADDR. In that case the object address is extended
with an empty attribute address and the pair comprises the result.</p>

&nbsp;
<p>REAL (LREAL) to INT conversion is performed after the rule</p>

&nbsp;
<p>			INT = entier( REAL + 0.5 ).</p>

&nbsp;
<p>(Entier: the greatest integer not greater than the argument). The conversion should be
done exactly.</p>

<p>Observe that this rule does not preserve symmetry around zero; e.g. +0.5 is converted to
1, while -0.5 is converted to 0.</p>

<p><br WP="BR2">
<br WP="BR1"><br WP="BR2">
</p>
<p>						L	A	O	G	P	R</p>

<p> to:		B	C  	R	R	S	A	A	A	A	A</p>

<p>		O	H	I	E	E	I	D	D	D	D	D</p>

<p>		O	A	N	A	A	Z	D	D	D	D	D</p>

<p> from:	L	R	T	L	L	E	R	R	R	R	R</p>

<br WP="BR2">
<p> BOOL	.</p>

<p> CHAR	.	+</p>

<p> INT		?	.	?	?</p>

<p> REAL		?	.	?</p>

<p> LREAL			?	?	.</p>

<p> SIZE						.</p>

<p> AADDR							.</p>

<p> OADDR								.	+</p>

<p> GADDR							+	+	.</p>

<p> PADDR										.</p>

<p> RADDR											.</p>

&nbsp;
<p><center><u>Table of legal conversions</center>
</u></p>

&nbsp;
<p>	.  -	always a legal conversion, but a null operation</p>

&nbsp;
<p>	+  -	always legal and exact</p>

&nbsp;
<p>	?  -	the legality depends on the actual value being converted. Loss of accuracy
is not considered an error when converting from integer values to real
values. In other cases execution time checks may have to be inserted in
order to avoid loss of information due to truncation.</p>

&nbsp;
<p>	blank  -  always illegal.</p>

<p>&nbsp;</p>
<h2>11.  <strong>TRANSFER OF CONTROL</strong></h2>

<p>Branches in the executing program may be specified in several ways. The labels that
occur in the source program, correspond to the general labels treated in section 1. Some
source language constructions such as loops will generate branches, but at the
corresponding label it is known from where the branch came. Consequently a series of
instructions handle such specific labels, this is treated in section 2. Sections 3 and 4 treat
the <u>skip</u> and <u>if</u> statements respectively.</p>

&nbsp;
<h3>11.1.  <u>General labels</u></h3>

&nbsp;
<p>	label_declaration</p>

<p>		::=	label_specification  !  label_definition</p>

&nbsp;
<p>	label_specification</p>

<p>		::=	<u>labelspec</u>  label:newtag</p>

&nbsp;
<p>	label_definition</p>

<p>		::=	<u>label</u>  label:spectag</p>

&nbsp;
<p>	goto_instruction</p>

<p>		::=	<u>goto</u></p>

&nbsp;
<p>General labels permit unlimited transfer to program points outside routines, they
correspond to labels in the source program. Inside routine bodies general labels may not
be declared. The stack must be empty at <u>label</u> and after <u>goto</u>.</p>

<p>&nbsp;</p>
<p><u>labelspec</u> label:newtag</p>

&nbsp;
<p>	An incomplete label descriptor is created, with no associated program point. The
program point must be defined later by a label definition.</p>

&nbsp;
<p><u>label</u>  label:spectag</p>

&nbsp;
<p> *	check stack empty;</p>

&nbsp;
<p>	If the label has been specified, the corresponding descriptor is modified to describe
the current program point. Otherwise a new descriptor is created of the form (VAL,
PADDR, &quot;current program point&quot;).</p>

&nbsp;
<p><u>goto</u></p>

&nbsp;
<p> *	force TOS value;  check TOS type(PADDR);</p>

<p> *	pop;  check stack empty;</p>

&nbsp;
<p>	TOS is popped and instructions generated to perform the control transfer.</p>

<p>&nbsp;</p>
<h3>11.2.  <u>Specific labels</u></h3>

&nbsp;
<p>	jump_instruction</p>

<p>		::=	forward_jump	!  forward_destination</p>

<p>		::=	backward_jump	!  backward_destination</p>

&nbsp;
<p>	forward_jump</p>

<p>		::=	<u>switch</u>	switch:newtag  size:number</p>

<p>		::=	<u>fjumpif</u>	relation  destination:newindex</p>

<p>		::=	<u>fjump</u>	destination:newindex</p>

&nbsp;
<p>	forward_destination</p>

<p>		::=	<u>sdest</u>	switch:tag  which:number</p>

<p>		::=  <u>fdest</u>	destination:index</p>

&nbsp;
<p>	backward_jump</p>

<p>		::=  <u>bjump</u>	destination:index</p>

<p>		::=	<u>bjumpif</u>	relation  destination:index</p>

&nbsp;
<p>	backward_destination</p>

<p>		::=	<u>bdest</u>	destination:newindex</p>

&nbsp;
<p>Specific labels are generated as part of the translation process from the source program
into its S-code representation. Each instance of such a label may only be referenced
once, and this knowledge should simplify the label management in the S-compiler and
make it possible to optimise the code generated.</p>

<p>Such program points are not identified by tags or descriptors; they are accessed by
means of an &quot;index&quot;. An index may be either undefined (syntactically &quot;newindex&quot;), it may
refer to a particular program point (syntactically &quot;index&quot;).</p>

<p>The constructions described in this section do not have to be properly nested, i.e. the
destination of a forward jump may be located before or after the destination of a following
forward jump etc. But such jump-destination sets must be fully enclosed either in one
routine or in the main program.</p>

&nbsp;
<p>Examples:</p>

<p>             <u>switch</u>  SW  3</p>

<p>                   ...</p>

<p>            ?&gt; <u>sdest</u>  SW 0  ( two labels, because - )</p>

<p>               &gt; <u>bdest</u>  LL1   ( - two jumps to here   )</p>

<p>              !    ...</p>

<p>            ?!&gt; <u>sdest</u>  SW 1</p>

<p>              !    ...</p>

<p>                <u>bjump</u>  LL1</p>

<p>                   ...</p>

<p>            ?&gt; <u>sdest</u>  SW 2</p>

<br WP="BR1"><br WP="BR2">
<p>          &lt; <u>fjump</u>  LF1</p>

<p>                   ...</p>

<p>                   ...</p>

<p>           &gt; <u>bdest</u>  LB1</p>

<p>                  ...</p>

<p>              &lt; <u>fjump</u>  LF2</p>

<p>                 ...</p>

<p>         &gt; <u>fdest</u>  LF1</p>

<p>                  ...</p>

<p>             &lt;- <u>bjump</u>  LB1</p>

<p>                   ...</p>

<p>               &gt; <u>fdest</u>  LF2</p>

<br WP="BR1"><br WP="BR2">
<p><center>( observe that the jump-destination sets do not need</center>
</p>

<p><center>to be properly nested )</center>
</p>

<p>&nbsp;</p>
<p><u>switch</u>  switch:newtag  size:number</p>

<br WP="BR1">
<p> *	force TOS value;  check TOS type(INT);</p>

<p> *	pop;</p>

<p> *	check stack empty;</p>

&nbsp;
<p>	The switch:newtag will be associated with a descriptor which identifies an ordered
set of &quot;size&quot; destinations &quot;D(0:size-1)&quot;, each of which must later be located by an
<u>sdest</u> instruction. The value described by TOS is used to generate a jump to the
required one, i.e. goto D(TOS). No range checking is implied, the necessary code
will have been generated by the front-end compiler.</p>

&nbsp;
<p><u>sdest</u>  switch:tag  which:number</p>

&nbsp;
<p> *	check stack empty;</p>

&nbsp;
<p>	The tag must have been defined in a <u>switch</u> instruction, and the number must be
within the range defined by the corresponding switch instruction, otherwise: error.</p>

<p>	The destination &quot;D(which)&quot; of the <u>switch</u> instruction defining the tag is located at the
current program point.</p>

&nbsp;
<p><u>fjumpif</u>  relation  destination:newindex  (dyadic)</p>

&nbsp;
<p> *	force TOS value; force SOS value;</p>

<p> *	check relation;</p>

<p> *	pop; pop;</p>

&nbsp;
<p>	The destination must be undefined, and TOS and SOS must be of the same
permissible resolved type with regard to the relation given, otherwise: error.</p>

<p>	A conditional forward jump sequence will be generated, branching only if the
relation (see chapter 9) evaluates <u>true</u>. The destination will refer to an undefined
program point to be located later (by <u>fdest</u>).</p>

&nbsp;
<p><u>fjump</u>  destination:newindex</p>

&nbsp;
<p> *	check stack empty;</p>

&nbsp;
<p>	The destination must be undefined,otherwise: error.</p>

<p>	A jump to the (as yet unknown) program point is generated, and the destination
becomes defined.</p>

&nbsp;
<p><u>fdest</u>  destination:index</p>

&nbsp;
<p> *	check stack empty;</p>

&nbsp;
<p>	The destination must have been defined by a <u>fjump</u> or <u>fjumpif</u> instruction, otherwise:
error.</p>

<p>	The current program point becomes the destination of the jump-instruction and the
destination becomes undefined.</p>

<p>&nbsp;</p>
<p><u>bjumpif</u>  relation  destination:index (dyadic)</p>

&nbsp;
<p> *	force TOS value;   force SOS value;</p>

<p> *	check relation;</p>

<p> *	pop;  pop;</p>

&nbsp;
<p>	The destination must be defined by a <u>bdest</u> instruction, and TOS and SOS must be
of the same permissible resolved types with regard to relation, otherwise: error.</p>

<p>	A conditional jump sequence will be generated, branching only if the relation
evaluates <u>true</u>. The destination becomes undefined.</p>

&nbsp;
<p><u>bjump</u>  destination:index</p>

&nbsp;
<p> *	check stack empty;</p>

&nbsp;
<p>	The destination must have been defined in a <u>bdest</u> instruction, otherwise: error.</p>

<p>	A jump to the referenced program point is generated, and the destination becomes
undefined.</p>

&nbsp;
<p><u>bdest</u>  destination:newindex</p>

&nbsp;
<p> *	check stack empty;</p>

&nbsp;
<p>	The destination must be undefined, otherwise: error.</p>

<p>	The destination is defined to refer to the current program point.</p>

<p>&nbsp;</p>
<h3>11.3.  <u>Skip statement</u></h3>

&nbsp;
<p>	skip_statement</p>

<p>		::=  <u>skipif</u>  relation  &lt;program_element&gt;*  <u>endskip</u></p>

&nbsp;
<p>	skip_instruction</p>

<p>		::=  <u>skipif</u>  relation  &lt;instruction&gt;*  <u>endskip</u></p>

&nbsp;
<p>The skip_statement is intended to be used where a transfer of control is to be generated
without altering the state of the stack, commonly to report error conditions during
expression evaluation. The skip <u>instruction</u> is the form the statement takes inside routine
bodies.</p>

&nbsp;
<p><u>skipif</u>  relation</p>

&nbsp;
<p> *	force TOS value;  force SOS value;</p>

<p> *	check relation;</p>

<p> *	pop;  pop;</p>

<p> *	save skip-stack;</p>

&nbsp;
<p>	The generated code will compute the relation, and control is transferred to an
&quot;end-label&quot; (to be defined later), if the relation is <u>true</u>. A copy of the complete state
of the S- compiler`s stack is saved as the &quot;skip-stack&quot;.</p>

<p>&nbsp;</p>
<p><u>endskip</u></p>

&nbsp;
<p> *	check stack empty;   restore skip-stack;</p>

&nbsp;
<p>	If it is possible for control to reach the current program point, a call on a suitable
run time error routine must be inserted at the end of the generated skip-branch.
This will be the interrupt handler described in (4).</p>

<p>	The &quot;end-label&quot; is located at the current program point, and the &quot;skip-stack&quot; is
restored as the current stack.</p>

<p>&nbsp;</p>
<h3>11.4.  <u>if-statement</u></h3>

&nbsp;
<p>	if_statement</p>

<p>		::=  <u>if</u>  relation  &lt;program_element&gt;*  else_part</p>

&nbsp;
<p>	else_part</p>

<p>		::=  <u>else</u>  &lt;program_element&gt;*  <u>endif</u>   !   <u>endif</u></p>

&nbsp;
<p>	if_instruction</p>

<p>		::=  <u>if</u>  relation  &lt;instruction&gt;*  i else_part</p>

&nbsp;
<p>	i else_part</p>

<p>		::=  <u>else</u>  &lt;instruction&gt;*  <u>endif</u>   !   <u>endif</u></p>

&nbsp;
<p>While the control transfer instructions covered in the preceding sections demand that the
stack be empty at the destination, this demand is relaxed in the usage of the constructions
defined here. In case the stack is non-empty at the point where different control branches
merge, the contents must be meaningful, that is:</p>

<ul>
  <li>the stack depth must be the same in both merged branches, and</li>
  <li>the types of corresponding elements must be the same.</li>
</ul>
<p>Such merges take place only at <u>endif</u>.</p>

<p>To simplify the implementation of the if-construction we adopt the following restrictions:</p>

<p>The if-construction will end up with a mode value item on top of the stack while the rest of
the stack remains the same. This item is produced in one of two different ways:</p>

<ul>
  <li>The current TOS is modified in both if-branches.</li>
  <li>A new stack item of the same type is produced in each of the if-branches.</li>
</ul>
<p>A force TOS value is performed in both if-branches.</p>

<p>The statement will generate target code to be executed conditionally, i.e. if the condition
holds the if-part will be executed otherwise the elsepart (if any). It is comparable to very
simple if-statements in other languages. The if <u>instruction</u> is the restricted form this
construction takes inside routine bodies.</p>

&nbsp;
<p><u>if</u>  relation</p>

&nbsp;
<p> *	force TOS value;  force SOS value;</p>

<p> *	check relation;</p>

<p> *	pop;  pop;</p>

<p> *	remember stack as &quot;if-stack&quot;;</p>

&nbsp;
<p>The generated code will compute the value of the relation, and transfer control to an
&quot;else-label&quot; (to be defined later) if the relation is <u>false</u>. A copy of the complete state of the
S-compiler's stack is saved as the &quot;if-stack&quot;.</p>

<p>&nbsp;</p>
<p><u>else</u></p>

&nbsp;
<p> *	force TOS value;</p>

<p> *	remember stack as &quot;else-stack&quot;;</p>

<p> *	reestablish stack saved as &quot;if-stack&quot;;</p>

&nbsp;
<p>An unconditional forward branch is generated to an &quot;end-label&quot; (to be defined later). A
copy is made of the complete state of the stack and this is saved as the &quot;else-stack&quot;, then
the stack is restored to the state saved as the &quot;if-stack&quot;. Finally the &quot;else-label&quot; (used by
<u>if</u>) is located at the current program point.</p>

&nbsp;
<p><u>endif</u></p>

&nbsp;
<p> *	force TOS value;</p>

<p> *	merge current stack with &quot;else-stack&quot; if it exists, otherwise &quot;if-stack&quot;;</p>

&nbsp;
<p>The current stack and the saved stack are merged. The saved stack will be the &quot;if-stack&quot; if
no else-part has been processed, otherwise it will be the &quot;else-stack&quot;. The merge takes
each corresponding pair of stack items and forces them to be identical by applying <u>fetch</u>
operations when necessary - this process will generally involve inserting code sequences
into the <u>if</u>-part and the <u>else</u>-part. It is an error if the two stacks do not contain the same
number of elements or if any pair of stack items cannot be made identical. After the merge
the saved stack is deleted.</p>

<p>If no else-part was processed the &quot;else-label&quot;, otherwise the &quot;end-label&quot;, is located at the
current program point.</p>

<p>&nbsp;</p>
<h2>12.  <strong>SEGMENTATION CONTROL</strong></h2>

&nbsp;
<p>	segment_instruction</p>

<p>		::=  <u>bseg</u>  &lt;program_element&gt;*  <u>eseg</u></p>

&nbsp;
<p>This instruction specifies that the enclosed program elements are out of sequence, i.e. the
code generated must either be located elsewhere or it must be preceded by an
unconditional jump instruction leading to the program point following <u>eseg</u>. The segment
instruction is illegal within routine bodies.</p>

<p>The purpose of the segment instruction is to be able to generate e.g. code for a &quot;thunk&quot; in
the natural S-program context, without having to worry about whether to generate jumps
around it etc. The intention is that the enclosed elements from the point of view of a
sequential scan through the surrounding code should be completely invisible, i.e. the
following piece of S-code:</p>

&nbsp;
<p>		sequence-1  <u>bseg</u>  sequence-2  <u>eseg</u>  sequence-3</p>

&nbsp;
<p>will generate target code for sequence-1 and sequence-3 in direct control sequence while
sequence-2 will be located somewhere that is unreachable except through an explicit
transfer of control (goto or the like).</p>

<p>Note that all jump/destination sets must be fully enclosed within a segment.</p>

<p>An S-program will contain many such segment constructions. The S-compiler has
complete freedom to decide <u>where</u> to locate the corresponding enclosed program
segments.</p>

<p>The segment construction has no implied effect on the allocation of data or constants.</p>

<p>The <u>bseg</u> and <u>eseg</u> have similar effects on the stack as <u>save</u> and <u>restore</u> (chapter 7).</p>

&nbsp;
<p><u>bseg</u></p>

&nbsp;
<p> *	remember stack;</p>

<p> *	purge stack;</p>

&nbsp;
<p>	The current program point is remembered together with the complete state of the
stack, the &quot;bseg-stack&quot;. Some new segment is designated the current program
point, together with a new, empty stack.</p>

&nbsp;
<p><u>eseg</u></p>

&nbsp;
<p> *	check stack empty;</p>

<p> *	reestablish stack remembered at corresponding <u>bseg</u>;</p>

&nbsp;
<p>	If it is possible for control to reach the current program point, a call on a suitable
run time error routine must be inserted at the end of the generated program
segment. This will be the interrupt_handler routine described in (4).</p>

<p>	The &quot;bseg-stack&quot; is restored together with the saved program point.</p>

&nbsp;
<h2>13.  <strong>ROUTINES</strong></h2>

&nbsp;
<p>Routines in S-code correspond to subroutines in other languages but with certain
restrictions: </p>

<ul>
  <li>All parameters are passed to and from the routines by value.</li>
  <li>Routines are not recursive (but the routine may possibly contain calls of the routine
itself. In that case the body of the routine will explicitly store and reload the
necessary values around such recursive calls).</li>
  <li>Any routine must exit through its <u>endroutine</u>, it is not possible to exit via any explicit
jump.</li>
  <li>The return address may be made available to the routine (by means of an <u>exit</u>
definition), thus allowing the return address to be changed by the routine itself.</li>
</ul>
<p>The definition of a routine creates two descriptors (of type VOID), describing the routine
<u>profile</u> and the routine <u>body</u>. In certain cases to be described later no body occurs in the
program.</p>

<p>The profile defines the parameter and exit descriptors for the routine, while the body
defines the local descriptors as well as the instruction sequence to be executed when the
routine is activated. Each routine body must have exactly one routine profile associated
with it, whereas a &quot;non-peculiar&quot; profile may be associated with several routine bodies. It
is not allowed for the same profile to be associated with more than one body in any
dynamic sequence of routines calling routines, since this would imply re-use of the (static)
allocation record defined by the profile.</p>

<p>The activation sequence for a routine is generated on the basis of the call instruction
treated in section 4 below.</p>

&nbsp;
<h3>13.1.  <u>Routine profiles</u></h3>

&nbsp;
<p>	routine_profile</p>

<p>		::=	<u>profile</u>	profile:newtag  &lt;peculiar&gt;?</p>

<p>			  &lt;import_definition&gt;*  &lt;export or exit&gt;?</p>

<p>			<u>endprofile</u></p>

<br WP="BR1"><br WP="BR2">
<p>	peculiar</p>

<p>		::=	<u>known</u>	body:newtag  kid:string</p>

<p>		::=	<u>system</u>	body:newtag  sid:string</p>

<p>		::=	<u>external</u>	body:newtag  nature:string  xid:string</p>

<p>		::=	<u>interface</u>	pid:string</p>

&nbsp;
<p>	import_definition</p>

<p>		::=	<u>import</u>	parm:newtag  quantity_descriptor</p>

&nbsp;
<p>	export_or_exit</p>

<p>		::=	<u>export</u>	parm:newtag  resolved_type</p>

<p>		::=	<u>exit</u>		return:newtag</p>

&nbsp;
<p>The import (input) parameters and the export (return) parameter are transmitted &quot;by
value&quot;. Each <u>import</u> (<u>export</u>) definition will declare a quantity local to the routine body
(bodies) later associated with the profile. The order in which the parameters are given in
the profile will define the correspondence between the formal parameter locations and the
assignment of the parameter value (<u>asspar</u> in the call instruction); the tag values (used in
the associated bodies) will also be allocated in this sequence.</p>

<p>An import parameter defined as a repetition must correspond to an <u>assrep</u> in the call, the
count specifies the maximum permissible number of values to be transferred. Note that
the actual count is not transferred, it should be defined as a separate import parameter.</p>

<p>An <u>exit</u> definition identifies a descriptor for the area containing the return address of the
routine. If no exit definition is given an an-onymous descriptor will be created for the same
area. The exit des-criptor is of the basic form (REF, PADDR, ...) and exists for the use of
<u>endroutine</u> (q.v.). If the descriptor is identified through <u>exit</u> it becomes accessible to the
routine exactly as any other local quantity, and in that case it will be possible for the
routine to change its return address. Such a routine cannot be called from other routines.</p>

<p>In general, only the profile:newtag and a possible body:newtag (in case the routine is
peculiar) are visible outwith any routine body associated with the profile. Observe that
routine parameters and exit tags are local quantities.</p>

<p>The parameter tags may, however, occur in the tag list of a module (see chapter 14).</p>

<p>Remark:	The above sentence was included for the time being, because of special
implementation strategy chosen by a subimplementor. The number of the
external tags in the run-time system will be drastically reduced when these
tags are removed from the tag list.</p>

&nbsp;
<h3>13.2.  <u>Peculiar routines</u></h3>

&nbsp;
<p>&quot;Peculiar&quot; provides information about routines whose bodies either will not be defined in
any S-program, or in the case of known routines may be safely skipped by the S-compiler.
Except for known no body may be associated with the profile; it uniquely defines one
routine. The body tag so specified will be used to refer to the routine in subsequent call
statements.</p>

<p>Peculiar routines are described in this way to permit the S-compiler to handle each one in
the most convenient system- and routine- dependent manner. In particular it is common
for system-provided routines to return the result in specific registers and not in store
locations. In these cases the use of peculiar routines will ensure that the export
descriptor, stacked following the <u>call</u>, describe the appropriate registers.</p>

<p>All peculiar routines are identified by a string (kid, sid, xid or pid) in the profile, since the
actual tags associated with such a routine will vary from S-program to S-program. The
string contains at most 6 characters with the case of any character being insignificant (e.g.
&quot;a&quot; is equivalent to &quot;A&quot;). All id strings for peculiar routine profiles contain only
alphanumeric characters, the first of which is a letter.</p>

&nbsp;
<p><u>known</u>  body:newtag  kid:string</p>

&nbsp;
<p>	A known routine has a body defined in S-code. The S-compiler may know the
working of the routine and may thus replace the body with an optimised code
sequence. It is intended to be used in cases where a standard S-code routine will
be in danger of being inefficient in some implementations, or when the routine call
can be replaced by an in-line code sequence at each call.</p>

<p>It should however be noted that it is necessary to simulate (in the S-compiler) a routine
spec for the body tag when processing <u>known</u> profiles.</p>

&nbsp;
<p><u>system</u>  body:newtag  sid:string</p>

&nbsp;
<p>	System profiles provide the interface to the run time environment of the program, or
they represent routines which are impossible to program in S-code (or potentially
prohibitively inefficient in all implementations). Thus no body will be given. Such
routines (e.g. date_and_time) are typically provided by the operating system on the
target machine, and may require special intervention from the S-compiler, since the
calling conventions and parameter passing mechanisms will be system-dependent.</p>

&nbsp;
<p><u>external</u>  body:newtag  nature:string  xid:string</p>

&nbsp;
<p>	External routines are routines written in other languages. The exact nature of the
routine is specified by the nature:string. External routines are implementation
dependent.</p>

&nbsp;
<p><u>interface</u>  pid:string</p>

&nbsp;
<p>	Interface profiles may occur in the head of the interface module only. The profile
becomes visible from the run time environment through the identifying string.</p>

<p>	Every profile associated to a routine address evaluation which is an actual
parameter to a system routine should be specified as an interface profile. An
interface profile cannot have more than ony body.</p>

<p>	In fact, the interface specification is redundant, but can be used to simplify code
production for routine address values.</p>

<p>	Interface routines cannot have more than one body.</p>

&nbsp;
<p>Note that when processing a <u>known</u> profile it is necessary to simulate a routine-spec for
the body tag in the S-compiler.</p>

<p>&nbsp;</p>
<h3>13.3.  <u>Routine bodies</u></h3>

&nbsp;
<p>	routine_specification</p>

<p>		::=  <u>routinespec</u>  body:newtag  profile:tag</p>

&nbsp;
<p>	routine_definition</p>

<p>		::=  <u>routine</u>  body:spectag  profile:tag</p>

<p>			&lt;local_quantity&gt;* &lt;instruction&gt;*  <u>endroutine</u></p>

&nbsp;
<p>	local_quantity</p>

<p>		::=  <u>local</u>  var:newtag  quantity_descriptor</p>

&nbsp;
<p>The body:newtag identifies the routine body and is used as an argument to <u>call</u>, while
profile:tag connects the body to the relevant routine profile and is used as an argument to
<u>precall</u>, <u>asscall</u> or <u>repcall</u>.</p>

<p>Routine specification is used in cases where it is necessary to call an as yet undefined
routine, and in module heads.</p>

<p>A routine body will be compiled into a sequence of instructions to be executed when
activated by a call statement referencing the body tag. No quantities or descriptors
defined in the body are visible outwith that body; all such tags are destroyed at <u>endroutine</u>
and made available for re-use. As a consequence the syntax restricts the use of certain
constructs inside the routine body:</p>

<ul>
  <li>constants and general labels cannot be defined inside the routine,</li>
  <li>external modules cannot be inserted into routine bodies (see 14.3),</li>
  <li>routines cannot be nested, i.e. routine specifications or definitions cannot occur in
a body,</li>
  <li>all jump/destination sets must be fully enclosed within the body, except for
destinations of <u>goto</u> jumps.</li>
  <li>protect statements are not allowed inside routines.</li>
  <li>if, skip, and segment constructions are restricted when used inside routine bodies,
the restriction is syntactically specified as e.g. &quot;if_statement&quot; (invalid) versus
&quot;if_instruction&quot; (valid). The constructions are simply restricted so as not to allow
any of the above restrictions be violated.</li>
</ul>
&nbsp;
<p><u>local</u>  var:newtag  quantity_descriptor</p>

&nbsp;
<p>	The local quantities constitute the local variables for the routine. Conceptually they
are static quantities, i.e. the descriptors will be complete. An implementation may
choose to make them dynamic, that is created each time the routine is activated,
and destroyed at routine exit.</p>

<p>	While the tags identifying the local variables not necessarily are generated in strict
sequence, they will at <u>endroutine</u> comprise an interval.</p>

&nbsp;
<p><u>routine</u>  body:spectag  profile:tag</p>

&nbsp;
<p>	An implied <u>bseg</u> (see chapter 12) is performed.</p>

<p>	The scope to the parameter tags defined in the associated profile is opened, and
all defined destination indices and label tags will temporarily lose their meaning.</p>

&nbsp;
<p><u>endroutine</u></p>

&nbsp;
<p>	All destination indices must be undefined, and the stack must be empty, otherwise:
error.</p>

<p>	An implicit <u>eval</u> is performed. Code is generated to transfer control to the program
point described by the exit descriptor, the scope to the profile is closed, and an
implicit <u>delete</u> is performed with the minimum local tag value defined in the routine
as argument. The label tags and the destination indices defined before <u>routine</u> was
evaluated regain their meaning. Observe, that since routines cannot be lexically
nested, it is sufficient to use (the equivalence of) two destination index vectors.
Finally an implied <u>eseg</u> is performed.</p>

<p>&nbsp;</p>
<h3>13.4.  <u>Routine activation</u></h3>

&nbsp;
<p>	call_instruction</p>

<p>		::=	connect_profile  &lt;parameter eval&gt;*  connect_routine</p>

&nbsp;
<p>	connect_profile</p>

<p>		::=	<u>precall</u>  profile:tag</p>

<p>		::=	<u>asscall</u>  profile:tag</p>

<p>		::=	<u>repcall</u>  n:byte  profile:tag</p>

&nbsp;
<p>	connect_routine</p>

<p>		::=	<u>call</u>  body:tag   !   &lt;instruction&gt;+  <u>call-tos</u></p>

&nbsp;
<p>	parameter eval</p>

<p>		::=	&lt;instruction&gt;+  <u>asspar</u></p>

<p>		::=	&lt;instruction&gt;+  <u>assrep</u>  n:byte</p>

&nbsp;
<p>The call instruction causes generation of the activation sequence for a routine. First the
profile is connected, this will provide information about the number and types of the
parameters. Following this the parameter values are evaluated and transferred, and finally
the actual routine to be activated is connected, either explicitly by giving the tag or
implicitly by taking its RADDR value from TOS.</p>

<p>&nbsp;</p>
<p><u>precall</u>  profile:tag</p>

&nbsp;
<p>	A copy of the profile descriptor is pushed onto the stack. This descriptor defines the
number and types of the parameters required and where they are to be placed.
Initially it identifies the first <u>import</u> parameter (if any). The descriptor will be
modified during the further processing of the call instruction.</p>

<p>	For each import parameter a parameter evaluation sequence follows, specifying
instructions which result in a descriptor of the actual parameter value on top of the
stack.</p>

&nbsp;
<p><u>call</u>  body:tag</p>

&nbsp;
<p>	The profile descriptor must now be in TOS, and it must not describe any import
parameter, otherwise: error.</p>

<p>	The generated code will transfer any parameters from the temporary area to the
parameter locations, and then perform a subroutine call to the body. The return
address (the current program point) will be remembered in the (explicitly named or
implicitly defined) exit area. How and when this remembering is done, is
implementation dependent.</p>

<p>	The profile descriptor is popped. If it indicates an <u>export</u> parameter, the
corresponding descriptor is pushed onto the stack as  (VAL, export.TYPE, ...).</p>

<p>&nbsp;</p>
<p><u>asscall</u>  profile:tag</p>

&nbsp;
<p>	TOS must describe a quantity of the same type as the first import parameter to the
given profile, otherwise: error.</p>

<p>	<u>asscall</u> makes it possible to call a routine when the first import parameter is already
on the stack. The evaluation of this construction will take place as if the TOS
element first is moved off the stack into some anonymous location, and then a
<u>precall</u> is simulated. Following this the former TOS is moved back to the stack on
top of the profile descriptor, and finally an <u>asspar</u> is simulated.</p>

&nbsp;
<p><u>repcall</u>  N:byte  profile:tag</p>

&nbsp;
<p>	TOS must describe a quantity of the same type as the first import parameter to the
given profile. This must be a repetition.</p>

<p>	<u>repcall</u> makes it possible to call a routine when the first import parameter is already
on the stack, and this is a repetition. The argument N must be less than or equal to
the number of elements in the repetition, and the type of the 'N' uppermost stack
descriptors must be identical to the type specified for the parameter. If these
conditions are not satisfied, the S- program is in error.</p>

<p>	The evaluation of this construction will take place as if the N uppermost elements of
the stack are first moved into some anonymous location, and then a <u>precall</u> is
simulated. Following this the former N stack elements are moved back to the stack
on top of the profile descriptor, and finally an <u>assrep</u> is simulated.</p>

&nbsp;
<p><u>asspar</u></p>

&nbsp;
<p>	At this stage SOS must be the connected descriptor (possibly modified by earlier
parameter assignments) and it must describe an <u>import</u> parameter of the same type
as TOS, otherwise error.</p>

<p>	The generated code will move the value of TOS into the temporary area. The stack
is popped and the profile descriptor is modified to describe the next parameter.
After a parameter assign the profile descriptor will remain on top of the stack.</p>

&nbsp;
<p><u>assrep</u>  N:byte</p>

&nbsp;
<p>	The profile descriptor in stack element number N+1 from the top must describe an
import parameter, which must be a repetition. The argument N must be less than or
equal to the number of elements in the repetition, and the types of the 'N'
uppermost stack descriptors must be identical to the type specified for the
parameter. If these conditions are not satisfied, it is an error.</p>

<p>	The 'N' values described by the top elements in the stack are assigned to the
elements of the repetition in the following order:</p>

<p>		The top element is assigned to the N'th element of the repetition and then
popped; then the new top element is assigned to the (N-1)'th repetition
element and popped, and so on until the N stack elements in question have
been assigned to the N first elements of the repetitive parameter.</p>

<p>	These assignments imply generation of deferred code. TOS will now be the routine
descriptor, which is modified to describe the next parameter.</p>

<p>	This facility is intended to be used to pass a variable number of parameters of the
same type to certain routines, in particular to routines associated with array
accessing.</p>

&nbsp;
<p><u>call-tos</u></p>

&nbsp;
<p>	TOS must be of type RADDR, and SOS must be the (modified) connected profile
descriptor, which does not describe any import parameters, otherwise: error.</p>

<p>	This is equivalent to &quot;call TOS&quot;, i.e. the routine address popped off the stack
identifies the entry point to a routine to be connected. It will normally not be
possible for the S-compiler to check, whether TOS actually is associated with the
profile. However, the value nobody should lead to a run time error.</p>

&nbsp;
<h3>13.5.  <u>Parameter transmission</u></h3>

&nbsp;
<p>Since OADDR and GADDR values are permitted as routine parameters, the transmission
of the parameters cannot in the general case take place directly into the parameter
locations. In order to make it possible for the garbage collector to identify such values, if
the g.c. is activated during parameter transmission, the values must be transmitted as
intermediate results, i.e. in the temporary area. All calls to the g.c. will be preceded by
<u>save</u>, thus consistency will be ensured.</p>

<p>The actual transfer of the values from the temporaries to the parameter locations
associated with the profile cannot take place before <u>call</u>.</p>

<p>&nbsp;</p>
<h2>14.  <strong>SEPARATE COMPILATION</strong></h2>

<h3>14..1.  <u>Module definition</u></h3>

&nbsp;
<p>	module_definition</p>

<p>		::=	<u>module</u>  module_id:string  check_code:string</p>

<p>			visible_existing</p>

<p>			<u>body</u> &lt;local_quantity&gt;* &lt;program_element&gt;* <u>endmodule</u></p>

&nbsp;
<p>	visible_existing</p>

<p>		::=	&lt;visible&gt;*  tag_list	!  <u>existing</u></p>

&nbsp;
<p>	visible</p>

<p>		::=	record_descriptor		!  routine_profile</p>

<p>		::=	routine_specification	!  label_specification</p>

<p>		::=  constant_specification	!  insert_statement</p>

<p>		::=	info_setting</p>

&nbsp;
<p>	tag_list</p>

<p>		::=	&lt; <u>tag</u>  internal:tag  external:number &gt;+</p>

&nbsp;
<p>Rather than compiling a complete program, the S-compiler can be instructed to compile a
part of a program (a module) which subsequently will be referenced by another module or
a main program.</p>

<p>The module_id is a system-unique system-dependent identification for the module. It will
be used to locate module descriptors referenced in <u>insert</u> statements, or the descriptor of
the module itself if it is specified <u>existing</u>.</p>

<p>The check_code is an implementation-dependent code which can be used to determine
the validity of the correspondence between a module object and the compiled version of
the module it purports to describe. One possibility for this check_code is an accurate
representation of the time and date of compilation.</p>

<p>An <u>existing</u> specification in the module head informs the S-compiler that the module has
been compiled previously, and that the module head was unchanged (as well external as
internal tags occurring in the head are the same). The visible attributes of the module will
in this case be those specified visible in the earlier compilation, but changes may have
been made in the module body. Such changes do not however influence these attributes,
and the S-compiler can obtain the module head from the module descriptor file. This
means that the compilation of the module will not require recompilation of other modules
referencing this module. The check_code given in the module head must then match that
in the existing attribute file.</p>

<p>If the S-compiler encounters a module with <u>existing</u> specified, the check_code given in the
module head must match that in the existing attribute file.</p>

<p>If the module is not specified <u>existing</u>, the list of descriptors specified in the module head
specifies the externally visible attributes of the module. In order to be able to create
unique tag identification of the visible elements, the <u>tag list</u> specifies a correspondence
between the internal tags used in the module and an external number. Only tags
specifically mentioned in the tag_list are transferred via the insert instruction given in
another compilation unit; the tags defined through an insert instruction cannot themselves
be made visible outwith the module being compiled.</p>

<p>The routine specifications refer to routines defined within the module body, neither routine
profiles nor other definitions given in the head may be repeated in the body. If a profile tag
occurs in the tag_list, all the parameter tags may also occur, since the profile tag may be
associated with a routine body in another module. Label or constant specifications refer to
quantities defined in the body.</p>

<p>Any local quantities and descriptors are visible only from within the body of the module; all
such tags are destroyed at <u>endmodule</u> and made available for re-use. They are statically
allocated and part of the module throughout an execution, by analogy with Algol's
'own'-variables. Their initial values are undefined.</p>

&nbsp;
<h3>14.2.  <u>The interface module</u></h3>

&nbsp;
<p>	interface_module</p>

<p>		::=	<u>global</u> <u>module</u>  module_id:string  check_code:string</p>

<p>			 &lt;global_interface&gt;*  tag_list</p>

<p>			  <u>body</u>  &lt; <u>init</u> global:tag  type  repetition_value &gt;*</p>

<p>			<u>endmodule</u></p>

&nbsp;
<p>	global_interface</p>

<p>		::=	record_descriptor</p>

<p>		::=	constant_definition	&lt; <u>system</u>  sid:string &gt;?</p>

<p>		::=	global_definition	&lt; <u>system</u>  sid:string &gt;?</p>

<p>		::=	routine_profile</p>

<p>		::=	info_setting</p>

&nbsp;
<p>	global_definition</p>

<p>		::=	<u>global</u>  internal:newtag  quantity_descriptor</p>

<br WP="BR1"><br WP="BR2">
<p>The interface module serves two main purposes:</p>

<ul>
  <li>it specifies a set of statically allocated variables (the globals),</li>
  <li>it specifies the interface to the system environment.</li>
</ul>
<p>An interface module is inserted as any other module with the restriction, that only one
particular interface module can ever occur in the executing program, i.e. it must be
checked that different modules do not insert different versions of the interface module.</p>

<p>A complete listing of the interface module may be found in (4).</p>

&nbsp;
<p>MAXLEN</p>

&nbsp;
<p>	This is a predefined SIZE constant with an implementation dependent value; it is
the <u>c-size</u> of the temporary area (page 35). Note that it is not the same as the
ALLOCATED attribute of this area; ALLOCATED will always be less than or equal
to the value of MAXLEN.</p>

<p>This constant is needed since it is necessary to have a special area available for a save
object in case it is not possible to allocate one dynamically without garbage collection.</p>

&nbsp;
<h4>14.2.1.  <u>Global variables</u></h4>

&nbsp;
<p>The global definition specifies static allocation of a variable of the given type, therefore
the corresponding descriptor will be complete. Each such variable is an object, and may
thus be addressed either by an object or a general address.</p>

<p>A global variable may be initialised to a given value through the <u>init</u> statement. This
initialisation must take place before execution of the program proper take place, e.g. in
connection with <u>main</u>. It is of no concern whether this is done by preloading the values, or
by executing code corresponding to the <u>init</u> statements. If a global variable is not so
initialised, the initial value is undefined.</p>

<p>&nbsp;</p>
<h4>14.2.2.  <u>The environment interface</u></h4>

&nbsp;
<p>The S-code specification of the environment interface is given in the interface module in
the form of system profiles, system globals, and system constants.</p>

<p>The system constants are assigned values during the generation of the S-code program.
Values may also be assigned to system globals during this process, using <u>init</u>. In both
cases the S-code program is only providing default values, which the S-compiler may
chose to overwrite with values appropriate for the particular implementation.</p>

<p>All system routines are defined in this module; it is the responsibility of the S-compiler to
insert the actual instruction sequences corresponding to each routine into the body.</p>

<p>&nbsp;</p>
<h3>14.3.  <u>The macro definition module</u></h3>

&nbsp;
<p>	macro_definition_module</p>

<p>		::=	<u>macro</u> <u>module</u>  module_id:string  check_code:string</p>

<p>			 &lt;macro_definition&gt;*  <u>endmodule</u></p>

&nbsp;
<p>The macro definition module contains the definitions of all macros used by the front end
Simula compiler (the run time system S-code will never contain macro calls). In systems
where this facility is implemented (see below) this module is implicitly inserted in the
S-compiler when it processes S-programs generated by the Simula front end compiler.
Only one macro definition module will occur in one particular release of the portable
system.</p>

<p>Macros are introduced for two purposes:</p>

<ul>
  <li>S-code compression, and</li>
  <li>code generation optimisation in the S-compiler.</li>
</ul>
<p>The front end compiler will be able to either generate macro calls or generate the
expansion of the call; this will be governed by a switch. Thus a particular S-compiler need
not implement the macro facility at all, as long as the Simula front end compiler is installed
with the macro expansion switch <u>on</u>.</p>

<p>The macro definition module will be accompanied by a listing of all macro definitions,
giving the symbolic S-code to be substituted at each macro call together with the rationale
for the particular macro, and a specification of the kind of the parameters and of the
parameter insertion points. This will facilitate efficient code generation for the macro
expansions.</p>

&nbsp;
<h4>14..3..1.  <u>Macro definitions</u></h4>

&nbsp;
<p>	macro_definition</p>

<p>		::=	<u>macro</u>  macro_name:byte  macro_parcount:byte</p>

<p>			  <u>known</u>  macro_id:string</p>

<p>			 &lt;macro_body_element&gt;*</p>

<p>			<u>endmacro</u></p>

&nbsp;
<p>	macro_body_element</p>

<p>		::=	<u>mark</u>  macro_sequence:string</p>

<p>		::=	<u>mpar</u>  macro_parnumber:byte</p>

&nbsp;
<p>The macro definition determines the substitution schema for the macro call processing
(see 14.3.2). The macro sequences of the body should not (and cannot) be analysed
when the definition is processed, and nested definitions are illegal. The macro_parcount
is the number of actual parameters given when the macro is called, i.e. zero means no
parameters, one means exactly one parameter in the call etc. The points at which some
actual parameter is to be inserted when the macro is expanded are marked by the
<u>mpar</u>-construction, and the parnumber refer to the place in the actual parameter list (thus
parnumber cannot be zero).</p>

<p>The macro_id names the macro in a more reasonable manner than the pair (module_id,
macro_name) does; it bears no other significance.</p>

&nbsp;
<h4>14..3..2.  <u>Macro expansion</u></h4>

&nbsp;
<p>	macro_call</p>

<p>		::=	<u>mcall</u>  macro_name:byte  &lt;actual_parameter:string&gt;*</p>

&nbsp;
<p>The effect of a macro call upon the S-compiler will be described as if the macro expansion
should take place by textual replacement in the input stream. It is emphasised that this
description is for the purpose of definition only, other and more efficient methods are of
course legal as long as the described effect is achieved.</p>

<p>When a macro call is recognised the complete state of the S-compiler is saved and the
S-compiler enters macro expansion mode. The corresponding macro definition is
identified, and the call is scanned (the number of actual parameters is given by the
definition). During the scan each actual parameter is assigned its parameter number,
beginning at one. The macro call is now replaced &quot;textually&quot; after the following rules:</p>

<ul>
  <li>All macro body elements are processed in the sequence they occur in the
definition.</li>
  <li>If the element is a macro sequence, the string contents is inserted, i.e. the &quot;length
byte&quot; of the string is removed.</li>
  <li>If the element is a parameter number, the contents of the corresponding actual
parameter string is inserted in the same manner.</li>
</ul>
<p>When the replacement defined above has taken place, the S-compiler leaves expansion
mode, restores the state saved and continues processing with the first inserted byte.</p>

<p>&nbsp;</p>
<h3>14.4.  <u>Inclusion of a module</u></h3>

&nbsp;
<p>	insert_statement</p>

<p>		::=	<u>insert</u>  module_id:string  check_code:string</p>

<p>			  external_id:string tagbase:newtag  taglimit:newtag</p>

&nbsp;
<p>		::=	<u>sysinsert</u> module_id:string  check_code:string</p>

<p>			  external_id:string tagbase:newtag  taglimit:newtag</p>

&nbsp;
<p>This instruction causes the S-Compiler to include a module. The external_id is used to
identify the module with respect to an operating system. If the single character ? is given
as an external_id the S-Compiler should search the module definition library for a module
identified by the module_id. If it cannot be found or if the check code does not match, the
S-Code is in error.</p>

<p><u>sysinsert</u> is used for system modules RTS, simob etc., while <u>insert</u> is used for user
modules e.g. seperately compiled classes.</p>

<p>The visible objects of the module (as specified in the tag_list) are now brought into the
current compilation unit by adding tagbase to the external numbers specified, checking
that taglimit is not exceeded. Thus tags are allocated from the range (tagbase..taglimit).</p>

<p>Each insert instruction will have this effect, and the same module may be included several
times in the same compilation unit. The consequence of that is to create several intervals
of tags, refering the same elements in the included module.</p>

&nbsp;
<h3>14.5.  <u>Linkage of modules</u></h3>

&nbsp;
<p>The linkage of the executable code will generally be done in a manner standard to the
target system. Some knowledge about the modules must, however, be communicated to
the S-compiler: identification and type binding etc. of names external to the program being
compiled. Such information is procured from a data base (the module definition library)
maintained by the S-compiler itself. The naming conventions used, the structure of and
access method to this data base are highly system-dependent.</p>

<p>&nbsp;</p>
<h2>15.  <strong>INITIALISATION OF ALLOCATED AREAS</strong></h2>

&nbsp;
<p>	area_initialisation</p>

<p>		::=	<u>zeroarea</u></p>

<p>		::=	<u>initarea</u>  resolved_type  !  <u>dinitarea</u>  structured_type</p>

&nbsp;
<p>For the purpose of giving dynamically allocated areas sensible initial values three
instructions are defined. These instructions will always be used in the following manner:</p>

<ul>
  <li>when an area has been allocated by the system environment, or when a possible
garbage collection has returned free storage, the area(s) will be   zeroed by
<u>zeroarea</u>,</li>
  <li>when a particular area has been acquired (somehow) to be structured by some
type, one of the instructions <u>initarea</u> or <u>dinitarea</u> is issued.</li>
</ul>
<p>This usage pattern will be enforced by the front-end compiler and the run time system, i.e.
when <u>initarea</u> is to be evaluated the S-compiler may assume that the area to be initialised
has been zero-filled. Thus an implementation may choose to realise either <u>zeroarea</u> or the
initarea-pair, or it may choose a mixed strategy, zero filling the area (<u>zeroarea</u>
implemented) and partly implementing (<u>d</u>)<u>initarea</u> for those components which do not have
a zero representation. It should be obvious that the complete implementation of <u>all</u> will be
redundant and will probably lead to considerable run time overhead.</p>

<p><u>Important note</u>:	Neither the prefix part nor alternative parts must ever be initialised.</p>

<p>&nbsp;</p>
<p><u>zeroarea</u>  (dyadic)</p>

&nbsp;
<p> *	force TOS value;  check TOS type(OADDR);</p>

<p> *	force SOS value;  check SOS type(OADDR);</p>

<p> *	pop;</p>

&nbsp;
<p>	TOS and SOS must be OADDR, otherwise error.</p>

<p>	The area between SOS and TOS (SOS included, TOS not) is to be zero-filled, and
TOS is popped.</p>

&nbsp;
<p><u>initarea</u>  resolved_type</p>

&nbsp;
<p> *	force TOS value;  check TOS type(OADDR);</p>

&nbsp;
<p>	TOS.TYPE must be OADDR, otherwise: error.</p>

&nbsp;
<p>	The argument type is imposed upon the area, and the area is initialised according
to the table below. Only the common part of an instance of a structure will be
initialised, ignoring both the prefix and any alternate part(s). The structure is
initialised component by component according to the table below.</p>

<p>&nbsp;</p>
<p><u>dinitarea</u>  structured_type  (dyadic)</p>

&nbsp;
<p> *	force TOS value;  check TOS type(INT);</p>

<p> *	force SOS value;  check SOS type(OADDR);</p>

<p> *	pop;</p>

&nbsp;
<p>	TOS.TYPE must be INT, SOS.TYPE must be OADDR, and the structured type must
contain an indefinite repetition, otherwise: error.</p>

<p>	The value of TOS is used to resolve the type, i.e fixing the number of elements in
the indefinite repetition, following that the evaluation proceeds exactly as for
<u>initarea</u>.</p>

<br WP="BR2">
<p><center><u>Area initialisation values</u></center>
</p>

<br WP="BR1">
<p>				type:			initialised to:</p>

&nbsp;
<p>				BOOL				<u>false</u></p>

<p>				CHAR				NUL (ISO repr. 0)</p>

<p>				INT				0</p>

<p>				REAL, LREAL		0.0</p>

<p>				SIZE				<u>nosize</u></p>

<p>				AADDR			<u>anone</u></p>

<p>				OADDR			<u>onone</u></p>

<p>				GADDR			<u>gnone</u></p>

<p>				PADDR			<u>nowhere</u></p>

<p>				RADDR			<u>nobody</u></p>

<p>				structure			- each attr. init. as above.</p>

&nbsp;
<p>Note:	if these values are represented as zero and if <u>zeroarea</u> is implemented, the
instructions (<u>d</u>)<u>initarea</u> may safely be ignored!</p>

<p>&nbsp;</p>
<h2>16.  <strong>OTHER INSTRUCTIONS</strong></h2>

&nbsp;
<p>	eval_instruction</p>

<p>		::=	<u>eval</u></p>

&nbsp;
<p>In certain cases the code specified by previuos program elements must be generated in
order to ensure, that the generated program will behave correctly. As an example,
consider the following SIMULA statement:</p>

&nbsp;
<p>			x.b  :=  a + f;</p>

&nbsp;
<p>where &quot;f&quot; is a function that, as a side effect, may change both &quot;a&quot; and &quot;x&quot;.</p>

<p>However, the semantics of SIMULA demands strict left-to-right evaluation of statement
components. The actual values to be used in the execution of the translated statement
<u>must</u> be the values before the function f is executed. Thus it is necessary that the values
of x and a used in the computation really are &quot;fetched&quot; into some temporary locations. A
possible optimisation might instead remember that these values are stored in specific
locations, and use these values directly from the locations &quot;x&quot; and &quot;a&quot;. In that case the
computed result would be wrong. In such a situation the front end compiler will issue this
instruction.</p>

<p>The instruction forces the S-compiler to perform any operations previously specified in the
S-program, which may have been deferred for optimisation purposes. All values and
references must be fully evaluated and stored in the temporary area when an <u>eval</u> is
done, unless they are constants. Following the instruction the internal state of the
S-compiler must match the state implied by a strict application of the S-code definition.</p>

&nbsp;
<p>	delete_statement</p>

<p>		::=	<u>delete</u>  from:tag</p>

&nbsp;
<p>   * check stacks empty;</p>

&nbsp;
<p>All tags defined with values greater than or equal to from:tag are made undefined, i.e. the
corresponding descriptors may be released. The tags become available for reuse. The
stack and all saved stacks must be empty, otherwise: error.</p>

<p>The S-code generators (e.g. the SIMULA front-end compiler) will ensure that the following
rules are obeyed; since it may be very costly in terms of execution time for the S-compiler
to check these conditions, we recommend the use of an internal switch to govern such
consistency checks.</p>

<p>Let DEL be the set of tags to be deleted (i.e. the set of tags in the closed interval
from...largest defined tag). The following conditions apply to elements of DEL:</p>

&nbsp;
<p> a)	If a record tag is in DEL, then</p>
<ul>
  <li>all quantities having this record as type,</li>
  <li>all records having this record as prefix, and</li>
  <li>all attributes of this record</li>
</ul>
<p>	are in DEL.</p>
<p> b)	If an attribute tag is in DEL, then</p>
<ul>
  <li>the associated record tag is in DEL.</li>
</ul>
<p>c)	If a profile tag is in DEL, then</p>
<ul>
  <li>all body tags associated with this profile</li>
  <li>all parameter tags of this profile</li>
</ul>
<p>	are in DEL.</p>
<p> d)	If a parameter tag is in DEL, then</p>
<ul>
  <li>the associated profile tag is in DEL.</li>
</ul>
&nbsp;
<p>These conditions may be summarised informally as follows: Once a tag is to be deleted,
all tags which directly or indirectly refer to this tag are deleted in the same delete
statement.</p>

&nbsp;
<p>	info_setting</p>

<p>		::=	<u>decl</u> line:number</p>

<p>		::=	<u>line</u> line:number</p>

<p>		::=	<u>stmt</u> line:number</p>

<p>		::=	<u>info</u>  string</p>

<p>		::=	<u>setswitch</u>  switch:byte  setting:byte</p>

&nbsp;
<p>The <u>line</u>, <u>decl</u> and <u>stmt</u> instructions are used to inform about a mapping between a source
program and its S-Code. The argument of the instructions refer to the numbering of the
lines of the program listing from the S-Code producer. <u>decl</u> informs that the code following
is for a SIMULA declaration starting on the line with the supplied number. <u>stmt</u> informs
that the code following is for a SIMULA statement starting on the line with the supplied
number. <u>line</u> informs that the current point in the S-Code corresponds to the start of the
source program line with the given number. The intention is that the Front End Compiler
will produce <u>decl</u> and <u>stmt</u> instructions, while <u>line</u> instructions will occur in the code for the
Run-Time System.</p>

<p>Eventually these instructions should be used to produce a mapping between the original
source program and its corresponding machine-code. For this purpose none of them need
occur in the final machine-code. The mapping may be represented by for instance a table.</p>

<p>The <u>stmt</u> instruction may be used for another purpose as well, see chapter 11 of The
Environment Interface.</p>

<p><u>info</u> offers the possibility to communicate to the S-compiler information, which must be
interpreted in a system-dependent manner.</p>

<p><u>setswitch</u> is intended to control various aspects of the working of the S-compiler such as
the production of debugging information.</p>

<p>The compiler will maintain a set of switches which can be set to various values:
SWITCH(switch) := setting. The meanings of the switches and their settings will be
implementation-dependent with the following exceptions:</p>

&nbsp;
<ol type="a">
  <li>SWITCH(1) controls the listing of the S-code as it is processed by the compiler.
Such listing should be done using the mnemonics defined in this document
(underline excepted).<br>
	SWITCH(2) controls the stack activity trace.</li>
  <li>The setting to zero of a switch inhibits the actions controlled by the switch. This
should be the default setting of all switches.</li>
</ol>
&nbsp;
<h2><strong>Appendix A</strong></h2>

&nbsp;
<p><u>The syntax of the S-code language</u></p>

&nbsp;
<p>	(For each production is given reference to its definition)</p>

<br WP="BR1"><br WP="BR2">
<p>	S-program                                                p. 13</p>

<p>		::=	<u>program</u>  program_head:string</p>

<p>                   program_body  <u>endprogram</u></p>

&nbsp;
<p>	program_body                                             p. 13</p>

<p>		::=  interface_module</p>

<p>		::=  macro_definition_module</p>

<p>		::=  &lt;module_definition&gt;*</p>

<p>		::=  <u>main</u>  &lt;local_quantity&gt;* &lt;program_element&gt;*</p>

&nbsp;
<p>	program_element                                          p. 13</p>

<p>		::=  instruction</p>

<p>		::=  label_declaration</p>

<p>		::=  routine_profile          !   routine_definition</p>

<p>		::=  skip_statement           !   if_statement</p>

<p>		::=  protect_statement        !   insert_statement</p>

<p>		::=  delete_statement</p>

&nbsp;
<p>	instruction                                              p. 13</p>

<p>		::=  constant_declaration</p>

<p>		::=  record_descriptor        !   routine_specification</p>

<p>		::=  stack_instruction        !   assign_instruction</p>

<p>		::=  addressing_instruction   !   protect_instruction</p>

<p>		::=  temp_control             !   access_instruction</p>

<p>		::=  arithmetic_instruction   !   convert_instruction</p>

<p>		::=  jump_instruction         !   goto_instruction</p>

<p>		::=  if_instruction           !   skip_instruction</p>

<p>		::=  segment_instruction      !   call_instruction</p>

<p>		::=  area_initialisation      !   eval_instruction</p>

<p>		::=  info_setting             !   macro_call</p>

<p>&nbsp;</p>
<p>	simple_type                                              p. 15</p>

<p>		::=  BOOL   !   CHAR</p>

<p>		::=  INT    !   REAL   !   LREAL  !  SIZE</p>

<p>		::=  OADDR  !   AADDR  !   GADDR  !  PADDR  !  RADDR</p>

&nbsp;
<p>	type                                                     p. 15</p>

<p>		::=  structured_type      !  simple_type</p>

&nbsp;
<p>	resolved_type                                            p. 15</p>

<p>		::=  resolved_structure   !  simple_type</p>

<p>		::=  INT  <u>range</u>  lower:number  upper:number</p>

<p>		::=  SINT</p>

&nbsp;
<p>	quantity_descriptor                                      p. 18</p>

<p>		::=  resolved_type  &lt; <u>rep</u>  count:number &gt;?</p>

&nbsp;
<p>	record_descriptor                                        p. 19</p>

<p>		::=  <u>record</u>  record_tag:newtag  &lt;record_info&gt;?</p>

<p>		      &lt;prefix_part&gt;?  common_part</p>

<p>		      &lt;alternate_part&gt;*  <u>endrecord</u></p>

&nbsp;
<p>	record_info                                              p. 19</p>

<p>		::=  <u>info</u>  &quot;TYPE&quot;  !  <u>info</u>  &quot;DYNAMIC&quot;</p>

&nbsp;
<p>	prefix_part                                              p. 19</p>

<p>		::=  <u>prefix</u>  resolved_structure</p>

&nbsp;
<p>	common_part                                              p. 19</p>

<p>		::=  &lt;attribute_definition&gt;*</p>

&nbsp;
<p>	alternate_part                                           p. 19</p>

<p>		::=  <u>alt</u>  &lt;attribute_definition&gt;*</p>

<p>&nbsp;</p>
<p>	attribute_definition                                     p. 19</p>

<p>		::=  <u>attr</u>  attr:newtag  quantity_descriptor</p>

&nbsp;
<p>	resolved_structure                                       p. 19</p>

<p>		::=  structured_type  &lt; <u>fixrep</u>  count:ordinal &gt;?</p>

&nbsp;
<p>	structured_type                                          p. 19</p>

<p>		::=  record_tag:tag</p>

&nbsp;
<p>	value                                                    p. 23</p>

<p>		::=  boolean_value            !   character_value</p>

<p>		::=  integer_value            !   size_value</p>

<p>		::=  real_value               !   longreal_value</p>

<p>		::=  attribute_address        !   object_address</p>

<p>		::=  general_address          !   program_address</p>

<p>		::=  routine_address          !   record_value</p>

&nbsp;
<p>	repetition_value                                         p. 23</p>

<p>		::=  &lt;boolean_value&gt;+</p>

<p>		::=  &lt;character_value&gt;+       !   text_value</p>

<p>		::=  &lt;integer_value&gt;+         !   &lt;size_value&gt;+</p>

<p>		::=  &lt;real_value&gt;+            !   &lt;longreal_value&gt;+</p>

<p>		::=  &lt;attribute_address&gt;+     !   &lt;object_address&gt;+</p>

<p>		::=  &lt;general_address&gt;+       !   &lt;program_address&gt;+</p>

<p>		::=  &lt;routine_address&gt;+       !   &lt;record_value&gt;+</p>

&nbsp;
<p>	text_value                                               p. 23</p>

<p>		::= <u>text</u> long_string</p>

&nbsp;
<p>	boolean_value                                            p. 23</p>

<p>		::=  <u>true</u>  !  <u>false</u></p>

&nbsp;
<p>	character_value                                          p. 23</p>

<p>		::=  <u>c-char</u>  byte</p>

<p>&nbsp;</p>
<p>	integer_value                                            p. 23</p>

<p>		::=  <u>c-int</u>  integer_literal:string</p>

&nbsp;
<p>	real_value                                               p. 23</p>

<p>		::=  <u>c-real</u>  real_literal:string</p>

&nbsp;
<p>	longreal_value                                           p. 23</p>

<p>		::=  <u>c-lreal</u>  real_literal:string</p>

&nbsp;
<p>	size_value                                               p. 24</p>

<p>		::=  <u>c-size</u>  type   !   <u>nosize</u></p>

&nbsp;
<p>	attribute_address                                        p. 24</p>

<p>		::=  &lt; <u>c-dot</u>  attribute:tag &gt;*  <u>c-aaddr</u>  attribute:tag</p>

<p>		::=  <u>anone</u></p>

&nbsp;
<p>	object_address                                           p. 24</p>

<p>		::=  <u>c-oaddr</u>  global_or_const:tag</p>

<p>		::=  <u>onone</u></p>

&nbsp;
<p>	general_address                                          p. 24</p>

<p>		::=  &lt; <u>c-dot</u>  attr:tag &gt;*  <u>c-gaddr</u>  global_or_const:tag</p>

<p>		::=  <u>gnone</u></p>

&nbsp;
<p>	program_address                                          p. 25</p>

<p>		::=  <u>c-paddr</u>  label:tag   !   <u>nowhere</u></p>

&nbsp;
<p>	routine_address                                          p. 25</p>

<p>		::=  <u>c-raddr</u>  body:tag    !   <u>nobody</u></p>

&nbsp;
<p>	record_value                                             p. 26</p>

<p>		::=  <u>c-record</u>  structured_type</p>

<p>		      &lt;attribute_value&gt;+  <u>endrecord</u></p>

&nbsp;
<p>	attribute_value                                          p. 26</p>

<p>		::=  <u>attr</u>  attribute:tag  type  repetition_value	 </p>

<p>	constant_declaration                                     p. 27</p>

<p>		::=  constant_specification  !  constant_definition</p>

&nbsp;
<p>	constant_specification                                   p. 27</p>

<p>		::=  <u>constspec</u>  const:newtag  quantity_descriptor</p>

&nbsp;
<p>	constant_definition                                      p. 27</p>

<p>		::=  <u>const</u>  const:spectag</p>

<p>		       quantity_descriptor  repetition_value</p>

&nbsp;
<p>	stack_instruction                                        p. 28</p>

<p>		::=  <u>push</u>   obj:tag   !  <u>pushv</u>  obj:tag</p>

<p>		::=  <u>pushc</u>  value     !  <u>pushlen</u>  !  <u>dup</u>  !  <u>pop</u>  !  <u>empty</u></p>

<p>		::=  <u>popall</u>  byte</p>

&nbsp;
<p>	assign_instruction                                       p. 28</p>

<p>		::=  <u>assign</u>   !   <u>update</u>   !   <u>rupdate</u></p>

&nbsp;
<p>	addressing_instruction                                   p. 31</p>

<p>		::=  <u>fetch</u>   !   <u>refer</u>  resolved_type   !   <u>deref</u></p>

<p>		::=  <u>select</u>  attribute:tag  !  <u>selectv</u>  attribute:tag</p>

<p>		::=  <u>remote</u>  attribute:tag  !  <u>remotev</u>  attribute:tag</p>

<p>		::=  <u>index</u>   !   <u>indexv</u></p>

<p>		::=  <u>inco</u>    !   <u>deco</u></p>

<p>		::=  <u>dist</u>    !   <u>dsize</u>  structured_type   !   <u>locate</u></p>

&nbsp;
<p>	protect_statement                                        p. 37</p>

<p>		::=  <u>save</u>  &lt;program_element&gt;*  <u>restore</u></p>

&nbsp;
<p>	temp_control                                             p. 37</p>

<p>		::=  <u>t-inito</u>   !   <u>t-geto</u>   !   <u>t-seto</u></p>

<p>&nbsp;</p>
<p>	access_instruction                                       p. 41</p>

<p>		::=  <u>setobj</u>    !   <u>getobj</u></p>

<p>		::=  <u>access</u>   oindex:byte  attribute:tag</p>

<p>		::=  <u>accessv</u>  oindex:byte  attribute:tag</p>

&nbsp;
<p>	arithmetic_instruction                                   p. 43</p>

<p>		::=  <u>add</u>  !  <u>sub</u>  !  <u>mult</u>  !  <u>div</u>  !  <u>rem</u>  !  <u>neg</u></p>

<p>		::=  <u>and</u>  !  <u>or</u>   !  <u>xor</u>   !  <u>imp</u>  !  <u>eqv</u>  !  <u>not</u></p>

<p>		::=  <u>compare</u>  relation</p>

&nbsp;
<p>	relation                                                 p. 45</p>

<p>		::=  <u>?lt</u>  !  <u>?le</u>  !  <u>?eq</u>   !  <u>?ge</u>  !  <u>?gt</u>  !  <u>?ne</u></p>

&nbsp;
<p>	convert_instruction                                      p. 46</p>

<p>		::=   <u>convert</u>  simple_type</p>

&nbsp;
<p>	label_declaration                                        p. 48</p>

<p>		::=  label_specification  !  label_definition</p>

&nbsp;
<p>	label_specification                                      p. 48</p>

<p>		::=  <u>labelspec</u>  label:newtag</p>

&nbsp;
<p>	label_definition                                         p. 48</p>

<p>		::=  <u>label</u>  label:spectag</p>

&nbsp;
<p>	goto_instruction                                         p. 48</p>

<p>		::=  <u>goto</u></p>

&nbsp;
<p>	jump_instruction                                         p. 49</p>

<p>		::=  forward_jump   !   forward_destination</p>

<p>		::=  backward_jump  !   backward_destination</p>

<p>&nbsp;</p>
<p>	forward_jump                                             p. 49</p>

<p>		::=  <u>switch</u>   switch:newtag  size:number</p>

<p>		::=  <u>fjumpif</u>  relation  destination:newindex</p>

<p>		::=  <u>fjump</u>    destination:newindex</p>

&nbsp;
<p>	forward_destination                                      p. 49</p>

<p>		::=  <u>sdest</u>    switch:tag  which:number</p>

<p>		::=  <u>fdest</u>    destination:index</p>

&nbsp;
<p>	backward_jump                                           p. 49</p>

<p>		::=  <u>bjump</u>    destination:index</p>

<p>		::=  <u>bjumpif</u>  relation  destination:index</p>

&nbsp;
<p>	backward_destination                                     p. 49</p>

<p>		::=  <u>bdest</u>    destination:newindex</p>

&nbsp;
<p>	skip_statement                                           p. 52</p>

<p>		::=  <u>skipif</u>  relation  &lt;program_element&gt;*  <u>endskip</u></p>

&nbsp;
<p>	skip_instruction                                         p. 52</p>

<p>		::=  <u>skipif</u>  relation  &lt;instruction&gt;*  <u>endskip</u></p>

&nbsp;
<p>	if_statement                                             p. 53</p>

<p>		::=  <u>if</u>  relation  &lt;program_element&gt;*  else_part</p>

&nbsp;
<p>	else_part                                                p. 53</p>

<p>		::=  <u>else</u>  &lt;program_element&gt;*  <u>endif</u></p>

<p>		::=  <u>endif</u></p>

&nbsp;
<p>	if_instruction                                           p. 53</p>

<p>		::=  <u>if</u>  relation  &lt;instruction&gt;*  i_else_part</p>

&nbsp;
<p>	i_else_part                                              p. 53</p>

<p>		::=  <u>else</u>  &lt;instruction&gt;*  <u>endif</u></p>

<p>		::=  <u>endif</u></p>

<p>&nbsp;</p>
<p>	segment_instruction                                      p. 55</p>

<p>		::=  <u>bseg</u>  &lt;program_element&gt;*  <u>eseg</u></p>

&nbsp;
<p>	routine_profile                                          p. 58</p>

<p>		::=  <u>profile</u>  profile:newtag  &lt;peculiar&gt;?</p>

<p>		      &lt;import_definition&gt;*   &lt;export_or_exit&gt;?</p>

<p>		     <u>endprofile</u></p>

&nbsp;
<p>	 peculiar                                                 p. 58</p>

<p>		::=  <u>known</u>      body:newtag  kid:string</p>

<p>		::=  <u>system</u>     body:newtag  sid:string</p>

<p>		::=  <u>external</u>   body:newtag  nature:string  xid:string</p>

<p>		::=  <u>interface</u>  pid:string</p>

&nbsp;
<p>	import_definition                                        p. 58</p>

<p>		::=  <u>import</u>   parm:newtag  quantity_descriptor</p>

&nbsp;
<p>	export_or_exit                                           p. 58</p>

<p>		::=  <u>export</u>   parm:newtag  export_type</p>

<p>		::=  <u>exit</u>     return:newtag</p>

&nbsp;
<p>	export_type                                              p. 58</p>

<p>		::=  resolved_type   !   <u>range</u></p>

&nbsp;
<p>	routine_specification                                    p. 61</p>

<p>		::=  <u>routinespec</u>   body:newtag  profile:tag</p>

&nbsp;
<p>	routine_definition                                       p. 61</p>

<p>		::=  <u>routine</u>  body:spectag  profile:tag</p>

<p>		      &lt;local_quantity&gt;*  &lt;instruction&gt;*</p>

<p>		     <u>endroutine</u></p>

&nbsp;
<p>	local_quantity                                           p. 61</p>

<p>		::=  <u>local</u>  var:newtag  quantity_descriptor</p>

<p>&nbsp;</p>
<p>	call_instruction                                         p. 63</p>

<p>		::=  connect_profile  &lt;parameter eval&gt;*</p>

<p>		       connect_routine</p>

&nbsp;
<p>	connect_profile                                          p. 63</p>

<p>		::=  <u>precall</u>  profile:tag</p>

<p>		::=  <u>asscall</u>  profile:tag</p>

<p>		::=  <u>repcall</u>  n:byte  profile:tag</p>

&nbsp;
<p>	 connect_routine                                          p. 63</p>

<p>		::=  <u>call</u>  body:tag   !   &lt;instruction&gt;+  <u>call-tos</u></p>

&nbsp;
<p>	parameter eval                                           p. 63</p>

<p>		::=  &lt;instruction&gt;+  <u>asspar</u></p>

<p>		::=  &lt;instruction&gt;+  <u>assrep</u>  n:byte</p>

&nbsp;
<p>	module_definition                                        p. 67</p>

<p>		::=  <u>module</u>  module_id:string  check_code:string</p>

<p>		       visible_existing</p>

<p>		     <u>body</u>  &lt;local_quantity&gt;* &lt;program_element&gt;* <u>endmodule</u></p>

&nbsp;
<p>	visible_existing</p>

<p>		::=  &lt;visible&gt;* tag_list    !   <u>existing</u></p>

&nbsp;
<p>	visible                                                  p. 67</p>

<p>		::=  record_descriptor      !   routine_profile</p>

<p>		::=  routine_specification  !   label_specification</p>

<p>		::=  constant_specification !   insert_statement</p>

<p>		::=  info_setting</p>

&nbsp;
<p>	tag_list                                                 p. 67</p>

<p>		::=  &lt; <u>tag</u>  internal:tag  external:number &gt;+</p>

&nbsp;
<p>	interface_module                                         p. 68</p>

<p>		::=  <u>global</u> <u>module</u>  module_id:string  checkcode:string</p>

<p>		      &lt;global interface&gt;*  tag_list</p>

<p>		     <u>body</u> &lt; <u>init</u> global:tag type repetition_value &gt;*</p>

<p>		     <u>endmodule</u></p>

&nbsp;
<p>	global_interface                                         p. 68</p>

<p>		::=  record_descriptor</p>

<p>		::=  constant_definition  &lt; <u>system</u>  sid:string &gt;?</p>

<p>		::=  global_definition    &lt; <u>system</u>  sid:string &gt;?</p>

<p>		::=  routine_profile</p>

<p>		::=  info_setting</p>

&nbsp;
<p>	global_definition                                        p. 68</p>

<p>		::=  <u>global</u>  internal:newtag  quantity_descriptor</p>

&nbsp;
<p>	macro_definition_module                                  p. 70</p>

<p>		::=  <u>macro</u>  <u>module</u>  module_id:string  checkcode:string</p>

<p>		      &lt;macro_definition&gt;*  <u>endmodule</u></p>

&nbsp;
<p>	macro_definition                                         p. 71</p>

<p>		::=  <u>macro</u>  macro_name:byte  macro_parcount:byte</p>

<p>		       <u>known</u>  macro_id:string</p>

<p>		      &lt;macro_body_element&gt;*</p>

<p>		     <u>endmacro</u></p>

&nbsp;
<p>	macro_body_element                                       p. 71</p>

<p>		::=  <u>mark</u>  macro_sequence:string</p>

<p>		::=  <u>mpar</u>  macro_parnumber:byte</p>

&nbsp;
<p>	macro_call                                               p. 71</p>

<p>		::=  <u>mcall</u>  macro_name:byte  &lt;actual_parameter:string&gt;*</p>

&nbsp;
<p>	insert_statement                                         p. 72</p>

<p>		::=  <u>insert</u>  module_id:string  check_code:string</p>

<p>		       external_id:string  tagbase:newtag</p>

<p>		       taglimit:newtag</p>

<p>		::=  <u>sysinsert</u>  module_id:string  check_code:string</p>

<p>		       external_id:string  tagbase:newtag</p>

<p>		       taglimit:newtag</p>

&nbsp;
<p>	area_initialisation                                      p. 73</p>

<p>		::=  <u>zeroarea</u></p>

<p>		::=  <u>initarea</u>   resolved_type</p>

<p>		::=  <u>dinitarea</u>  structured_type</p>

&nbsp;
<p>	eval_instruction                                         p. 75</p>

<p>		::=  <u>eval</u></p>

&nbsp;
<p>	 delete_statement                                         p. 75</p>

<p>		::=  <u>delete</u>  from:tag</p>

&nbsp;
<p>	info_setting                                             p. 76</p>

<p>		::=  <u>info</u>  string</p>

<p>		::=  <u>decl</u>  line:number</p>

<p>		::=  <u>line</u>  line:number</p>

<p>		::=  <u>stmt</u>  line:number</p>

<p>		::=  <u>setswitch</u>  switch:byte  setting:byte</p>

&nbsp;
<p>	byte</p>

<p>		::=  an (8-bit) unsigned integer value in the range 0..255.</p>

&nbsp;
<p>	number</p>

<p>		::=	a two-byte value greater than or equal to zero. A number (or any
other multi-byte structure) will always be transmitted with the most
significant byte first. Let the bytes be &lt;B1&gt;&lt;B2&gt; in that sequence; the
value will be 256 * B1 + B2 .</p>

&nbsp;
<p>	ordinal</p>

<p>		::=	a number with value greater than zero.</p>

&nbsp;
<p>	tag</p>

<p>		::=	An ordinal (the &quot;tag-value&quot;) associated with a descriptor. See section
2.4.</p>

<p>		::=	The number zero followed by an ordinal (the &quot;tag value&quot;) and an
identifying string. This second form is intended for debugging purposes, and is used to associate an identification to the tag.</p>

&nbsp;
<p>	newtag</p>

<p>		::=	A tag-value with no association, see section 2.4.</p>

&nbsp;
<p>	spectag</p>

<p>		::=	a tag-value which, if not undefined, must have been given an
association in a specification (<u>labelspec</u>, <u>constspec</u>, <u>routinespec</u>), see
section 2.4.</p>

&nbsp;
<p>	index</p>

<p>		::=	a byte within an implementation-defined range which identifies an
internal label. An important side effect of its occurrence is that it
looses its meaning. Thus an internal label can be the destination of
exactly one jump-instruction. See section 11.2.</p>

&nbsp;
<p>	newindex</p>

<p>		::=	an index-byte which is undefined; it becomes defined as an internal
label through its occurrence. See section 11.2.</p>

&nbsp;
<p>	string</p>

<p>		::=	a byte with the value N followed by N &quot;data bytes&quot;. The character
count N must be greater than zero, thus a string cannot be empty
(neither can a long_string, q.v.).</p>

&nbsp;
<p>	long_string</p>

<p>		::=	an ordinal with the value N followed by N &quot;data bytes&quot;.</p>

&nbsp;
<h2><strong>Appendix B</strong></h2>

&nbsp;
<p><u>Encoding of basic symbols</u></p>

<table border="1" width="100%">
  <tr>
    <td width="25%">	 0 - not used</td>
    <td width="25%">	 1 <u>record</u>		 </td>
    <td width="25%">		 2 not used</td>
    <td width="25%">	 3 <u>prefix</u></td>
  </tr>
  <tr>
    <td width="25%">	 4 <u>attr</u>		 </td>
    <td width="25%">		 5 not used</td>
    <td width="25%">	 6 <u>rep</u>		 </td>
    <td width="25%">		 7 <u>alt</u></td>
  </tr>
  <tr>
    <td width="25%">	 8 <u>fixrep</u>		 </td>
    <td width="25%">		 9 <u>endrecord</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	10 <u>c-record</u>	</td>
    <td width="25%">	11 <u>text</u>		</td>
    <td width="25%">		12 <u>c-char</u>		</td>
    <td width="25%">		13 <u>c-int</u></td>
  </tr>
  <tr>
    <td width="25%">	14 <u>c-size</u>		</td>
    <td width="25%">		15 <u>c-real</u>		</td>
    <td width="25%">		16 <u>c-lreal</u>	</td>
    <td width="25%">	17 <u>c-aaddr</u></td>
  </tr>
  <tr>
    <td width="25%">	18 <u>c-oaddr</u>	</td>
    <td width="25%">	19 <u>c-gaddr</u>	</td>
    <td width="25%">	20 <u>c-paddr</u>	</td>
    <td width="25%">	21 <u>c-dot</u></td>
  </tr>
  <tr>
    <td width="25%">	22 <u>c-raddr</u>	</td>
    <td width="25%">	23 <u>nobody</u>		</td>
    <td width="25%">		24 <u>anone</u>		</td>
    <td width="25%">		25 <u>onone</u></td>
  </tr>
  <tr>
    <td width="25%">	26 <u>gnone</u>		</td>
    <td width="25%">		27 <u>nowhere</u>	</td>
    <td width="25%">	28 <u>true</u>		</td>
    <td width="25%">		29 <u>false</u></td>
  </tr>
  <tr>
    <td width="25%">	30 <u>profile</u>	</td>
    <td width="25%">	31 <u>known</u>		</td>
    <td width="25%">		32 <u>system</u>		</td>
    <td width="25%">		33 <u>external</u></td>
  </tr>
  <tr>
    <td width="25%">	34 <u>import</u>		</td>
    <td width="25%">		35 <u>export</u>		</td>
    <td width="25%">		36 <u>exit</u>		</td>
    <td width="25%">		37 <u>endprofile</u></td>
  </tr>
  <tr>
    <td width="25%">	38 <u>routinespec</u>	</td>
    <td width="25%">	39 <u>routine</u>	</td>
    <td width="25%">	40 <u>local</u>		</td>
    <td width="25%">		41 <u>endroutine</u></td>
  </tr>
  <tr>
    <td width="25%">	42 <u>module</u>		&nbsp;</td>
    <td width="25%">		43 <u>existing</u>	</td>
    <td width="25%">	44 <u>tag</u>		</td>
    <td width="25%">		45 <u>body</u></td>
  </tr>
  <tr>
    <td width="25%">	46 <u>endmodule</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	47 <u>labelspec</u>	</td>
    <td width="25%">	48 <u>label</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	49 <u>range</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	50 <u>global</u>		</td>
    <td width="25%">		51 <u>init</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	52 <u>constspec</u>	</td>
    <td width="25%">	53 <u>const</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	54 <u>delete</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	55 <u>fdest</u>		</td>
    <td width="25%">		56 <u>bdest</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	57 <u>save</u>		</td>
    <td width="25%">		58 <u>restore</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	59 <u>bseg</u>		</td>
    <td width="25%">		60 <u>eseg</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	61 <u>skipif</u>		</td>
    <td width="25%">		62 <u>endskip</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	63 <u>if</u>		</td>
    <td width="25%">		64 <u>else</u>		</td>
    <td width="25%">		65 <u>endif</u>		</td>
    <td width="25%">		66 not used</td>
  </tr>
  <tr>
    <td width="25%">	67 <u>precall</u>	</td>
    <td width="25%">	68 <u>asspar</u>		</td>
    <td width="25%">		69 <u>assrep</u>		</td>
    <td width="25%">		70 <u>call</u></td>
  </tr>
  <tr>
    <td width="25%">	71 <u>fetch</u>		</td>
    <td width="25%">		72 <u>refer</u>		</td>
    <td width="25%">		73 <u>deref</u>		</td>
    <td width="25%">		74 <u>select</u></td>
  </tr>
  <tr>
    <td width="25%">	75 <u>remote</u>		</td>
    <td width="25%">		76 <u>locate</u>		</td>
    <td width="25%">		77 <u>index</u>		</td>
    <td width="25%">		78 <u>inco</u></td>
  </tr>
  <tr>
    <td width="25%">	79 <u>deco</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	80 <u>push</u>		</td>
    <td width="25%">		81 <u>pushc</u>		</td>
    <td width="25%">		82 <u>pushlen</u>	</td>
    <td width="25%">	83 <u>dup</u></td>
  </tr>
  <tr>
    <td width="25%">	84 <u>pop</u>		</td>
    <td width="25%">		85 <u>empty</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	86 <u>setobj</u>		</td>
    <td width="25%">		87 <u>getobj</u>		</td>
    <td width="25%">		88 <u>access</u></td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	89 <u>fjump</u>		</td>
    <td width="25%">		90 <u>bjump</u>		</td>
    <td width="25%">		91 <u>fjumpif</u>	</td>
    <td width="25%">	92 <u>bjumpif</u></td>
  </tr>
  <tr>
    <td width="25%">	93 <u>switch</u>		</td>
    <td width="25%">		94 <u>goto</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	95 <u>t-inito</u>	</td>
    <td width="25%">	96 <u>t-geto</u>		</td>
    <td width="25%">		97 <u>t-seto</u></td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	98 <u>add</u>		</td>
    <td width="25%">		99 <u>sub</u>		</td>
    <td width="25%">		100 <u>mult</u>		</td>
    <td width="25%">		101 <u>div</u></td>
  </tr>
  <tr>
    <td width="25%">	102 <u>rem</u>		</td>
    <td width="25%">		103 <u>neg</u>		</td>
    <td width="25%">		104 <u>and</u>		</td>
    <td width="25%">		105 <u>or</u></td>
  </tr>
  <tr>
    <td width="25%">	106 <u>xor</u>		</td>
    <td width="25%">		107 <u>imp</u>		</td>
    <td width="25%">		108 <u>eqv</u>		</td>
    <td width="25%">		109 <u>not</u></td>
  </tr>
  <tr>
    <td width="25%">	110 <u>dist</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	111 <u>assign</u>	</td>
    <td width="25%">	112 <u>update</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	113 <u>convert</u>	</td>
    <td width="25%">	114 <u>sysinsert</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	115 <u>insert</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	 116 <u>zeroarea</u>	</td>
    <td width="25%">	117 <u>initarea</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	118 <u>compare</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	119 <u>?lt</u>		</td>
    <td width="25%">		120 <u>?le</u>		</td>
    <td width="25%">		121 <u>?eq</u>		</td>
    <td width="25%">		122 <u>?ge</u></td>
  </tr>
  <tr>
    <td width="25%">	123 <u>?gt</u>		</td>
    <td width="25%">		124 <u>?ne</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	125 <u>eval</u>		&nbsp;</td>
    <td width="25%">		126 <u>info</u>		</td>
    <td width="25%">		127 <u>line</u>		</td>
    <td width="25%">		128 <u>setswitch</u></td>
  </tr>
  <tr>
    <td width="25%">	129 not used</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	130 <u>program</u>	</td>
    <td width="25%">	131 <u>main</u>		</td>
    <td width="25%">		132 <u>endprogram</u></td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	133 <u>dsize</u>		</td>
    <td width="25%">		134 <u>sdest</u>		</td>
    <td width="25%">		135 <u>rupdate</u>	</td>
    <td width="25%">	136 <u>asscall</u></td>
  </tr>
  <tr>
    <td width="25%">	137 <u>call-tos</u>	</td>
    <td width="25%">	138 <u>dinitarea</u>	</td>
    <td width="25%">	139 <u>nosize</u>	</td>
    <td width="25%">	140 <u>popall</u></td>
  </tr>
  <tr>
    <td width="25%">	141 <u>repcall</u>	</td>
    <td width="25%">	142 <u>interface</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	143 <u>macro</u>		</td>
    <td width="25%">		144 <u>mark</u>		</td>
    <td width="25%">		145 <u>mpar</u></td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	146 <u>endmacro</u>	</td>
    <td width="25%">	147 <u>mcall</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	148 <u>pushv</u>		</td>
    <td width="25%">		149 <u>selectv</u>	</td>
    <td width="25%">	150 <u>remotev</u>	</td>
    <td width="25%">	151 <u>indexv</u></td>
  </tr>
  <tr>
    <td width="25%">	152 <u>accessv</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	153 <u>decl</u>		</td>
    <td width="25%">		154 <u>stmt</u></td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="25%">	155 - 255 - reserved.</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
</table>

<br WP="BR1">
<p>	Predefined tags:</p>

<table border="1" width="100%">
  <tr>
    <td width="25%">	 0 - not used</td>
    <td width="25%">	1 BOOL</td>
    <td width="25%">		 2 CHAR</td>
    <td width="25%">		 3 INT</td>
  </tr>
  <tr>
    <td width="25%">	 4 SINT</td>
    <td width="25%">		5 REAL</td>
    <td width="25%">		 6 LREAL</td>
    <td width="25%">		 7 AADDR</td>
  </tr>
  <tr>
    <td width="25%">	 8 OADDR</td>
    <td width="25%">		9 GADDR</td>
    <td width="25%">		10 PADDR</td>
    <td width="25%">		11 RADDR</td>
  </tr>
  <tr>
    <td width="25%">	12 SIZE</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
    <td width="25%">&nbsp;</td>
  </tr>
  <tr>
    <td width="100%" colspan="4">	13-31   reserved, i.e. first program-defined tag will be 32.</td>
  </tr>
</table>

<br WP="BR1"><br WP="BR2">
<h2><strong>Appendix C</strong></h2>

&nbsp;
<p><u>Statutes for SG/PSS</u></p>

&nbsp;
<p><center><strong>STATUTES</center>
</strong></p>

<p><strong><center></strong></center>
</p>

<p><center>for the</center>
</p>

<p><center></center>
</p>

<p><center><u>STANDARDS GROUP</center>
</u></p>

<p><u><center></u></center>
</p>

<p><center>for the Portabls SIMULA System.</center>
</p>

<br WP="BR1">
<h4>Article 1. <u>Definitions</u></h4>

<p>The Portable SIMULA System (PSS) consists of a language dependent part and a target
dependent part. The interface between these two parts is at any time defined in the
documents:</p>

<blockquote>
<p>	S-PORT: Definition of S-code</p>

<p>	S-PORT: The Environment Interface</p>

</blockquote>
<p>The two documents comprise the PSS interface definition.</p>

<p>An S-compiler system is a system which is able to translate and execute programs
represented according to the PSS interface definition.</p>

<p>&nbsp;</p>

<h4>Article 2. <u>Objectives</u></h4>

<p>The Standards Group for the Portable SIMULA System (SG/PSS) is an organisation which
at all times shall:</p>

<ul>
  <li>be the final arbiter in the interpretation of the PSS interface definition and be
a center for custody of this formal definition.</li>
  <li>provide a forum for discussion and exchange of information relating to the
PSS interface definition and its support.</li>
  <li>standardise the PSS interface definition and modify the definition when this
is found necessary.</li>
</ul>
<p>&nbsp;</p>
<h4>Article 3. <u>Membership</u></h4>

<p>Membership is open to organisations and firms responsible for the maintenance and
support of an S-compiler system in active use. Any organisation may apply and be voted a
member of the SG/PSS.</p>

<p>The Norwegian Computing Center (NCC), Oslo, Norway and the Edinburgh Regional
Computing Center (ERCC), Edinburgh, Scotland are ex officio members of the SG/PSS.
The NCC will also act as the secretariat of the SG/PSS.</p>

<p>The SG/PSS can offer membership to individuals, in recognition of their contribution to the
SG/PSS work.</p>

<p>Once granted, an SG/PSS membership lasts until:</p>

<ul>
  <li>it is resigned by the member, or</li>
  <li>it is revoked by the SG/PSS because the conditions under which it was
granted cease to exist or the member acts against the objectives of the
SG/PSS.</li>
</ul>
<p>There is no membership fee for the SG/PSS. Members must cover their own
expences.</p>

<p>&nbsp;</p>

<h4>Article 4. <u>Representation, Voting and Meetings</u></h4>

<p>Each member shall appoint one person to be his/her representative in the SG/PSS. The
duration of appointment is determined by the members.</p>

<p>The SG/PSS shall meet once every year for an Annual Meeting. This meeting will, in
addition to possible administrative matters, handle proposals related to the PSS interface
definition. The Annual Meeting shall also elect one of the member's representatives as
Chairman for the Standards Group.</p>

<p>Decisions can only be taken regarding matters on the agenda presented to the members
at least 3 weeks before the meeting, unless all members present agree otherwise.</p>

<p>In addition to the Annual Meeting SG/PSS may have extraordinary meetings. Such
meetings are held when the Chairman finds it necessary, or when this is approved by a
majority of the members.</p>

<p>To constitute a quorum, all members of the SG/PSS shall be notified of the meeting and a
majority of the members representatives shall be present or give their votes by mail,
including the NCC and ERCC representatives.</p>

<p>Decisions by SG/PSS are made by a majority vote among the representatives taking part
in the vote. Changes to the statutes for the SG/PSS or a decision to dissolve the SG/PSS
require 4/5 majority. Any decision requires the consent of the NCC.</p>

<p>The SG/PSS meetings are open to non-representatives or non-members. Observers have
no voting rights, and must apply to the Chairman of the SG/PSS for each meeting they
wish to attend.</p>

&nbsp;
<h4>Article 5. <u>Effectuation and revisions</u></h4>

<p>These statutes were adopted at the Foundation Meeting of the Standards Group for the
Portable SIMULA System in Edinburgh the 3rd March 1981 and come into effect
immediately.</p>

&nbsp;
<h3><u>Formal rules of the SG/PSS operation</u></h3>

&nbsp;
<p>1.	The main task of the SG/PSS is the maintenance of the PSS interface definition. Its
work consists of:</p>

<ol type="a">
  <li>a clarification of obscure parts of the definition.</li>
  <li>removal of eventual conflicts in the definition.</li>
  <li>alteration of the definition when necessary.</li>
</ol>
&nbsp;
<p>2.	The following types of changes in the definition can be directly considered by
SG/PSS:</p>

<ol type="a">
  <li>obvious oversights that have occurred in the text of the definition.</li>
  <li>removal of language restrictions that are proved obsolete for consistency
and implementation.</li>
  <li>trivial extensions to the existing concepts that are felt relevant for continued
use of the definition in changing environments.</li>
  <li>any other changes as long as none of the members are against it.</li>
</ol>
<p>&nbsp;</p>
<p>3.	Any other changes than those mentioned in point 2 above can also be considered.
These changes must, however, be submitted to the secretariat two (2) months prior
to the meeting. Submitted proposals will be distributed to the members without
delay, to facilitate inclusion of relevant comments in the material presented with the
meeting agenda at least three (3) weeks before said meeting.</p>

&nbsp;
<p>4.	All proposals for changes in the PSS interface definition conforming with the above
rules must be formulated in writing in a concise manner and submitted to the
secretariat. Anyone may submit such a proposal.</p>

&nbsp;
<p>5.	The Chairman of the SG/PSS is responsible for confirming receipt of each
proposal, registering it and scheduling its processing at one of the meetings of the
SG/PSS. Alternatively the Chairman may point out any inadequacies in a proposal
to its submitter.</p>

<p>	The proposal will be announced at the subsequent SG/PSS meeting which may
approve or revoke the Chairman's decision related to this proposal.</p>

<p>	Complete material related to a proposal will be submitted to the members when the
proposal is processed at the next meeting or by specific request.</p>

&nbsp;
<p>6.	In its final form every proposal will be an updating text to one of the documents
comprising the PSS interface definition. It will further indicate the original submitter,
date of submission and its motivation. Alternative forms of the proposal and
reasons for their rejection are a valuable part of the document. An example of a
suitable form is attached to these rules.</p>

<p>	The logical consistency of the text, its clarity and conciseness are of utmost
importance. To this end the SG/PSS or its Chairman may allocate one particular
member to bring the proposal into the required shape if this is deemed necessary.</p>

&nbsp;
<p>7.	It is the responsability of the Chairman to notify the submitter of a proposal about
the result of its processing by the SG/PSS if this is not otherwise obvious. It is also
his/her responsibility to minimize the time taken over each proposal.</p>

&nbsp;
<p>8.	The final text of the proposals will be available from the secratariat as a
supplement to the PSS interface definition until they are incorporated into the
definition at the next revision of the documents. To facilitate this process, at its
approval a proposal will be assigned a number reflecting which of the documents it
refers to and its chronological order.</p>

<p>&nbsp;</p>
<h3>&nbsp;</h3>

<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="3">
      <h3>Proposal for changing the Portable SIMULA System interface definition.</h3>
    </td>
  </tr>
  <tr>
    <td width="100%" colspan="3">
<p>Document affected:</p>

<p>Submitter:</p>

<p>Date:</p>

<p>Title of proposal:</p>

<p>Affected section:</p>

      <p>&nbsp;</td>
  </tr>
  <tr>
    <td width="100%" colspan="3">
<p><u>Proposal</u>:</p>

<br WP="BR1">
      <p>&nbsp;</td>
  </tr>
  <tr>
    <td width="100%" colspan="3">
<p><u>Motivation</u>:</p>

<br WP="BR1"><br WP="BR2">
      <p>&nbsp;</td>
  </tr>
  <tr>
    <td width="100%" colspan="3"><u><b>SG/PSS decision on the above proposal</b></u></td>
  </tr>
  <tr>
    <td width="34%">For:</td>
    <td width="33%">               Against:</td>
    <td width="33%">                Abstained:</td>
  </tr>
</table>

<br WP="BR1">
<h2><strong>Index of Keywords</strong></h2>

&nbsp;
<p>				?eq 	 67</p>

<p>				?ge 	 67</p>

<p>				?gt 	 67</p>

<p>				?le 	 67</p>

<p>				?lt 	 67</p>

<p>				?ne 	 67</p>

<p>				AADDR 	 13, 24, 31</p>

<p>				Access 	 63</p>

<p>				Access instruction 	 61</p>

<p>				Accessv 	 63</p>

<p>				Add 	 64</p>

<p>				Addressing instruction 	 45</p>

<p>				Alt 	 29</p>

<p>				Alternate part 	 29</p>

<p>				And 	 66</p>

<p>				Anone 	 37</p>

<p>				Area 	 8</p>

<p>				Area initialisation 	 109</p>

<p>				Arithmetic instruction 	 64</p>

<p>				Asscall 	 96</p>

<p>				Assign 	 43</p>

<p>				Assign instruction 	 41</p>

<p>				Asspar 	 97</p>

<p>				Assrep 	 97</p>

<p>				Atomic unit 	 8</p>

<p>				Attr 	 38</p>

<p>				Attribute address 	 24, 37</p>

<p>				Attribute definition 	 29</p>

<p>				Attribute value 	 38</p>

<p>				Backward destination 	 73</p>

<p>				Backward jump 	 73</p>

<p>				BASE 	 13</p>

<p>				Bdest 	 77</p>

<p>				Bjump 	 77</p>

<p>				Bjumpif 	 77</p>

<p>				Body 	 88, 91, 99</p>

<p>				BOOL 	 23</p>

<p>				Boolean value 	 35</p>

<p>				Bseg 	 84</p>

<p>				Byte 	 20</p>

<p>				C-aaddr 	 37</p>

<p>				C-char 	 35</p>

<p>				C-dot 	 37</p>

<p>				C-gaddr 	 37</p>

<p>				C-int 	 35</p>

<p>				C-lreal 	 36</p>

<p>				C-oaddr 	 37</p>

<p>				C-paddr 	 38</p>

<p>				C-raddr 	 38</p>

<p>				C-real 	 36</p>

<p>				C-record 	 38</p>

<p>				C-size 	 36</p>

<p>				Call 	 95</p>

<p>				Call instruction 	 94</p>

<p>				Call-tos 	 98</p>

<p>				CHAR 	 23</p>

<p>				Character value 	 35</p>

<p>				Check code 	 99, 101, 104</p>

<p>				Common part 	 29</p>

<p>				Compare 	 66</p>

<p>				Complete descriptor 	 9</p>

<p>				Connect profile 	 94</p>

<p>				Connect routine 	 94</p>

<p>				Const 	 40</p>

<p>				Constant area 	 9</p>

<p>				Constant declaration 	 40</p>

<p>				Constant definition 	 40</p>

<p>				Constant specification 	 40</p>

<p>				Constspec 	 40</p>

<p>				Convert 	 69</p>

<p>				Convert instruction 	 69</p>

<p>				Current program point 	 9</p>

<p>				Decl 	 114</p>

<p>				Deco 	 50</p>

<p>				Delete 	 113</p>

<p>				Delete statement 	 113</p>

<p>				Deref 	 46</p>

<p>				Descriptor 	 9, 85</p>

<p>				Dinitarea 	 111</p>

<p>				Dist 	 50</p>

<p>				Div 	 64</p>

<p>				Dsize 	 51</p>

<p>				Dup 	 42</p>

<p>				DYNAMIC 	 29, 51</p>

<p>				Dynamic quantity 	 9</p>

<p>				Else 	 82</p>

<p>				Else part 	 80</p>

<p>				Empty 	 43</p>

<p>				Endif 	 82</p>

<p>				Endmacro 	 105</p>

<p>				Endmodule 	 99, 104</p>

<p>				Endprofile 	 86</p>

<p>				Endprogram 	 18</p>

<p>				Endrecord 	 29, 38</p>

<p>				Endroutine 	 91, 93</p>

<p>				Endskip 	 79</p>

<p>				Eqv 	 66</p>

<p>				Eseg 	 84</p>

<p>				Eval 	 112</p>

<p>				Eval instruction 	 112</p>

<p>				Existing 	 99</p>

<p>				Exit 	 85, 86</p>

<p>				Export 	 86</p>

<p>				Export or exit 	 86</p>

<p>				External 	 89</p>

<p>				False 	 35</p>

<p>				Fdest 	 76</p>

<p>				Fetch 	 45</p>

<p>				Fixrep 	 29</p>

<p>				Fjump 	 76</p>

<p>				Fjumpif 	 76</p>

<p>				Forward destination 	 73</p>

<p>				Forward jump 	 73</p>

<p>				GADDR 	 24</p>

<p>				General address 	 13, 24, 37</p>

<p>				Getobj 	 62</p>

<p>				Global 	 101</p>

<p>				Global definition 	 101</p>

<p>				Global interface 	 101</p>

<p>				Gnone 	 37</p>

<p>				Goto 	 72</p>

<p>				Goto instruction 	 71</p>

<p>				I else part 	 80</p>

<p>				If 	 81</p>

<p>				If instruction 	 80</p>

<p>				If statement 	 80</p>

<p>				Imp 	 66</p>

<p>				Import 	 86</p>

<p>				Import definition 	 86</p>

<p>				Inco 	 50</p>

<p>				Index 	 21, 49</p>

<p>				Indexv 	 50</p>

<p>				Info 	 29, 114</p>

<p>				Info setting 	 114</p>

<p>				Init 	 101, 102</p>

<p>				Initarea 	 110</p>

<p>				Insert 	 107</p>

<p>				Insert statement 	 107</p>

<p>				Instruction 	 18</p>

<p>				INT 	 22, 23</p>

<p>				Integer value 	 35</p>

<p>				Interface 	 90</p>

<p>				Interface module 	 101</p>

<p>				Jump instruction 	 73</p>

<p>				Known 	 88</p>

<p>				Label 	 72</p>

<p>				Label declaration 	 71</p>

<p>				Label definition 	 71</p>

<p>				Label specification 	 71</p>

<p>				Labelspec 	 72</p>

<p>				Line 	 114</p>

<p>				Local 	 92</p>

<p>				Local quantity 	 91</p>

<p>				Locate 	 52</p>

<p>				Long string 	 34</p>

<p>				Longreal value 	 36</p>

<p>				LREAL 	 23</p>

<p>				Macro 	 105</p>

<p>				Macro body element 	 105</p>

<p>				Macro call 	 106</p>

<p>				Macro definition 	 105</p>

<p>				Macro definition module 	 104</p>

<p>				Main 	 18</p>

<p>				Mark 	 105</p>

<p>				MAXLEN 	 102</p>

<p>				Mcall 	 106</p>

<p>				MODE 	 14</p>

<p>				Module 	 99</p>

<p>				Module definition 	 99</p>

<p>				Mpar 	 105</p>

<p>				Mult 	 64</p>

<p>				Neg 	 65</p>

<p>				Newindex 	 21</p>

<p>				Newtag 	 20</p>

<p>				Nobody 	 38</p>

<p>				Nosize 	 24, 36</p>

<p>				Not 	 66</p>

<p>				Nowhere 	 38</p>

<p>				Number 	 20</p>

<p>				OADDR 	 13</p>

<p>				Object 	 8</p>

<p>				Object address 	 24, 37</p>

<p>				Object unit 	 8</p>

<p>				OFFSET 	 13</p>

<p>				Onone 	 37</p>

<p>				Or 	 66</p>

<p>				Ordinal 	 20</p>

<p>				PADDR 	 25</p>

<p>				Parameter eval 	 94</p>

<p>				Peculiar 	 86</p>

<p>				Pop 	 42</p>

<p>				Popall 	 43</p>

<p>				Precall 	 95</p>

<p>				Prefix 	 29, 30</p>

<p>				Prefix part 	 29</p>

<p>				Profile 	 85, 86</p>

<p>				Program 	 18</p>

<p>				Program address 	 25, 38</p>

<p>				Program body 	 18</p>

<p>				Program element 	 18</p>

<p>				Protect instruction 	 53</p>

<p>				Protect statement 	 53</p>

<p>				Push 	 41</p>

<p>				Pushc 	 42</p>

<p>				Pushlen 	 56</p>

<p>				Pushv 	 41</p>

<p>				Quantity 	 8</p>

<p>				Quantity descriptor 	 26</p>

<p>				RADDR 	 25</p>

<p>				Range 	 20, 22, 26</p>

<p>				REAL 	 23</p>

<p>				Real value 	 36</p>

<p>				Record 	 8, 29</p>

<p>				Record descriptor 	 29</p>

<p>				Record info 	 29</p>

<p>				Record value 	 38</p>

<p>				REF 	 14</p>

<p>				Refer 	 46</p>

<p>				Relation 	 67</p>

<p>				Rem 	 65</p>

<p>				Remote 	 48</p>

<p>				Remotev 	 49</p>

<p>				Rep 	 26, 28</p>

<p>				Repcall 	 96</p>

<p>				Repetition value 	 34</p>

<p>				Resolved structure 	 29</p>

<p>				Resolved type 	 22</p>

<p>				Restore 	 58</p>

<p>				Routine 	 93</p>

<p>				Routine address 	 25, 38</p>

<p>				Routine body 	 85</p>

<p>				Routine definition 	 91</p>

<p>				Routine profile 	 85, 86</p>

<p>				Routine specification 	 91</p>

<p>				Routinespec 	 91</p>

<p>				Rupdate 	 44</p>

<p>				S-program 	 10, 18</p>

<p>				Save 	 57</p>

<p>				Sdest 	 75</p>

<p>				Segment 	 9</p>

<p>				Segment instruction 	 83</p>

<p>				Select 	 47</p>

<p>				Selectv 	 48</p>

<p>				Setobj 	 62</p>

<p>				Setswitch 	 114</p>

<p>				Simple type 	 15, 23</p>

<p>				SINT 	 22</p>

<p>				SIZE 	 24</p>

<p>				Size value 	 36</p>

<p>				Skip instruction 	 78</p>

<p>				Skip statement 	 78</p>

<p>				Skipif 	 78</p>

<p>				Spectag 	 20</p>

<p>				Stack 	 9, 17</p>

<p>				Stack instruction 	 41</p>

<p>				Static quantity 	 9</p>

<p>				Stmt 	 114</p>

<p>				String 	 21</p>

<p>				Structured type 	 29</p>

<p>				Sub 	 64</p>

<p>				Switch 	 75</p>

<p>				Sysinsert 	 107</p>

<p>				System 	 89</p>

<p>				T-geto 	 59</p>

<p>				T-inito 	 59</p>

<p>				T-seto 	 60</p>

<p>				Tag 	 16, 20</p>

<p>				Tag list 	 99</p>

<p>				Temp control 	 53</p>

<p>				Text 	 34</p>

<p>				Text value 	 34</p>

<p>				True 	 35</p>

<p>				TYPE 	 15, 22, 29</p>

<p>				Update 	 44</p>

<p>				VAL 	 14</p>

<p>				Value 	 34</p>

<p>				Var 	 91</p>

<p>				Visible 	 99</p>

<p>				Visible existing 	 99</p>

<p>				VOID 	 15</p>

<p>				Xor 	 66</p>

<p>				Zeroarea 	 110</p>

&nbsp;
</body>
</html>
