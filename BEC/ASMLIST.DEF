Module ASMLIST("iAPX");
begin insert SCOMN,SKNWN,SBASE;
       -----------------------------------------------------------------
       ---  COPYRIGHT 1988 by                                        ---
       ---  Simula a.s.                                              ---
       ---  Oslo, Norway                                             ---
       ---                                                           ---
       ---                                                           ---
       ---              P O R T A B L E     S I M U L A              ---
       ---                                                           ---
       ---                   F O R    I B M    P C                   ---
       ---                                                           ---
       ---                                                           ---
       ---           S   -   C   O   M   P   I   L   E   R           ---
       ---                                                           ---
       ---              Q - C o d e    U t i l i t i e s             ---
       ---                                                           ---
       ---                                                           ---
       ---  Selection Switches:                                      ---
       ---                                                           ---
       ---     A - Includes Assembly Output                          ---
       ---     C - Includes Consistency Checks                       ---
       ---     D - Includes Tracing Dumps                            ---
       ---     S - Includes System Generation                        ---
       ---     E - Extended mode -- 32-bit 386                       ---
       ---     V - New version. (+V:New, -V:Previous)                ---
       -----------------------------------------------------------------


Define Q_OPRATR=16,I_LABEL=41,I_OPERATOR=48,I_OPERAND=55
Define P_FLAG=0,P_SEG=2,P_RELA=6,P_VAL=30;

%+A  const range(0:19) a_dyad(20) =
%+A (0,qAND,qOR,qXOR,qAND,qOR,qXOR,qADD,qSUB,qCMP,
%+A    qADD,qSUB,qADD,qSUB,qADC,qSBB,qADD,qSUB,qADC,qSBB);

%+A Range(0:16000) LoopLab;
%+A Infix(WORD)   CurSegid;
%+A boolean ListI;

%title ***  D a t a    L i s t i n g    R o u t i n e s  ***

%+A Visible Routine ListDataLabel;
%+A import infix(WORD) smbx; range(0:MaxWord) fixno;
%+A begin AsmSection(DSEGID); setpos(sysout,I_LABEL);
%+A       if smbx.val>0
%+A       then outsymb(smbx); setpos(sysout,I_OPERATOR);
%+A            outstring("LABEL  WORD"); OutListing;
%+A            setpos(sysout,I_OPERATOR); outstring("PUBLIC   ");
%+A            outsymb(smbx);
%+A       else outstring("?FIX"); outword(fixno);
%+A            setpos(sysout,I_OPERATOR); outstring("LABEL  WORD");
%+A       endif;
%+A       OutListing;
%+A end;

%+A Visible Routine ListZero; import range(0:MaxWord) n;
%+A begin
%+AE      infix(wWORD) ofst32;
%+A       AsmSection(DSEGID);
%+A %-E   ListNewLine(DBUF.ofst.val+DBUF.nxt);
%+AE      ofst32.HighWord.val:=DBUF.ofstHI;
%+AE      ofst32.LowWord.val:=DBUF.ofstLO;
%+AE      ListNewLine(ofst32.val+DBUF.nxt);
%+A       setpos(sysout,I_OPERATOR);
%+A       if    n=1 then outstring("DB 0")
%+A       elsif n=2 then outstring("DW 0")
%+A       elsif n=4 then outstring("DD 0")
%+A       else outstring("DB ");
%+A            outword(n); outstring(" DUP(0)");
%+A       endif; OutListing;
%+A end;

%+A Routine ListNewLine; import range(0:MaxWord) rela;
%+A begin printout(inptrace); setpos(sysout,P_FLAG); outchar('D');
%+A       setpos(sysout,P_RELA); edhex(sysout,rela,4); setpos(sysout,P_VAL);
%+A end;

%+A Visible Routine ListData;
%+A import range(0:MaxWord) n; name() gadr;
%+A begin name(character) chradr; range(0:MaxWord) i,p;
%+AE      infix(wWORD) ofst32;
%+A       chradr:=gadr; i:=0; p:=0;
%+A       AsmSection(DSEGID);
%+A %-E   ListNewLine(DBUF.ofst.val+DBUF.nxt);
%+AE      ofst32.HighWord.val:=DBUF.ofstHI;
%+AE      ofst32.LowWord.val:=DBUF.ofstLO;
%+AE      ListNewLine(ofst32.val+DBUF.nxt);
%+A       repeat while n > 0
%+A       do if p > 8 then p:=0; OutListing endif;
%+A          if p=0 then setpos(sysout,I_OPERATOR); outstring("DB ");
%+A          else outchar(',') endif;
%+A          outword(var(chradr)(i) qua integer);
%+A          i:=i+1; p:=p+1; n:=n-1;
%+A       endrepeat;
%+A       OutListing;
%+A end;

%+A Visible Routine List1Data; import range(0:MaxByte) v;
%+A begin
%+AE      infix(wWORD) ofst32;
%+A       AsmSection(DSEGID);
%+A %-E   ListNewLine(DBUF.ofst.val+DBUF.nxt);
%+AE      ofst32.HighWord.val:=DBUF.ofstHI;
%+AE      ofst32.LowWord.val:=DBUF.ofstLO;
%+AE      ListNewLine(ofst32.val+DBUF.nxt);
%+A       setpos(sysout,I_OPERATOR); outstring("DB ");
%+A       outword(v); OutListing;
%+A end;

%+A Visible Routine List2Data; import range(0:MaxWord) v;
%+A begin
%+AE      infix(wWORD) ofst32;
%+A       AsmSection(DSEGID);
%+A %-E   ListNewLine(DBUF.ofst.val+DBUF.nxt);
%+AE      ofst32.HighWord.val:=DBUF.ofstHI;
%+AE      ofst32.LowWord.val:=DBUF.ofstLO;
%+AE      ListNewLine(ofst32.val+DBUF.nxt);
%+A       setpos(sysout,I_OPERATOR); outstring("DW ");
%+A       outword(v); OutListing;
%+A end;

%+A Visible Routine List4Data; import integer v;
%+A begin
%+AE      infix(wWORD) ofst32;
%+A       AsmSection(DSEGID);
%+A %-E   ListNewLine(DBUF.ofst.val+DBUF.nxt);
%+AE      ofst32.HighWord.val:=DBUF.ofstHI;
%+AE      ofst32.LowWord.val:=DBUF.ofstLO;
%+AE      ListNewLine(ofst32.val+DBUF.nxt);
%+A       setpos(sysout,I_OPERATOR); outstring("DD ");
%+A       outint(v); OutListing;
%+A end;

%+A Visible Routine ListAddrData; import infix(MemAddr) a;
%+A begin
%+AE      infix(wWORD) ofst32;
%+A       AsmSection(DSEGID);
%+A %-E   ListNewLine(DBUF.ofst.val+DBUF.nxt);
%+AE      ofst32.HighWord.val:=DBUF.ofstHI;
%+AE      ofst32.LowWord.val:=DBUF.ofstLO;
%+AE      ListNewLine(ofst32.val+DBUF.nxt);
%+A       setpos(sysout,I_OPERATOR); outstring("DD ");
%+A       if a.kind=0 then outchar('0');
%+A       else outadr(a) endif; OutListing;
%+A end;

%+A Visible Routine ListOfstData; import infix(MemAddr) a;
%+A begin
%+AE      infix(wWORD) ofst32;
%+A       AsmSection(DSEGID);
%+A %-E   ListNewLine(DBUF.ofst.val+DBUF.nxt);
%+AE      ofst32.HighWord.val:=DBUF.ofstHI;
%+AE      ofst32.LowWord.val:=DBUF.ofstLO;
%+AE      ListNewLine(ofst32.val+DBUF.nxt);
%+A       setpos(sysout,I_OPERATOR); outstring("DW ");
%+A       if a.kind=0 then outchar('0');
%+A       else outadr(a) endif; OutListing;
%+A end;
%page

%+A Visible Routine ListENDASM;
%+A begin infix(WORD) i,id,segx; range(0:MaxWord) rela;
%+A       infix(Fixup) Fx;
%+A   --- Edit and print location counter table
%+A   outstring("Location Counters:"); i.val:=0; setpos(sysout,23);
%+A   repeat while i.val < DIC.nSegm
%+A   do i.val:=i.val+1; id:=DIC.Segm(i.HI).elt(i.LO);
%+A      rela:=DICREF(id) qua Segment.rela.val;
%+A      if rela <> 0
%+A      then outsymb(id); outchar('=');
%+A           edhex(sysout,rela,4);
%+A           if sysout.pos<55 then outstring("  ")
%+A           else outimage; setpos(sysout,23) endif;
%+A      endif;
%+A   endrepeat; outimage;

%+A   --- Edit and print external references table
%+A   outstring("External References:"); i.val:=0; setpos(sysout,23);
%+A   repeat while i.val < DIC.nExtr
%+A   do i.val:=i.val+1; id:=DIC.Extr(i.HI).elt(i.LO);
%+A      outsymb(DICREF(id) qua Extern.segid);
%+A      outchar(':'); outsymb(id);
%+A      if sysout.pos<55 then outstring("  ")
%+A      else outimage; setpos(sysout,23) endif;
%+A   endrepeat; outimage;

%+A   --- Edit and print external definitions table
%+A   outstring("Public Definitions:"); i.val:=0; setpos(sysout,23);
%+A   repeat while i.val < DIC.nPubl
%+A   do i.val:=i.val+1; id:=DIC.Publ(i.HI).elt(i.LO);
%+A      segx:=DICREF(id) qua Public.segx;
%+A      rela:=DICREF(id) qua Public.rela.val;
%+A      outsymb(id); outchar('=');
%+A      outsymb(DIC.Segm(segx.HI).elt(segx.LO));
%+A      if rela <> 0
%+A      then outchar('+'); outword(rela) endif;
%+A      if sysout.pos<55 then outstring("  ")
%+A      else outimage; setpos(sysout,23) endif;
%+A   endrepeat; outimage;

%+A   --- Edit and print FIXUP table
%+A   outstring("FIXUP Definitions:"); i.val:=0; setpos(sysout,23);
%+A   repeat while i.val < nFIX
%+A   do outstring("FIXUP("); outword(i.val); outstring(")=");
%+A      Fx:=FIXTAB(i.HI).elt(i.LO);
%+A      EdFixup(sysout,Fx); outstring("(line ");
%+A      outint(Fx.line); outstring(")");
%+A      if sysout.pos<40 then outstring("  ")
%+A      else outimage; setpos(sysout,23) endif;
%+A      i.val:=i.val+1;
%+A   endrepeat; outimage;
%+A end;

%title ***   A s s e m b l y    L i s t i n g    R o u t i n e   ***
%+A Visible Routine AsmSection; import infix(WORD) segid;
%+A begin infix(WORD) segx; PrintOut(Sysout);
%+A       if segid <> CurSegid
%+A       then setpos(sysout,I_LABEL); outstring("#");
%+A            segx:=PutSegx(segid); outword(segx.val);
%+A            OutListing; CurSegid:=segid;
%+A       endif;
%+A end;

%+A Routine I_CODE;
%+A begin putpos(sysout,37); outstring("==>"); setpos(sysout,I_OPERATOR) end;

%+A Routine OutListing;
%+A begin infix(string) s; range(0:MaxWord) p; p:=sysout.pos;
%+A   repeat while p > 0
%+A   do p:=p-1; if sysout.chr(p) <> ' ' then goto L endif; endrepeat;
%+A   goto E;  L: sysout.pos:=p+1;
%+A   if asmgen
%+A   then if sysout.pos > I_LABEL
%+A        then s.chradr:=@sysout.chr(I_LABEL);
%+A             s.nchr:=sysout.pos - I_LABEL;
%+A             EnvOutImage(scrfile,s);
%+A             if status>0 then FILERR(scrfile,"COASM.OutListing") endif;
%+A        endif;
%+A   endif;
%+A   if    listq1>0 then printout(sysout)
%+A   elsif listq2>0 then printout(sysout)
%+A   elsif listsw>0 then printout(sysout)
%+A   else pickup(sysout) endif;
%+A E:end;

%+A Routine I_LINE;
%+A begin OutListing; setpos(sysout,I_OPERATOR) end;

%+A %-E Routine edASSUME;
%+A %-E import range(0:nregs) segreg; infix(WORD) segid;
%+A %-E begin I_LINE; outstring("ASSUME ");
%+A %-E       outreg(segreg); outchar(':');
%+A %-E       if segid=DGROUP then outstring("DGROUP")
%+A %-E       elsif segid.val=0 then outstring("NOTHING")
%+A %-E       else outsymb(segid) endif;
%+A %-E end;

%+A Visible Routine AsmListing;
%+A import infix(wWORD) rela; ref(Qpkt) qi; Boolean Alist;
%+A begin range(0:nregs) qreg,qreg2;  -- Q-Code registers
%+A   range(0:7) reg,reg2;            -- I-Code registers
%+A   range(0:20) subc;
%+A   infix(MemAddr) opr; ref(Qfrm6) dst;
%+A   infix(wWORD) cnst;
%+A   range(0:MaxWord) i; infix(WORD) ix,fix;
%+A   Boolean OvflTail;
%+A   infix(ValueItem) val;
%+A   range(0:MaxByte) fmf;
%+AE  range(0:MaxByte) fSD,fwf,fSP,tx,fx,qereg,ereg; infix(String) opc;

%+A   qreg:=qi.reg; subc:=qi.subc; OvflTail:=false; ListI:=Alist;

%+A   if InputTrace > 0 then printout(inptrace) endif;
%+A   setpos(sysout,P_FLAG);
%+A   if listq2>2 then outchar('P');
%+A      setpos(sysout,P_SEG); edhex(sysout,CSEGID.val,2);
%+A      setpos(sysout,P_RELA) endif;
%+A   if rela.val<>0 then edhex(sysout,rela.val,4) endif;
%+A   if    qi.type=cANY then outstring(" ANY ")
%+A   elsif qi.type=cVAL then outstring(" VAL ")
%+A   elsif qi.type=cOBJ then outstring(" OBJ ")
%+A   elsif qi.type=cSTP then outstring(" STP ")
%+A   elsif qi.type=cADR then outstring(" ADR ") endif;
%+A   if listq2>2 then setpos(sysout,Q_OPRATR) endif;
%+A   case 0:qMXX (qi.fnc);
%+A   when qPUSHR: ------ PUSHR   reg ----------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("PUSHR  "); outreg(subc);
%+A        if Alist
%+A        then I_CODE;
%+A             outstring("PUSH   "); outreg(WholeReg(subc));
%+A        endif;
%+A   when qPOPR: ------- POPR    reg ----------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("POPR   "); outreg(subc);
%+A        if Alist
%+A        then I_CODE;
%+A             outstring("POP    "); outreg(WholeReg(subc));
%+A %-E         if subc >= qES then edASSUME(subc,DumSEG) endif;
%+A        endif;
%+A   when qPUSHC: ------ PUSHC   reg const ----------------  Format 2
%+A                ------ PUSHC   reg fld addr -------------  Format 2b
%+A        --- Q-Code:
%+A        outstring("PUSHC  "); outreg(qreg);
%+A        outchar(','); edval(qi);
%+A        if Alist
%+A        then I_CODE;
%+A %-E         if CPUID >= iAPX186
%+A %-E         then
%+A                  outstring("PUSH   "); edval(qi);
%+A %-E         else if qi.kind=K_Qfrm2
%+A %-E              then EdLoadCnst(qi,qreg,qi qua Qfrm2.aux.val);
%+A %-E              else outstring("MOV    "); outreg(qreg);
%+A %-E                   outchar(','); edval(qi);
%+A %-E              endif;
%+A %-E              I_LINE; outstring("PUSH   ");
%+A %-E              outreg(WholeReg(qreg));
%+A %-E         endif;
%+A        endif;
%+A   when qPUSHA: ------ PUSHA   reg opr ------------------  Format 3
%+A        opr:=qi qua Qfrm3.opr;
%+A %-E    opr.sbireg:=SetSBIreg(opr.sbireg,GetDefaultSreg(opr));
%+A        --- Q-Code:
%+A        outstring("PUSHA  "); outreg(qreg);
%+A        outchar(','); outopr(opr);
%+A        if Alist
%+A        then I_CODE; outstring("LEA    "); outreg(qreg);
%+A             outchar(','); outopr(opr); I_LINE;
%+A             outstring("PUSH   "); outreg(WholeReg(qreg));
%+A        endif;
%+A   when qPUSHM: ------ PUSHM   const opr ----------------  Format 4
%+A        cnst:=qi qua Qfrm4.aux; opr:=qi qua Qfrm4.opr;
%+A        --- Q-Code:
%+A        outstring("PUSHM  "); outword(cnst.val);
%+A        outchar(','); outopr(opr);
%+A        if Alist
%+A        then I_CODE; cnst.val:=wAllign(%cnst.val%);
%+A             opr.rela.val:=opr.rela.val+cnst.val;
%+A             repeat while cnst.val>0
%+A             do cnst.val:=cnst.val-AllignFac;
%+A                opr.rela.val:=opr.rela.val-AllignFac;
%+A                outstring("PUSH   "); outopr(opr); I_LINE;
%+A             endrepeat; goto X1;
%+A        endif;
%+A   when qPOPK: ------- POPK    const --------------------  Format 2
%+A        cnst:=qi qua Qfrm2.aux;
%+A        --- Q-Code:
%+A        outstring("POPK   "); outword(cnst.val);
%+A        if Alist then I_CODE; EdAddSP(qi,wAllign(%cnst.val%)) endif;
%+A   when qPOPM: ------- POPM    reg const opr ------------  Format 4
%+A        cnst:=qi qua Qfrm4.aux; opr:=qi qua Qfrm4.opr;
%+A        --- Q-Code:
%+A        outstring("POPM   "); outreg(qreg);
%+A        outchar(','); outword(cnst.val);
%+A        outchar(','); outopr(opr);
%+A        if Alist
%+A        then I_CODE;
%+A             repeat while cnst.val>0
%+A             do outstring("POP    ");
%+A                if cnst.val >= AllignFac
%+A                then cnst.val:=cnst.val-AllignFac;
%+A                     outopr(opr); I_LINE;
%+A                else cnst.val:=0; outreg(WholeReg(qreg)); I_LINE;
%+A                     outstring("MOV    ");
%+A                     if qreg<qAX then outstring("BYTE PTR ") endif;
%+A                     outopr(opr);
%+A                     outchar(','); outreg(qreg);
%+A                endif;
%+A                opr.rela.val:=opr.rela.val+AllignFac;
%+A             endrepeat;
%+A        endif;
%+A   when qLOADC: ------ LOADC   reg const ----------------  Format 2
%+A                ------ LOADC   reg fld addr -------------  Format 2b
%+A        --- Q-Code:
%+A        outstring("LOADC  "); outreg(qreg);
%+A        outchar(','); edval(qi);
%+A        if Alist
%+A        then I_CODE;
%+A             if qi.kind=K_Qfrm2
%+A             then EdLoadCnst(qi,qreg,qi qua Qfrm2.aux.val);
%+A             else outstring("MOV    "); outreg(qreg);
%+A                  outchar(','); edval(qi);
%+A             endif;
%+A        endif;
%+A %-E when qLOADSC: ----- LOADSC  sreg reg fld addr -------  Format 2b
%+A %-E    qi qua Qfrm2b.aux.val:=F_BASE;
%+A %-E    --- Q-Code:
%+A %-E    outstring("LOADSC "); outreg(subc);
%+A %-E    outchar(','); outreg(qreg);
%+A %-E    outchar(','); edval(qi);
%+A %-E    if Alist
%+A %-E    then I_CODE;
%+A %-E         outstring("MOV    "); outreg(qreg);
%+A %-E         outchar(','); edval(qi); I_LINE;
%+A %-E         outstring("MOV    "); outreg(subc);
%+A %-E         outchar(',');   outreg(qreg);
%+A %-E         edASSUME(subc,qi qua Qfrm2b.addr.segmid);
%+A %-E    endif;
%+A   when qLOADA: ------ LOADA   reg opr ------------------  Format 3
%+A        opr:=qi qua Qfrm3.opr;
%+A %-E    opr.sbireg:=SetSBIreg(opr.sbireg,GetDefaultSreg(opr));
%+A        --- Q-Code:
%+A        outstring("LOADA  "); outreg(qreg);
%+A        outchar(','); outopr(opr);
%+A        if Alist
%+A        then I_CODE; outstring("LEA    "); outreg(qreg);
%+A             outchar(','); outopr(opr);
%+A        endif;
%+A %-E when qLDS: -------- LDS   reg ofst opr nrep ---------  Format 4c
%+A %-E    i:=qi qua Qfrm4c.nrep; cnst:=qi qua Qfrm4c.aux;
%+A %-E    --- Q-Code:
%+A %-E    outstring("LDS    "); outreg(qreg);
%+A %-E    outchar(','); outopr(qi qua Qfrm3.opr);
%+A %-E    outchar(','); outword(i);
%+A %-E    outchar(','); outword(cnst.val);
%+A %-E    if Alist
%+A %-E    then I_CODE; outstring("LDS    "); outreg(qreg);
%+A %-E         outstring(",DWORD PTR ");
%+A %-E         outopr(qi qua Qfrm3.opr);
%+A %-E         repeat while i <> 0
%+A %-E         do i:=i-1; I_LINE; outstring("LDS    "); outreg(qreg);
%+A %-E            outstring(",DS:["); outreg(qreg);
%+A %-E            outstring("]+"); outword(cnst.val);
%+A %-E         endrepeat;
%+A %-E         edASSUME(qDS,DumSEG);
%+A %-E    endif;
%+A %-E when qLES: -------- LES   reg ofst opr nrep ---------  Format 4c
%+A %-E    i:=qi qua Qfrm4c.nrep; cnst:=qi qua Qfrm4c.aux;
%+A %-E    --- Q-Code:
%+A %-E    outstring("LES    "); outreg(qreg);
%+A %-E    outchar(','); outopr(qi qua Qfrm3.opr);
%+A %-E    outchar(','); outword(i);
%+A %-E    outchar(','); outword(cnst.val);
%+A %-E    if Alist
%+A %-E    then I_CODE; outstring("LES    "); outreg(qreg);
%+A %-E         outstring(",DWORD PTR ");
%+A %-E         outopr(qi qua Qfrm3.opr);
%+A %-E         repeat while i <> 0
%+A %-E         do i:=i-1; I_LINE; outstring("LES    "); outreg(qreg);
%+A %-E            outstring(",ES:["); outreg(qreg);
%+A %-E            outstring("]+"); outword(cnst.val);
%+A %-E         endrepeat;
%+A %-E         edASSUME(qES,DumSEG);
%+A %-E    endif;
%+AE  when qBOUND: ------ BOUND   reg opr ------------------  Format 3
%+AE       opr:=qi qua Qfrm3.opr;
%+AE       --- Q-Code:
%+AE       outstring("BOUND  "); outreg(qreg);
%+AE       outchar(','); outopr(opr);
%+AE       if Alist
%+AE       then I_CODE; outstring("BOUND  "); outreg(qreg);
%+AE            outchar(','); outopr(opr);
%+AE       endif;
%+A   when qLOAD: ------- LOAD    subc reg ofst opr nrep ---  Format 4c
%+AE       i:=qi qua Qfrm4c.nrep; cnst:=qi qua Qfrm4c.aux;
%+A        opr:=qi qua Qfrm3.opr;
%+A        --- Q-Code:
%+A        outstring("LOAD   ");
%+AE       if subc=qSEXT then outstring("SEXT,");
%+AE       elsif subc=qZEXT then outstring("ZEXT,") endif;
%+A        outreg(qreg); outchar(','); outopr(opr);
%+AE       outchar(','); outword(i);
%+AE       outchar(','); outint(cnst.val);
%+A        if Alist
%+A        then I_CODE;
%+AE            if subc=qSEXT
%+AE            then outstring("MOVSX  "); outreg(WholeReg(qreg));
%+AE            elsif subc=qZEXT
%+AE            then outstring("MOVZX  "); outreg(WholeReg(qreg));
%+AE            else
%+A                   outstring("MOV    "); outreg(qreg);
%+AE            endif;
%+A             outchar(','); outopr(opr);
%+AE            repeat while i <> 0
%+AE            do i:=i-1; I_LINE; outstring("MOV    "); outreg(qreg);
%+AE               outstring(",["); outreg(qreg);
%+AE               outstring("]+"); outint(cnst.val);
%+AE            endrepeat;
%+A %-E         if    qreg = qDS then edASSUME(qDS,DumSEG)
%+A %-E         elsif qreg = qES then edASSUME(qES,DumSEG) endif;
%+A        endif;
%+A   when qSTORE: ------ STORE   reg opr ------------------  Format 3
%+A        opr:=qi qua Qfrm3.opr;
%+A        --- Q-Code:
%+A        outstring("STORE  "); outreg(qreg);
%+A        outchar(','); outopr(opr);
%+A        if Alist
%+A        then I_CODE; outstring("MOV    "); outopr(opr);
%+A             outchar(',');   outreg(qreg);
%+A        endif;
%+A   when qMOV: -------- MOV     subc reg reg2 ------------  Format 2
%+A        --- Q-Code:
%+A        outstring("MOV    ");
%+AE       if subc=qSEXT then outstring("SEXT,");
%+AE       elsif subc=qZEXT then outstring("ZEXT,") endif;
%+A        outreg(qreg); outchar(',');
%+A        outreg(qi qua Qfrm2.aux.val);
%+A        if Alist
%+A        then I_CODE; qreg2:=qi qua Qfrm2.aux.val;
%+A             if RegSize(qreg) <> RegSize(qreg2)
%+A             then IERR("COASM.qMOV byte/word register");
%+A                  setpos(sysout,I_OPERATOR);
%+A                  qreg:=WholeReg(qreg); qreg2:=WholeReg(qreg2);
%+A             endif;
%+AE            if subc=qSEXT
%+AE            then outstring("MOVSX  "); outreg(WholeReg(qreg));
%+AE            elsif subc=qZEXT
%+AE            then outstring("MOVZX  "); outreg(WholeReg(qreg));
%+AE            else outstring("MOV    "); outreg(qreg) endif;
%+AE            outchar(',');  outreg(qreg2);
%+A %-E         if (qreg >= qES) and (qreg2 >= qES)
%+A %-E         then  outstring("PUSH   "); outreg(qreg2); I_LINE;
%+A %-E               outstring("POP    "); outreg(qreg);
%+A %-E         else  outstring("MOV    "); outreg(qreg);
%+A %-E               outchar(',');  outreg(qreg2);
%+A %-E         endif;
%+A %-E         if    qreg = qDS then edASSUME(qDS,DumSEG)
%+A %-E         elsif qreg = qES then edASSUME(qES,DumSEG) endif;
%+A        endif;
%+A   when qMOVMC: ------ MOVMC   width const opr ----------  Format 4
%+A                ------ MOVMC   width fld opr addr -------  Format 4b
%+A        --- Q-Code:
%+A        outstring("MOVMC  "); outwidth(qreg);
%+A        outchar(' '); outopr(qi qua Qfrm4.opr);
%+A        outchar(','); edval(qi);
%+A        if Alist
%+A        then I_CODE; outstring("MOV    "); outwidth(qreg);
%+A             outopr(qi qua Qfrm4.opr); outchar(',');
%+A             edval(qi);
%+A        endif;
%+A   when qXCHG: ------- XCHG    reg reg2 -----------------  Format 2
%+A        qreg2:=qi qua Qfrm2.aux.val;
%+A        --- Q-Code:
%+A        outstring("XCHG   "); outreg(qreg);
%+A        outchar(','); outreg(qreg2);
%+A        if Alist
%+A        then I_CODE;
%+A             if RegSize(qreg) <> RegSize(qreg2)
%+A             then IERR("COASM.qXCHG byte/word register");
%+A                  setpos(sysout,I_OPERATOR);
%+A                  qreg:=WholeReg(qreg); qreg2:=WholeReg(qreg2);
%+A             endif;
%+A             outstring("XCHG   "); outreg(qreg);
%+A             outchar(','); outreg(qreg2);
%+A        endif;
%+A   when qXCHGM: ------ XCHGM   reg opr ------------------  Format 3
%+A        --- Q-Code:
%+A        outstring("XCHGM  "); outreg(qreg);
%+A        outchar(','); outopr(qi qua Qfrm3.opr);
%+A        if Alist
%+A        then I_CODE; outstring("XCHG   "); outreg(qreg);
%+A             outchar(','); outopr(qi qua Qfrm3.opr);
%+A        endif;
%+A   when qMONADR: ----- MONADR  subc reg -----------------  Format 2
%+A        --- Q-Code:
%+A        edmonad(subc); outreg(qreg);
%+A        if Alist
%+A        then I_CODE;
%+A             if subc>8 then subc:=subc-7; OvflTail:=TSTOFL endif;
%+A             if subc=qNEGM then subc:=qNEG endif;
%+AE            if RegSize(qreg) > 1 then qreg:=WholeReg(qreg) endif;
%+A             edmonad(subc); outreg(qreg);
%+A             if subc>=qSHL1 then outstring(",1") endif;
%+A        endif;
%+A   when qMONADM: ----- MONADM  subc width opr -----------  Format 3
%+A        --- Q-Code:
%+A        edmonad(subc); outwidth(qreg);
%+A        outchar(' '); outopr(qi qua Qfrm3.opr);
%+A        if Alist
%+A        then I_CODE;
%+A             if subc>8 then subc:=subc-7; OvflTail:=TSTOFL endif;
%+A             if subc=qNEGM then subc:=qNEG endif;
%+A             edmonad(subc); outwidth(qreg);
%+A             outopr(qi qua Qfrm3.opr);
%+A             if subc>=qSHL1 then outstring(",1") endif;
%+A        endif;
%+A   when qDYADR: ------ DYADR   subc reg reg2 ------------  Format 2
%+A        qreg2:=qi qua Qfrm2.aux.val;
%+A        --- Q-Code:
%+A        eddyad(subc); outreg(qreg);
%+A        outchar(','); outreg(qreg2);
%+A        if Alist
%+A        then I_CODE; subc:=a_dyad(subc);
%+A             if qi.subc>=qADDF then OvflTail:=TSTOFL endif;
%+A             if RegSize(qreg) <> RegSize(qreg2)
%+A             then IERR("COASM.qDYADR byte/word register");
%+A                  setpos(sysout,I_OPERATOR);
%+A                  qreg:=WholeReg(qreg); qreg2:=WholeReg(qreg2);
%+A             endif;
%+A             eddyad(subc); outreg(qreg);
%+A             outchar(','); outreg(qreg2);
%+A %-E         if (qi.subc=qINCO) or (qi.subc=qDECO)
%+A %-E         then edinco(qi.subc,qreg) endif;
%+A        endif;
%+A   when qSHIFT: ------ SHIFT   subc reg CL --------------  Format 2
%+A        --- Q-Code:
%+A        outstring("SHIFT  ");
%+A        outword(subc); outchar(',');
%+A        outreg(qreg); outstring(",CL");
%+A        if Alist
%+A        then I_CODE; if subc=qSHL then outstring("SHL    ");
%+A             elsif subc=qSHR then outstring("SHR    ");
%+A             else outstring("SAR    ") endif;
%+A             outreg(qreg); outstring(",CL");
%+A        endif;
%+A   when qDYADC: ------ DYADC   subc reg const -----------  Format 2
%+A                ------ DYADC   subc reg fld addr --------  Format 2b
%+A        --- Q-Code:
%+A        eddyad(subc); outreg(qreg);
%+A        outchar(','); edval(qi);
%+A        if Alist
%+A        then I_CODE; subc:=a_dyad(subc);
%+A             if qi.subc>=qADDF then OvflTail:=TSTOFL endif;
%+A %-E         if    (qreg=qSP) and (subc=qADD) and (qi.kind=K_Qfrm2)
%+AE            if    (qreg=qESP) and (subc=qADD) and (qi.kind=K_Qfrm2)
%+A                             then EdAddSP(qi,qi qua Qfrm2.aux.val)
%+A %-E         elsif (qreg=qSP) and (subc=qSUB) and (qi.kind=K_Qfrm2)
%+AE            elsif (qreg=qESP) and (subc=qSUB) and (qi.kind=K_Qfrm2)
%+A                             then EdSubSP(qi qua Qfrm2.aux.val)
%+A             else eddyad(subc); outreg(qreg);
%+A                  outchar(','); edval(qi);
%+A             endif;
%+A %-E         if (qi.subc=qINCO) or (qi.subc=qDECO)
%+A %-E         then edinco(qi.subc,qreg) endif;
%+A        endif;
%+A   when qDYADM: ------ DYADM   subc reg opr -------------  Format 3
%+A        --- Q-Code:
%+A        eddyad(subc); outreg(qreg);
%+A        outchar(','); outopr(qi qua Qfrm3.opr);
%+A        if Alist
%+A        then I_CODE; subc:=a_dyad(subc);
%+A             if qi.subc>=qADDF then OvflTail:=TSTOFL endif;
%+A             eddyad(subc); outreg(qreg);
%+A             outchar(','); outopr(qi qua Qfrm3.opr);
%+A %-E         if (qi.subc=qINCO) or (qi.subc=qDECO)
%+A %-E         then edinco(qi.subc,qreg) endif;
%+A        endif;
%+A   when qDYADMC: ----- DYADMC  subc width const opr -----  Format 4
%+A                 ----- DYADMC  subc width fld opr addr --  Format 4b
%+A        --- Q-Code:
%+A        eddyad(subc); outwidth(qreg);
%+A        outopr(qi qua Qfrm4.opr);
%+A        outchar(','); edval(qi);
%+A        if Alist
%+A        then I_CODE; subc:=a_dyad(subc);
%+A             if qi.subc>=qADDF then OvflTail:=TSTOFL endif;
%+A             eddyad(subc); outwidth(qreg);
%+A             outopr(qi qua Qfrm4.opr); outchar(',');
%+A             edval(qi);
%+A %-E         if (qi.subc=qINCO) or (qi.subc=qDECO)
%+A %-E         then
%+A %-E              ---- ??????????????????????????
%+A %-E         endif;
%+A        endif;
%+A   when qDYADMR: ----- DYADMR  subc reg opr -------------  Format 3
%+A        --- Q-Code:
%+A        eddyad(subc); outreg(qreg);
%+A        outchar(','); outopr(qi qua Qfrm3.opr);
%+A        if Alist
%+A        then I_CODE; subc:=a_dyad(subc);
%+A             if qi.subc>=qADDF then OvflTail:=TSTOFL endif;
%+A             eddyad(subc); outopr(qi qua Qfrm3.opr)
%+A             outchar(','); outreg(qreg);
%+A %-E         if (qi.subc=qINCO) or (qi.subc=qDECO)
%+A %-E         then edinco(qi.subc,qreg) endif;
%+A        endif;
%+A   when qTRIADR: ----- TRIADR  subc reg -----------------  Format 2
%+A        --- Q-Code:
%+A        outtriadr(subc); outreg(qreg);
%+A        if Alist
%+A        then I_CODE; subc:=bAND(subc,11);
%+A             if subc <> qi.subc then OvflTail:=TSTOFL endif;
%+A             outtriadr(subc); outreg(qreg);
%+A        endif;
%+A   when qTRIADM: ----- TRIADM  subc width opr -----------  Format 3
%+A        --- Q-Code:
%+A        outtriadr(subc); outwidth(qreg);
%+A        outchar(' '); outopr(qi qua Qfrm3.opr);
%+A        if Alist
%+A        then I_CODE; subc:=bAND(subc,11);
%+A             if subc <> qi.subc then OvflTail:=TSTOFL endif;
%+A             outtriadr(subc); outwidth(qreg);
%+A             outopr(qi qua Qfrm3.opr);
%+A        endif;
%+A   when qCWD: -------- CWD  width -----------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("CWD    ");
%+AE       outreg(subc);
%+A        if Alist
%+A        then I_CODE;
%+A %-E         outstring("CWD");
%+AE            if subc<qAX then outstring("CBW");
%+AE            elsif subc<qEAX then outstring("CWD");
%+AE            else outstring("CDQ") endif;
%+A        endif;
%+A   when qCONDEC: ----- CONDEC  subc reg -----------------  Format 2
%+A        --- Q-Code:
%+A        outstring("CONDEC ");
%+A        edqcond(subc); outreg(qreg);
%+A        if Alist
%+A        then I_CODE;
%+A %-E         EdCondJMP(NotQcond(subc));
%+A %-E         outstring("    SHORT $+3"); I_LINE;
%+A %-E         outstring("DEC    "); outreg(WholeReg(qreg));
%+AE            EdCondSETB(subc); outreg(qreg);
%+A        endif;
%+A   when qRSTRB: ------ RSTRB   subc dir rep -------------  Format 2
%+A        ListRSTR(subc,qi.reg,qi qua Qfrm2.aux.val,'B');
%+A   when qRSTRW: ------ RSTRW   subc dir rep -------------  Format 2
%+A        ListRSTR(subc,qi.reg,qi qua Qfrm2.aux.val,'W');
%+A   when qLAHF: ------- LAHF -----------------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("LAHF   ");
%+A        if Alist then I_CODE; outstring("LAHF") endif;
%+A   when qSAHF: ------- SAHF -----------------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("SAHF   ");
%+A        if Alist then I_CODE; outstring("SAHF") endif;
%+A   when qFDEST: ------ FDEST   fixno jmp ----------------  Format 6
%+A        --- Q-Code:
%+A        outstring("FDEST ?FIX") outword(qi qua Qfrm6.aux);
%+A        if Alist
%+A        then I_CODE; putpos(sysout,I_LABEL); outstring("?FIX");
%+A             outword(qi qua Qfrm6.aux); outchar(':')
%+A        endif;
%+A   when qBDEST: ------ BDEST   labno rela jmp ------------  Format 6
%+A        --- Q-Code:
%+A        outstring("BDEST ");
%+A        outword(qi qua Qfrm6.aux); outchar(',');
%+A        outword(qi qua Qfrm6.rela.val);
%+A        if Alist
%+A        then I_CODE; putpos(sysout,I_LABEL); outstring("?LAB");
%+A             outword(qi qua Qfrm6.aux); outchar(':')
%+A        endif;
%+A   when qLABEL: ------ LABEL   subc fixno smbx ----------  Format 6
%+A        --- Q-Code:
%+A        outstring("LABEL ");
%+A        case 0:3 (subc)
%+A        when qBPROC: outstring("BPROC,")
%+A        when qEPROC: outstring("EPROC,")
%+A        endcase;
%+A        outword(qi qua Qfrm6.aux);
%+A        if Alist
%+A        then I_CODE; putpos(sysout,I_LABEL);
%+A             fix.val:=qi qua Qfrm6.aux;
%+A             ix.val:=qi qua Qfrm6.smbx;
%+A             case 0:3 (subc)
%+A             when qBPROC: if ix.val > 0
%+A                  then repeat while qi.reg<>0 -- counts alignment bytes
%+A                       do setpos(sysout,I_OPERATOR); outstring("NOP");
%+A                          I_LINE; putpos(sysout,I_LABEL); qi.reg:=qi.reg-1
%+A                       endrepeat;
%+A                       outsymb(ix); setpos(sysout,I_OPERATOR);
%+A                       outstring("PROC  FAR");
%+A                       I_LINE; setpos(sysout,I_OPERATOR);
%+A                       outstring("PUBLIC   "); outsymb(ix);
%+A                  else outstring("?FIX");
%+A                       outword(fix.val);
%+A                       setpos(sysout,I_OPERATOR);
%+A                       outstring("PROC  FAR");
%+A                  endif;
%+A             when qEPROC: if ix.val > 0
%+A                  then outsymb(ix); setpos(sysout,I_OPERATOR);
%+A                       outstring("ENDP");
%+A                  else outstring("?FIX");
%+A                       outword(fix.val);
%+A                       setpos(sysout,I_OPERATOR); outstring("ENDP");
%+A                  endif;
%+A             otherwise if ix.val > 0
%+A                  then outsymb(ix); setpos(sysout,I_OPERATOR);
%+A                       outstring("LABEL  FAR"); I_LINE;
%+A                       setpos(sysout,I_OPERATOR);
%+A                       outstring("PUBLIC   "); outsymb(ix);
%+A                  else outstring("?FIX");
%+A                       outword(fix.val);
%+A                       setpos(sysout,I_OPERATOR);
%+A                       outstring("LABEL  NEAR");
%+A                  endif;
%+A             endcase;
%+A        endif;
%+A   when qJMP: -------- JMP     subc addr dst ------------  Format 5
%+A        --- Q-Code:
%+A        outstring("JMP    "); edqcond(subc);
%+A        outadr(qi qua Qfrm5.addr); dst:=qi qua Qfrm5.dst;
%+A        if dst=none then outstring(",none")
%+A        elsif dst.fnc=qBDEST
%+A        then outstring(",BDST"); outword(dst.aux);
%+A        elsif dst.fnc=qFDEST
%+A        then outstring(",FIX") outword(dst.aux) endif;
%+A        if Alist
%+A        then I_CODE; -- aux field set by coasm
%+A             case 0:5 (qi qua Qfrm5.aux)
%+A             when 0: -- short conditional
%+A                  edCondJMP(subc);
%+A             when 1: -- short unconditional
%+A                  outstring("JMP    SHORT ");
%+A             when 2: -- near conditional
%+A %+E              edCondJMP(subc); outstring("NEAR PTR ");
%+A %-E              edCondJMP(NotQcond(subc)); outstring("$+5"); I_LINE;
%+A %-E              outstring("JMP    NEAR PTR ");
%+A             when 3: -- near unconditional
%+A                  outstring("JMP    NEAR PTR ");
%+A             when 4: -- far conditional
%+A %-E              edCondJMP(NotQcond(subc)); outstring("$+7"); I_LINE;
%+A %-E              outstring("JMP    FAR PTR ");
%+A             when 5: -- far unconditional
%+A %-E              outstring("JMP    FAR PTR ");
%+A             endcase
%+A             if dst=none then outadr(qi qua Qfrm5.addr)
%+A             elsif dst.fnc=qBDEST
%+A             then outstring("?LAB"); outword(dst.aux);
%+A             elsif dst.fnc=qFDEST
%+A             then outstring("?FIX"); outword(dst.aux);
%+A             else outadr(qi qua Qfrm5.addr) endif;
%+A        endif;
%+A   when qJMPM: ------- JMPM    opr ----------------------  Format 3
%+A        --- Q-Code:
%+A        outstring("JMPM   "); outopr(qi qua Qfrm3.opr);
%+A        if Alist
%+A        then I_CODE; outstring("JMP    WORD PTR ");
%+A             outopr(qi qua Qfrm3.opr);
%+A        endif;
%+A %-E when qJMPFM: ------ JMPFM   opr --------------------  Format 3
%+A %-E    --- Q-Code:
%+A %-E    outstring("JMPFM  "); outopr(qi qua Qfrm3.opr);
%+A %-E    if Alist
%+A %-E    then I_CODE; outstring("JMP    DWORD PTR ");
%+A %-E         outopr(qi qua Qfrm3.opr);
%+A %-E    endif;
%+A   when qCALL: ------- CALL    subc pxlng addr ----------  Format 5
%+A        --- Q-Code:
%+A        outstring("CALL   "); outword(qi qua Qfrm5.subc);
%+A        outchar(','); outword(qi qua Qfrm5.reg);
%+A        outchar(','); outword(qi qua Qfrm5.aux);
%+A        outchar(',');
%+AE       if qi qua Qfrm5.addr.kind=reladr -- Special Case: CALL [reg]
%+AE       then outopr(qi qua Qfrm5.addr);
%+AE       else
%+A             outadr(qi qua Qfrm5.addr);
%+AE       endif;
%+A        if Alist
%+A        then I_CODE;
%+A %-E         if (subc=qXNX) or (subc=qC)
%+A %-E         then outstring("PUSH   SS"); I_LINE;
%+A %-E              outstring("POP    DS"); I_LINE;
%+A %-E         endif;
%+A             if subc=qC
%+A             then EdCall(qi qua Qfrm5.addr);
%+A                  cnst.val:=qi qua Qfrm5.aux;
%+A                  if cnst.val > 0
%+A                  then I_LINE;
%+A %-E                   outstring("ADD    SP,");
%+AE                      outstring("ADD    ESP,");
%+A                       outword(cnst.val);
%+A                  endif;
%+A             elsif subc=qXNX
%+A             then EdCall(qi qua Qfrm5.addr);
%+A                  cnst.val:=qi qua Qfrm5.aux;
%+A                  if cnst.val > 0
%+A                  then I_LINE;
%+A %-E                   outstring("ADD    SP,");
%+AE                      outstring("ADD    ESP,");
%+A                       outword(cnst.val);
%+A                  endif;
%+A                  I_LINE; outstring("INC    AX");
%+A %-E              I_LINE; outstring("JNZ    $+");
%+A %-E              outword(if EnvCSEG=CSEGID then 5 else 7);
%+AE                 I_LINE; outstring("JNZ    $+7");
%+A                  I_LINE; EdCall(X_SSTAT);
%+A                  I_LINE; outstring("DEC    AX");
%+A             elsif subc=qKNL
%+A             then 
%+A %-E              outstring("MOV    AX,");
%+AE                 outstring("MOV    EAX,");
%+A                  outword(qi qua Qfrm5.addr.knlx.val); I_LINE;
%+A %-E              I_LINE; outstring("CALLF  144:0");
%+AE                 I_LINE; outstring("CALLF  7:0");
%+A                  I_LINE; outstring("JNC    $+??"); I_LINE;
%+A %-E              outstring("MOV    SS:OFFSET DGROUP:G@OSSTAT,AX");
%+AE                 outstring("MOV    G@OSSTAT,EAX");
%+A                  I_LINE;
%+A %-E              outstring("MOV    SS:OFFSET DGROUP:G@KNLAUX,AX");
%+AE                 outstring("MOV    G@KNLAUX,EAX");
%+A                  cnst.val:=qi qua Qfrm5.aux;
%+A                  if cnst.val > 0
%+A                  then I_LINE;
%+A %-E                   outstring("ADD    SP,");
%+AE                      outstring("ADD    ESP,");
%+A                       outword(cnst.val);
%+A                  endif;
%+A %-E         elsif subc=qOS2
%+A %-E         then EdCall(qi qua Qfrm5.addr); I_LINE;
%+A %-E              outstring("MOV    SS:OFFSET DGROUP:G@OSSTAT,AX");
%+A             else EdCall(qi qua Qfrm5.addr) endif;
%+A        endif;
%+A   when qADJST: ------ ADJST   const --------------------  Format 2
%+A        --- Q-Code:
%+A        outstring("ADJST  "); outword(qi qua Qfrm2.aux.val);
%+A        if Alist then I_CODE endif;
%+A   when qENTER: ------ ENTER   const --------------------  Format 2
%+A        --- Q-Code:
%+A        cnst:=qi qua Qfrm2.aux;
%+A        outstring("ENTER  "); outword(cnst.val);
%+A        if Alist
%+A        then I_CODE;
%+A %-E         if qi.subc=0
%+A %-E         then outstring("POP    AX"); I_LINE;
%+A %-E              outstring("PUSH   CS"); I_LINE;
%+A %-E              outstring("PUSH   AX"); I_LINE endif;
%+A %-E         if CPUID >= iAPX186
%+A %-E         then
%+A                  outstring("ENTER  "); outword(cnst.val);
%+A %-E         else outstring("PUSH   BP"); I_LINE;
%+A %-E              outstring("MOV    BP,SP");
%+A %-E              if cnst.val>0
%+A %-E              then I_LINE; outstring("SUB    SP,");
%+A %-E                   outword(cnst.val);
%+A %-E              endif;
%+A %-E         endif;
%+A        endif;
%+ACS %-E  if CHKSTK
%+ACS %-E  then I_LINE; outstring("CMP    SP,OFFSET G@STKBEG");
%+ACS %-E       I_LINE; outstring("JA     $+");
%+ACS %-E       if EnvCSEG=CSEGID then outword(5)
%+ACS %-E       else outword(7) endif;
%+ACS %-E       I_LINE; EdCall(X_STKOFL);
%+ACS %-E  endif;
%+A   when qLEAVE: ------ LEAVE   const --------------------  Format 2
%+A        --- Q-Code:
%+A        cnst:=qi qua Qfrm2.aux;
%+A        outstring("LEAVE  "); outword(cnst.val);
%+A        if Alist
%+A        then I_CODE;
%+A %-E         if CPUID >= iAPX186
%+A %-E         then
%+A                  outstring("LEAVE");
%+A %-E         else if cnst.val>0
%+A %-E              then outstring("MOV    SP,BP"); I_LINE endif;
%+A %-E              outstring("POP    BP");
%+A %-E         endif;
%+A        endif;
%+A   when qRET: -------- RET     const --------------------  Format 2
%+A        --- Q-Code:
%+A        outstring("RET    "); outword(qi qua Qfrm2.aux.val);
%+A        if Alist
%+A        then I_CODE;
%+A %-E         outstring("RETF   ");
%+AE            outstring("RET    ");
%+A             outword(qi qua Qfrm2.aux.val);
%+A        endif;
%+A %-E when qDOS2: ------- DOS2 ---------------------------  Format 1
%+A %-E    --- Q-Code:
%+A %-E    outstring("DOS2");
%+A %-E    if Alist
%+A %-E    then I_CODE;
%+A %-E         outstring("INT    33"); I_LINE;
%+A %-E         outstring("JNC    $+6"); I_LINE;
%+A %-E         outstring("MOV    SS:OFFSET DGROUP:G@OSSTAT,AL");
%+A %-E    endif;
%+A   when qINT: -------- INT     const --------------------  Format 2
%+A        --- Q-Code:
%+A        outstring("INT    "); outword(qi qua Qfrm2.aux.val);
%+A        if Alist
%+A        then I_CODE;
%+A             outstring("INT    ");outword(qi qua Qfrm2.aux.val);
%+A        endif;
%+A   when qIRET: ------- IRET -----------------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("IRET");
%+A        if Alist then I_CODE; outstring("IRET") endif;
%+A   when qFLD: -------- FLD     fSD fmf opr --------------  Format 3
%+A        EdFLD(qi);
%+A   when qFLDC: ------- FLDC    sreg fmf val -------------  Format 3+
%+AE              ------- FLDC    fSD  fmf val -------------  Format 3+
%+A        EdFLDC(qi);
%+A   when qFDUP: ------- FDUP    fSD ----------------------  Format 1
%+A        EdFDUP(qi);
%+A   when qFST: -------- FST     fSD fmf opr --------------  Format 3
%+A        EdFST(qi);
%+A   when qFSTP: ------- FSTP    fSD fmf opr --------------  Format 3
%+A        EdFSTP(qi);
%+A   when qFPUSH: ------ FPUSH   fSD fmf ------------------  Format 1
%+A        EdFPUSH(qi);
%+A   when qFPOP: ------- FPOP    fSD fmf ------------------  Format 1
%+A        EdFPOP(qi);
%+A   when qFLDCK: ------ FLDCK   subc ---------------------  Format 1
%+A        EdFLDCK(qi);
%+A   when qFMONAD: ----- FMONAD  subc fSD -----------------  Format 1
%+A        EdFMONAD(qi);
%+A   when qFDYAD: ------ FDYAD   subc fSD -----------------  Format 1
%+A        EdFDYAD(qi);
%+A   when qFDYADM: ----- FDYADM  subc fmf fSD opr ---------  Format 4
%+A        EdFDYADM(qi);
%+A   when qWAIT: ------- WAIT -----------------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("WAIT");
%+A        if Alist then I_CODE; outstring("WAIT") endif;
%+A   when qEVAL: ------- EVAL -----------------------------  Format 1
%+A        --- Q-Code:
%+A        outstring("EVAL");
%+A        if Alist then I_CODE endif;
%+A   when qLINE: ------- LINE    subc const ---------------  Format 2
%+A        putpos(sysout,I_LABEL);
%+A        case 0:2 (subc)
%+A        when 0:    outstring(";     SOURCE LINE ");
%+A        when qDCL: outstring(";     DECLARATION LINE ");
%+A        when qSTM: outstring(";     STATEMENT LINE ");
%+A        endcase;
%+A        outint(qi qua Qfrm2.aux.val);
%+A        if DEBMOD > 2 then if subc=qSTM
%+A        then I_LINE; outstring("POPF");
%+A             I_LINE; outstring("PUSHF"); endif endif;
%+A   endcase;

%+A   if OvflTail then I_LINE; outstring("INTO") endif;
%+A   I_LINE; X1: putpos(sysout,0);
%+A end;

%+A Routine EdLoadCnst;
%+A import ref(Qpkt) qi; range(0:255) qreg; integer cnst;
%+A begin range(0:1) w;
%+A       w:=if bAND(qreg,qw_W)=qw_W then 1 else 0;  --- ???????????????
%+A       if (w=1) and (cnst=0) and RegDies(qi,uF)
%+A       then outstring("XOR    "); outreg(qreg);
%+A            outchar(','); outreg(qreg);
%+A       else outstring("MOV    "); outreg(qreg);
%+A            outchar(','); outword(cnst);
%+A       endif;
%+A end;

%+A Routine edval; import ref(Qpkt) qi;
%+A begin if    qi.kind=K_Qfrm2 then outword(qi qua Qfrm2.aux.val)
%+A       elsif qi.kind=K_Qfrm4  then outword(qi qua Qfrm4.aux.val)
%+A       elsif qi.kind=K_Qfrm2b
%+A            then edrelval(qi qua Qfrm2b.aux.val,qi qua Qfrm2b.addr)
%+A       elsif qi.kind=K_Qfrm4b
%+A             then edrelval(qi qua Qfrm4b.aux.val,qi qua Qfrm4b.addr)
%+A       else outstring("**ILL-VAL-2 ") endif;
%+A end;

%+A Routine edrelval;
%+A import range(0:4) fld; infix(MemAddr) addr;
%+A begin infix(WORD) segid;
%+A %-E   case 0:4 (fld)
%+A %-E   when F_BASE:   outstring("SEG "); segid.val:=AdrSegid(addr)
%+A %-E        if segid.val=0 then outadr(addr)
%+A %-E        else outsymb(segid) endif;
%+A %-E   when F_OFFSET: outstring("OFFSET "); outadr(addr);
%+A %-E   otherwise outstring("**ILL-VAL-1 "); outadr(addr)  endcase;
%+AE      outstring("OFFSET "); outadr(addr);
%+A end;

%+A Routine EdCall; import infix(MemAddr) addr;
%+A begin
%+A %-E   if AdrSegid(addr)=CSEGID.val then outstring("CALL   NEAR PTR ")
%+A %-E   else if AdrSegid(addr)<>0
%+A %-E        then addr.rela.val:=addr.rela.val+3 endif;
%+A %-E        outstring("CALL   FAR PTR ");
%+A %-E   endif;
%+AE      outstring("CALL   ");
%+AE      if addr.kind=reladr -- Special Case: CALL [reg]
%+AE      then outopr(addr);
%+AE      else
%+A            outadr(addr);
%+AE      endif;
%+A end;

%+A Routine EdAddSP;
%+A import ref(Qpkt) qi; range(0:MaxWord) cnst;
%+A begin range(0:nregs) rx;
%+A   if cnst <= (2*AllignFac)
%+A   then rx:=RegAvailable(qi)
%+A        if rx > 0
%+A        then repeat while cnst >= AllignFac
%+A             do outstring("POP    "); outreg(rx);
%+A                I_LINE; cnst:=cnst-AllignFac;
%+A             endrepeat;
%+A        elsif cnst > 3 then goto L1 endif;
%+A        repeat while cnst>0
%+A %-E    do cnst:=cnst-1; outstring("INC    SP"); I_LINE endrepeat;
%+AE       do cnst:=cnst-1; outstring("INC    ESP"); I_LINE endrepeat;
%+A   else L1:
%+A %-E    outstring("ADD    SP,");
%+AE       outstring("ADD    ESP,");
%+A        outword(cnst);
%+A   endif;
%+A end;

%+A Routine EdSubSP;
%+A import range(0:MaxWord) cnst;
%+A begin
%+A   if cnst <= (2*AllignFac)
%+A   then repeat while cnst >= AllignFac
%+A %-E    do outstring("PUSH   AX");
%+AE       do outstring("PUSH   EAX");
%+A           I_LINE; cnst:=cnst-AllignFac;
%+A        endrepeat;
%+A   else
%+A %-E    outstring("SUB    SP,");
%+AE       outstring("SUB    ESP,");
%+A        outword(cnst);
%+A   endif;
%+A end;

%+A Routine EdCondJMP; import range(0:15) qcond;
%+A begin case 0:15 (qcond)
%+A   when 0:     outstring("JMP")
%+A   when q_IEQ,q_WEQ:  outstring("JE ")
%+A   when q_INE,q_WNE:  outstring("JNE")
%+A   when q_ILE:  outstring("JLE")     when q_WLT:  outstring("JB ")
%+A   when q_WLE:  outstring("JBE")     when q_ILT:  outstring("JL ")
%+A   when q_IGE:  outstring("JGE")     when q_IGT:  outstring("JG ")
%+A   when q_WGE:  outstring("JAE")     when q_WGT:  outstring("JA ")
%+A   endcase;
%+A   setpos(sysout,I_OPERAND);
%+A end;
%+A
%+AE Routine EdCondSETB; import range(0:15) qcond;
%+AE begin case 0:15 (qcond)
%+AE   when q_IEQ,q_WEQ:  outstring("SETE   ")
%+AE   when q_INE,q_WNE:  outstring("SETNE  ")
%+AE   when q_ILE:  outstring("SETLE  ")     when q_WLT:  outstring("SETB   ")
%+AE   when q_WLE:  outstring("SETBE  ")     when q_ILT:  outstring("SETL   ")
%+AE   when q_IGE:  outstring("SETGE  ")     when q_IGT:  outstring("SETG   ")
%+AE   when q_WGE:  outstring("SETAE  ")     when q_WGT:  outstring("SETA   ")
%+AE   endcase;
%+AE end;

%+A Routine ListRSTR;
%+A import range(0:20) subc; range(0:4) dir,rep; character cc;
%+A begin boolean STDf; STDf:=false;
%+A       --- Q-Code:
%+A       case 0:6 (subc)
%+A       when qRMOV:  outstring("RMOV   ")
%+A       when qRCMP:  outstring("RCMP   ")
%+A       when qZERO:  outstring("ZERO   ")
%+A       when qRCMPS: outstring("RCMPS  ")
%+A       when qRSCAS: outstring("RSCAS  ")
%+A       when qRSTOS: outstring("RSTOS  ")
%+A       endcase;
%+A       if dir=qCLD then outstring(",CLD,")
%+A       else outstring(",STD,") endif;
%+A       case 0:2 (rep)
%+A       when qREP:     outstring("REP")
%+A       when qREPEQ:   outstring("REPE")
%+A       when qREPNE:   outstring("REPNE")
%+A       endcase;
%+A       if ListI
%+A       then I_CODE;
%+A            if dir <> qCLD then outstring("STD"); I_LINE; STDf:=true;
--- pje        else outstring("CLD"); I_LINE;
%+A            endif;
%+A            if subc=qZERO
%+A %-E        then outstring("SUB    CX,DI");   I_LINE;
%+AE           then outstring("SUB    ECX,EDI"); I_LINE;
%+A                 outstring("JNB    $+5");     I_LINE;
%+A                 outstring("STD");            I_LINE; STDf:=true;
%+A %-E             outstring("NEG    CX");      I_LINE;
%+AE                outstring("NEG    ECX");     I_LINE;
%+A                 if cc <> 'B'
%+A                 then
%+A %-E                  outstring("SHR    CX,1"); I_LINE;
%+AE                     outstring("SHR    ECX,1"); I_LINE;
%+AE                     outstring("SHR    ECX,1"); I_LINE;
%+A                 endif;
%+A            endif;
%+A            case 0:2 (rep)
%+A            when qREP:     outstring("REP    ")
%+A            when qREPEQ:   outstring("REPE   ")
%+A            when qREPNE:   outstring("REPNE  ")
%+A            endcase;
%+A            case 0:6 (subc)
%+A            when qRMOV:  outstring("MOVS"); outchar(cc)
%+A            when qRCMP:  outstring("CMPS"); outchar(cc)
%+A            when qZERO:  outstring("STOS"); outchar(cc)
%+A            when qRCMPS: outstring("CMPS"); outchar(cc)
%+A                         I_LINE; outstring("MOV    AL,0");
%+A                         I_LINE; outstring("JNE    $+3");
%+A                         I_LINE; outstring("DEC    AX");
%+A            when qRSCAS: outstring("SCAS"); outchar(cc);I_LINE;
%+A                         if rep = qREPNE
%+A                         then outstring("JNE    $+3");
%+A                         else outstring("JE     $+3") endif;
%+A %-E                     I_LINE; outstring("INC    CX");
%+AE                        I_LINE; outstring("INC    ECX");
%+A            when qRSTOS: outstring("STOS"); outchar(cc);
%+A            endcase;
%+A       endif;
%+A %-W   if STDf then I_LINE; outstring("CLD"); endif; --- pje
%+A end;

%+A Routine outwidth; import range(0:nregs) qreg;
%+A begin range(0:8) w; w:=RegSize(qreg);
%+A       if w=1 then outstring("BYTE PTR ")
%+AE      elsif w=4 then outstring("DWORD PTR ")
%+A       else outstring("WORD PTR ") endif;
%+A end

%+A Routine edfmf; import range(0:6) fmf;
%+A begin case 0:6 (fmf)
%+A   when FMF_LREAL: outstring("lreal")
%+A   when FMF_REAL:  outstring("real")
%+A   when FMF_INT:   outstring("int")
%+A   when FMF_SINT:  outstring("sint")
%+A   when FMF_TEMP:  outstring("treal")
%+A   otherwise outword(fmf); outstring("-bytes") endcase;
%+A end;


%+A Routine edmonad; import range(0:4) subc;
%+A begin case 0:14 (subc)
%+A   when qNOT:  outstring("NOT    ")   when qNEGM:  outstring("NEGM   ")
%+A   when qNEG:  outstring("NEG    ")   when qINC:   outstring("INC    ")
%+A   when qDEC:  outstring("DEC    ")   when qNEGF:  outstring("NEGF   ")
%+A   when qINCF: outstring("INCF   ")   when qDECF:  outstring("DECF   ")
%+A   when qSHL1: outstring("SHL    ")   when qSHL1F: outstring("SHLF   ")
%+A   when qSHR1: outstring("SHR    ")   when qSHR1F: outstring("SHRF   ")
%+A   when qSAR1: outstring("SAR    ")   when qSAR1F: outstring("SARF   ")
%+A   endcase;
%+A end;


%+A Routine eddyad; import range(0:19) subc;
%+A begin case 0:19 (subc)               when qCMP:  outstring("CMP    ")
%+A       when qAND:  outstring("AND    ")    when qANDM: outstring("ANDM   ")
%+A       when qOR:   outstring("OR     ")    when qORM:  outstring("ORM    ")
%+A       when qXOR:  outstring("XOR    ")    when qXORM: outstring("XORM   ")
%+A       when qADD:  outstring("ADD    ")    when qSUB:  outstring("SUB    ")
%+A       when qADC:  outstring("ADC    ")    when qSBB:  outstring("SBB    ")
%+A       when qADDM: outstring("ADDM   ")    when qSUBM: outstring("SUBM   ")
%+A       when qADDF: outstring("ADDF   ")    when qSUBF: outstring("SUBF   ")
%+A       when qADCF: outstring("ADCF   ")    when qSBBF: outstring("SBBF   ")
%+A       when qINCO: outstring("INCO   ")    when qDECO: outstring("DECO   ")
%+A       endcase;
%+A end;

%+A %-E Routine edinco; import range(0:19) subc; range(0:nregs) qreg;
%+A %-E begin I_LINE; outstring("JNC    $+");
%+A %-E       outword(if subc=qINCO then 5 else 4);
%+A %-E       I_LINE; outstring("XOR    "); outreg(qreg);
%+A %-E       outchar(','); outreg(qreg);
%+A %-E       if subc=qINCO
%+A %-E       then I_LINE; outstring("DEC    "); outreg(qreg) endif;
%+A %-E end;


%+A Routine outtriadr; import range(0:15) subc;
%+A begin case 0:15 (subc)
%+A   when qWMUL:  outstring("MUL    ")   when qIMUL:  outstring("IMUL   ")
%+A   when qWDIV:  outstring("DIV    ")   when qIDIV:  outstring("IDIV   ")
%+A   when qWMOD:  outstring("DIV    ")   when qIMOD:  outstring("IDIV   ")
%+A   when qWMULF: outstring("MULF   ")   when qIMULF: outstring("IMULF  ")
%+A   when qWDIVF: outstring("DIVF   ")   when qIDIVF: outstring("IDIVF  ")
%+A   when qWMODF: outstring("DIVF   ")   when qIMODF: outstring("IDIVF  ")
%+A   endcase;
%+A end;


%+A Routine edfmonadc; import range(0:5) subc;
%+A begin case 0:5 (subc)
%+A   when qFNEG: outstring("FCHS   ")   when qFSQRT: outstring("FSQRT  ")
%+A   when qFABS: outstring("FABS   ")   when qFRND:  outstring("FRNDINT ")
%+A   when qFREM: outstring("FPREM  ")
%+A   endcase;
%+A end;


%+A Routine edfdyadc; import range(0:7) subc;
%+A begin case 0:7 (subc)
%+A   when qFCOM:  outstring("COMP   ")   when qFADD:  outstring("ADD    ")
%+A   when qFSUB:  outstring("SUB    ")   when qFSUBR: outstring("SUBR   ")
%+A   when qFMUL:  outstring("MUL    ")   when qFDIV:  outstring("DIV    ")
%+A   when qFDIVR: outstring("DIVR   ")
%+A   endcase;
%+A end;


%+A Routine edfdyadp; import range(0:7) subc;
%+A begin case 0:7 (subc)
%+A   when qFCOM:  outstring("COMPP  ")   when qFADD:  outstring("ADDP   ")
%+A   when qFSUB:  outstring("SUBP   ")   when qFSUBR: outstring("SUBRP  ")
%+A   when qFMUL:  outstring("MULP   ")   when qFDIV:  outstring("DIVP   ")
%+A   when qFDIVR: outstring("DIVRP  ")
%+A   endcase;
%+A end;


%+A Routine edqcond; import range(0:14) qcond;
%+A begin case 0:14 (qcond)
%+A   when q_WLT: outstring("WLT,")   when q_ILT: outstring("ILT,")
%+A   when q_WLE: outstring("WLE,")   when q_ILE: outstring("ILE,")
%+A   when q_WEQ: outstring("WEQ,")   when q_IEQ: outstring("IEQ,")
%+A   when q_WGE: outstring("WGE,")   when q_IGE: outstring("IGE,")
%+A   when q_WGT: outstring("WGT,")   when q_IGT: outstring("IGT,")
%+A   when q_WNE: outstring("WNE,")   when q_INE: outstring("INE,")
%+A   endcase;
%+A end;


%+A Routine edfldcc; import range(0:7) subc;
%+A begin case 0:7 (subc)
%+A   when qFLDZ:   outstring("FLDZ")
%+A   when qFLD1:   outstring("FLD1")
%+A   when qFLDPI:  outstring("FLDPI")
%+A   when qFLDL2T: outstring("FLDL2T")
%+A   when qFLDL2E: outstring("FLDL2E")
%+A   when qFLDLG2: outstring("FLDLG2")
%+A   when qFLDLN2: outstring("FLDLN2")
%+A   endcase;
%+A end;

%+AE Routine EdWxCONV; import range(0:MaxByte) from,fSP,to,tSP;
%+AE begin case 0:6 (from)
%+AE       when FMF_INT,FMF_SINT:
%+AE            case 0:6 (to)
%+AE            when FMF_INT,FMF_SINT: outstring("WFLD   WS")
%+AE            when FMF_REAL:         outstring("WFLOAT WS")
%+AE            when FMF_LREAL:        outstring("WFLOAT WD")
%+AE            endcase; outword(tSP);
%+AE            if fSP = 0 then outchar(',');
%+AE            else outstring(",WS"); outword(fSP) endif;
%+AE       when FMF_REAL:
%+AE            case 0:6 (to)
%+AE            when FMF_INT,FMF_SINT: outstring("WFIX   WS")
%+AE            when FMF_REAL:         outstring("WFLD   WS")
%+AE            when FMF_LREAL:        outstring("WFCVT  WD")
%+AE            endcase; outword(tSP);
%+AE            if fSP = 0 then outchar(',');
%+AE            else outstring(",WS"); outword(fSP) endif;
%+AE       when FMF_LREAL: case 0:6 (to)
%+AE            when FMF_INT,FMF_SINT: outstring("WFIX   WS")
%+AE            when FMF_REAL:         outstring("WFCVT  WS")
%+AE            when FMF_LREAL:        outstring("WFLD   WD")
%+AE            endcase; outword(tSP);
%+AE            if fSP = 0 then outchar(',');
%+AE            else outstring(",WD"); outword(fSP) endif;
%+AE       endcase;
%+AE end;

%+A Routine EdFLD; -------- FLD     fSD fmf opr --------------  Format 3
%+A import ref(Qfrm3) qi;
%+A begin infix(MemAddr) opr; range(0:MaxByte) fmf;
%+AE      range(0:MaxByte) fSD,fwf,fSP,qereg,ereg;

%+A       opr:=qi qua Qfrm3.opr; fmf:=qi.reg;
%+AE      fSD:=qi.subc; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       --- Q-Code:
%+A       outstring("FLD    ");
%+AE      edfmf(fwf); outword(fSP); outchar(' ');
%+A       edfmf(fmf); outchar(':'); outopr(opr);
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then qereg:=RegAvailable(qi);
%+AE                if qereg <> 0 then ereg:=qereg;
%+AE                else outstring("PUSH   EAX");
%+AE                     I_LINE; ereg:=qEAX;
%+AE                endif;
%+AE                if fmf=FMF_SINT
%+AE                then outstring("MOVSX  "); outreg(ereg);
%+AE                     outstring(",WORD PTR ");
%+AE                else outstring("MOV    "); outreg(ereg);
%+AE                     if fmf=FMF_LREAL
%+AE                     then outstring(",DWORD PTR ");
%+AE                          outopr(opr); I_LINE;
%+AE                          fmf:=fwf:=FMF_REAL;
%+AE                          EdWxCONV(fmf,0,fwf,fSP+1);
%+AE                          outreg(ereg); I_LINE;
%+AE                          opr.rela.val:=opr.rela.val+4;
%+AE                          outstring("MOV    "); outreg(ereg);
%+AE                     endif;
%+AE                     outstring(",DWORD PTR ");
%+AE                endif;
%+AE                outopr(opr); I_LINE;
%+AE                EdWxCONV(fmf,0,fwf,fSP); outreg(ereg);
%+AE                if qereg = 0
%+AE                then I_LINE; outstring("POP    EAX") endif;
%+AE           else
%+A                 case 0:6 (fmf)
%+A                 when FMF_SINT:  outstring("FILD   WORD PTR ")
%+A                 when FMF_INT:   outstring("FILD   DWORD PTR ")
%+A                 when FMF_REAL:  outstring("FLD    DWORD PTR ")
%+A                 when FMF_LREAL: outstring("FLD    QWORD PTR ")
%+A                 when FMF_TEMP:  outstring("FLD    TBYTE PTR ")
%+A                 otherwise outstring("FLD    **ERROR** ") endcase;
%+A                 outopr(opr);
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFLDC; ------- FLDC    sreg fmf val -----------  Format 3+
%+AE                ------- FLDC    fSD  fmf val -----------  Format 3+
%+A import ref(Qfrm3) qi;
%+A begin infix(MemAddr) opr; range(0:MaxByte) fmf; infix(ValueItem) val
%+AE      range(0:MaxByte) fSD,fwf,fSP,qereg,ereg;

%+A       val:=qi qua Qfrm3.val; fmf:=qi.reg;
%+AE      fSD:=qi.subc; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       --- Q-Code:
%+A       outstring("FLDC   ");
%+AE      edfmf(fwf); outword(fSP); outchar(' ');
%+A       edfmf(fmf); outchar(':');
%+A %-E   outreg(qi.subc); outchar(':');
%+A       case 0:6 (qi.reg)
%+A       when FMF_SINT:  outword(val.wrd)
%+A       when FMF_INT:   outint(val.int)
%+A       when FMF_REAL:  EdReal(sysout,val.rev)
%+A       when FMF_LREAL: EdLreal(sysout,val.lrv)
%+A       endcase;
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then qereg:=RegAvailable(qi);
%+AE                if qereg <> 0 then ereg:=qereg;
%+AE                else outstring("PUSH   EAX");
%+AE                     I_LINE; ereg:=qEAX;
%+AE                endif;
%+AE                EdLoadCnst(qi,ereg,qi qua Qfrm3.val.int(0));
%+AE                I_LINE;
%+AE                if fmf=FMF_LREAL
%+AE                then fmf:=fwf:=FMF_REAL;
%+AE                     EdWxCONV(fmf,0,fwf,fSP+1);
%+AE                     outreg(ereg); I_LINE;
%+AE                     EdLoadCnst(qi,ereg,qi qua Qfrm3.val.int(1));
%+AE                     I_LINE;
%+AE                endif;
%+AE                EdWxCONV(fmf,0,fwf,fSP); outreg(ereg);
%+AE                if qereg = 0
%+AE                then I_LINE; outstring("POP    EAX") endif;
%+AE           else
%+A                 case 0:6 (fmf)
%+A                 when FMF_SINT:  outstring("FILD   WORD PTR ...")
%+A                 when FMF_INT:   outstring("FILD   DWORD PTR ...")
%+A                 when FMF_REAL:  outstring("FLD    DWORD PTR ...")
%+A                 when FMF_LREAL: outstring("FLD    QWORD PTR ...")
%+A                 otherwise outstring("FLD    **ERROR** ") endcase;
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFDUP; ------- FDUP    fSD ----------------------  Format 1
%+A import ref(Qfrm1) qi;
%+A begin
%+AE      range(0:MaxByte) fSD,fwf,fSP;

%+AE      fSD:=qi.subc; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       --- Q-Code:
%+A       outstring("FDUP   ");
%+AE      edfmf(fwf); outword(fSP);
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then if fwf=FMF_LREAL
%+AE                then outstring("WFLD   WD"); outword(fSP);
%+AE                     outstring(",WD"); outword(fSP-2);
%+AE                else outstring("WFLD   WS"); outword(fSP);
%+AE                     outstring(",WS"); outword(fSP-2);
%+AE                endif;
%+AE           else
%+A                 outstring("FLD    ST(0)");
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFST; -------- FST     fSD fmf opr --------------  Format 3
%+A import ref(Qfrm3) qi;
%+A begin infix(MemAddr) opr; range(0:MaxByte) fmf;
%+AE      range(0:MaxByte) fSD,fwf,fSP,qereg,ereg;

%+A       opr:=qi qua Qfrm3.opr; fmf:=qi.reg;
%+AE      fSD:=qi.subc; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       --- Q-Code:
%+A       outstring("FST    ");
%+AE      edfmf(fwf); outword(fSP); outchar(' ');
%+A       edfmf(fmf); outchar(':'); outopr(opr);
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then qereg:=RegAvailable(qi);
%+AE                if qereg <> 0 then ereg:=qereg;
%+AE                else outstring("PUSH   EAX");
%+AE                     I_LINE; ereg:=qEAX;
%+AE                endif;
%+AE                if fwf <> fmf
%+AE                then EdWxCONV(fwf,fSP,fmf,fSP); I_LINE endif;
%+AE                if fmf=FMF_LREAL
%+AE                then outstring("WFST   "); outreg(ereg);
%+AE                     outstring(",WS"); outword(fSP+1); I_LINE;
%+AE                     outstring("MOV    DWORD PTR ");
%+AE                     outopr(opr); outchar(',');
%+AE                     outreg(ereg); I_LINE;
%+AE                     opr.rela.val:=opr.rela.val+4;
%+AE                endif;
%+AE                outstring("WFST   "); outreg(ereg);
%+AE                outstring(",WS"); outword(fSP); I_LINE;
%+AE                if fmf=FMF_SINT then outstring("MOV    WORD PTR ")
%+AE                else outstring("MOV    DWORD PTR ") endif;
%+AE                outopr(opr); outchar(',');
%+AE                outreg(ereg);
%+AE                if qereg = 0
%+AE                then I_LINE; outstring("POP    EAX") endif;
%+AE           else
%+A                 case 0:6 (fmf)
%+A                 when FMF_SINT:  outstring("FIST   WORD PTR ")
%+A                 when FMF_INT:   outstring("FIST   DWORD PTR ")
%+A                 when FMF_REAL:  outstring("FST    DWORD PTR ")
%+A                 when FMF_LREAL: outstring("FST    QWORD PTR ")
%+A                 when FMF_TEMP:  outstring("FST    TBYTE PTR ")
%+A                 otherwise outstring("FST    **ERROR** ") endcase;
%+A                 outopr(opr);
%+A                 I_LINE; outstring("WAIT"); -- Explicit -- TEMP
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFSTP; ------- FSTP    fSD fmf opr --------------  Format 3
%+A import ref(Qfrm3) qi;
%+A begin infix(MemAddr) opr; range(0:MaxByte) fmf;
%+AE      range(0:MaxByte) fSD,fwf,fSP,qereg,ereg;

%+A       opr:=qi qua Qfrm3.opr; fmf:=qi.reg;
%+AE      fSD:=qi.subc; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       --- Q-Code:
%+A       outstring("FSTP   ");
%+AE      edfmf(fwf); outword(fSP); outchar(' ');
%+A       edfmf(fmf); outchar(':'); outopr(opr);
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then qereg:=RegAvailable(qi);
%+AE                if qereg <> 0 then ereg:=qereg;
%+AE                else outstring("PUSH   EAX");
%+AE                     I_LINE; ereg:=qEAX;
%+AE                endif;
%+AE                if fwf <> fmf
%+AE                then EdWxCONV(fwf,fSP,fmf,fSP); I_LINE endif;
%+AE                if fmf=FMF_LREAL
%+AE                then outstring("WFST   "); outreg(ereg);
%+AE                     outstring(",WS"); outword(fSP+1); I_LINE;
%+AE                     outstring("MOV    DWORD PTR ");
%+AE                     outopr(opr); outchar(',');
%+AE                     outreg(ereg); I_LINE;
%+AE                     opr.rela.val:=opr.rela.val+4;
%+AE                endif;
%+AE                outstring("WFST   "); outreg(ereg);
%+AE                outstring(",WS"); outword(fSP); I_LINE;
%+AE                if fmf=FMF_SINT then outstring("MOV    WORD PTR ")
%+AE                else outstring("MOV    DWORD PTR ") endif;
%+AE                outopr(opr); outchar(',');
%+AE                outreg(ereg);
%+AE                if qereg = 0
%+AE                then I_LINE; outstring("POP    EAX") endif;
%+AE           else
%+A                 case 0:6 (fmf)
%+A                 when FMF_SINT:  outstring("FISTP  WORD PTR ")
%+A                 when FMF_INT:   outstring("FISTP  DWORD PTR ")
%+A                 when FMF_REAL:  outstring("FSTP   DWORD PTR ")
%+A                 when FMF_LREAL: outstring("FSTP   QWORD PTR ")
%+A                 when FMF_TEMP:  outstring("FSTP   TBYTE PTR ")
%+A                 otherwise outstring("FLD    **ERROR** ") endcase;
%+A                 outopr(opr);
%+A                 I_LINE; outstring("WAIT"); -- Explicit -- TEMP
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFPUSH; ------ FPUSH   fSD fmf ------------------  Format 1
%+A import ref(Qfrm1) qi;
%+A begin range(0:MaxByte) fmf;
%+AE      range(0:MaxByte) fSD,fwf,fSP;
%+AE      fSD:=qi.subc; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       fmf:=qi.reg;
%+A       --- Q-Code:
%+A       outstring("FPUSH  ");
%+AE      edfmf(fwf); outword(fSP); outchar(' ');
%+A       edfmf(fmf);
%+A       if ListI
%+A       then I_CODE;
%+A %-E        case 0:6 (fmf)
%+A %-E        when FMF_SINT:  EdSubSP(2); I_LINE;
%+A %-E                        outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FISTP  SS:WORD PTR [DI]")
%+A %-E        when FMF_INT:   EdSubSP(4); I_LINE;
%+A %-E                        outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FISTP  SS:DWORD PTR [DI]")
%+A %-E        when FMF_REAL:  EdSubSP(4); I_LINE;
%+A %-E                        outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FSTP   SS:DWORD PTR [DI]")
%+A %-E        when FMF_LREAL: EdSubSP(8); I_LINE;
%+A %-E                        outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FSTP   SS:QWORD PTR [DI]")
%+A %-E        when FMF_TEMP:  EdSubSP(10); I_LINE;
%+A %-E                        outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FSTP   SS:TBYTE PTR [DI]")
%+A %-E        otherwise outstring("FSTP   **ERROR** ") endcase;
%+A %-E        I_LINE; outstring("WAIT"); -- Explicit -- TEMP
%+AE           if NUMID=WTLx167
%+AE           then if fwf <> fmf
%+AE                then EdWxCONV(fwf,fSP,fmf,fSP); I_LINE endif;
%+AE                if fmf=FMF_LREAL
%+AE                then outstring("WFPUSH WD") else outstring("WFPUSH WS") endif;
%+AE                outword(fSP);
%+AE           else case 0:6 (fmf)
%+AE                when FMF_SINT:  EdSubSP(4); I_LINE;
%+AE                                outstring("FISTP  DWORD PTR [ESP]")
%+AE                when FMF_INT:   EdSubSP(4); I_LINE;
%+AE                                outstring("FISTP  DWORD PTR [ESP]")
%+AE                when FMF_REAL:  EdSubSP(4); I_LINE;
%+AE                                outstring("FSTP   DWORD PTR [ESP]")
%+AE                when FMF_LREAL: EdSubSP(8); I_LINE;
%+AE                                outstring("FSTP   QWORD PTR [ESP]")
%+AE                when FMF_TEMP:  EdSubSP(12); I_LINE;
%+AE                                outstring("FSTP   TBYTE PTR [ESP]")
%+AE                otherwise outstring("FSTP   **ERROR** ") endcase;
%+AE                I_LINE; outstring("WAIT"); -- Explicit -- TEMP
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFPOP; ------- FPOP    fSD fmf ------------------  Format 1
%+A import ref(Qfrm1) qi;
%+A begin range(0:MaxByte) fmf;
%+AE      range(0:MaxByte) fSD,fwf,fSP;
%+AE      fSD:=qi.subc; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       fmf:=qi.reg;
%+A       --- Q-Code:
%+A       outstring("FPOP   ");
%+AE      edfmf(fwf); outword(fSP); outchar(' ');
%+A       edfmf(fmf);
%+A       if ListI
%+A       then I_CODE;
%+A %-E        case 0:6 (fmf)
%+A %-E        when FMF_SINT:  outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FILD   SS:WORD PTR [DI]"); I_LINE;
%+A %-E                        EdAddSP(qi,2);
%+A %-E        when FMF_INT:   outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FILD   SS:DWORD PTR [DI]"); I_LINE;
%+A %-E                        EdAddSP(qi,4);
%+A %-E        when FMF_REAL:  outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FLD    SS:DWORD PTR [DI]"); I_LINE;
%+A %-E                        EdAddSP(qi,4);
%+A %-E        when FMF_LREAL: outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FLD    SS:QWORD PTR [DI]"); I_LINE;
%+A %-E                        EdAddSP(qi,8);
%+A %-E        when FMF_TEMP:  outstring("MOV    DI,SP"); I_LINE;
%+A %-E                        outstring("FLD    SS:TBYTE PTR [DI]"); I_LINE;
%+A %-E                        EdAddSP(qi,10);
%+A %-E        otherwise outstring("FSTP   **ERROR** ") endcase;
%+AE           if NUMID=WTLx167
%+AE           then if fwf=FMF_LREAL
%+AE                then outstring("WFPOP  WD") else outstring("WFPOP  WS") endif;
%+AE                outword(fSP);
%+AE                if fwf <> fmf
%+AE                then I_LINE; EdWxCONV(fmf,fSP,fwf,fSP) endif;
%+AE           else case 0:6 (fmf)
%+AE                when FMF_SINT:  outstring("FILD   WORD PTR [ESP]"); I_LINE;
%+AE                                EdAddSP(qi,4);
%+AE                when FMF_INT:   outstring("FILD   DWORD PTR [ESP]"); I_LINE;
%+AE                                EdAddSP(qi,4);
%+AE                when FMF_REAL:  outstring("FLD    DWORD PTR [ESP]"); I_LINE;
%+AE                                EdAddSP(qi,4);
%+AE                when FMF_LREAL: outstring("FLD    QWORD PTR [ESP]"); I_LINE;
%+AE                                EdAddSP(qi,8);
%+AE                when FMF_TEMP:  outstring("FLD    TBYTE PTR [ESP]"); I_LINE;
%+AE                                EdAddSP(qi,12);
%+AE                otherwise outstring("FSTP   **ERROR** ") endcase;
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFLDCK; ------ FLDCK   subc ---------------------  Format 1
%+A import ref(Qfrm1) qi;
%+A begin --- Q-Code:
%+A       outstring("FLDCK  "); outword(qi.subc);
%+A       if ListI then I_CODE; edfldcc(qi.subc) endif;
%+A end;

%+A Routine EdFMONAD; ----- FMONAD  subc fSD -----------------  Format 1
%+A import ref(Qfrm1) qi;
%+A begin
%+AE      range(0:MaxByte) fSD,fwf,fSP;

%+AE      fSD:=qi.reg; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       --- Q-Code:
%+A       edfmonadc(qi.subc);
%+AE      outchar(' '); edfmf(fwf); outword(fSP);
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then case 0:5 (qi.subc)
%+AE                when qFNEG:  outstring("WFNEG  ");
%+AE                when qFSQRT: outstring("WFSQRT ");
%+AE                when qFABS:  outstring("WFABS  ");
-- ??? %+AE         when qFRND:  outstring("WF???  ");
-- ??? %+AE         when qFREM:  outstring("WF???  ");
%+AE                otherwise IERR("COASM:WTL-FMONAD")
%+AE                endcase;
%+AE                if fwf=FMF_LREAL
%+AE                then outstring("WD"); outword(fSP);
%+AE                     outstring(",WD"); outword(fSP);
%+AE                else outstring("WS"); outword(fSP);
%+AE                     outstring(",WS"); outword(fSP);
%+AE                endif;
%+AE           else
%+A                 edfmonadc(qi.subc);
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFDYAD; ------ FDYAD   subc fSD -----------------  Format 1
%+A import ref(Qfrm1) qi;
%+A begin
%+AE      range(0:MaxByte) fSD,fwf,fSP,tx,fx;

%+AE      fSD:=qi.reg; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31);
%+A       --- Q-Code:
%+A       outchar('F'); edfdyadp(qi.subc);
%+AE      outchar(' '); edfmf(fwf); outword(fSP);
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then tx:=fSP-2; fx:=fSP;
%+AE                case 0:7 (qi.subc)
%+AE                when qFCOM:  outstring("WFCMP  ")
%+AE                when qFADD:  outstring("WFADD  ")
%+AE                when qFSUB:  outstring("WFSUB  ")
%+AE                when qFSUBR: outstring("WFSUB  "); fx:=tx; tx:=fSP;
%+AE                when qFMUL:  outstring("WFMUL  ")
%+AE                when qFDIV:  outstring("WFDIV  ")
%+AE                when qFDIVR: outstring("WFDIV  "); fx:=tx; tx:=fSP;
%+AE                endcase;
%+AE                if fwf=FMF_LREAL
%+AE                then outstring("WD"); outword(tx);
%+AE                     outstring(",WD"); outword(fx);
%+AE                else outstring("WS"); outword(tx);
%+AE                     outstring(",WS"); outword(fx);
%+AE                endif;
%+AE                if tx>fx
%+AE                then I_LINE; outstring("WFLD   ");
%+AE                     if fwf=FMF_LREAL
%+AE                     then outstring("WD"); outword(fx);
%+AE                          outstring(",WD"); outword(tx);
%+AE                     else outstring("WS"); outword(fx);
%+AE                          outstring(",WS"); outword(tx);
%+AE                     endif;
%+AE                elsif qi.subc=qFCOM
%+AE                then I_LINE; outstring("WFSTCTX EAX");
%+AE                     I_LINE; outstring("SAHF");
%+AE                endif;
%+AE           else
%+A                 outchar('F'); edfdyadp(qi.subc);
%+A                 if qi.subc = qFCOM
%+A                 then if NUMID < iAPX287
%+A                      then I_LINE; outstring("FSTSW  ");
%+A                           outopr(TMPAREA);
%+A                           I_LINE; outstring("WAIT");
%+A                           I_LINE; outstring("MOV    AX,");
%+A                           outopr(TMPAREA);
%+A                      else I_LINE; outstring("FSTSW  AX") endif;
%+A                      I_LINE; outstring("SAHF");
%+A                 else outstring("ST(1),ST") endif;
%+AE           endif;
%+A       endif;
%+A end;

%+A Routine EdFDYADM; ----- FDYADM  subc fmf fSD opr ---------  Format 4
%+A import ref(Qfrm4) qi;
%+A begin infix(MemAddr) opr; range(0:MaxByte) fmf;
%+AE      infix(String) opc;
%+AE      range(0:MaxByte) fSD,fwf,fSP,tx,fx,qereg,ereg;

%+A       opr:=qi qua Qfrm4.opr; fmf:=qi.reg;
%+AE      fSD:=qi qua Qfrm4.aux.LO; fwf:=bSHR(fSD,5); fSP:=bAND(fSD,31)
%+A       --- Q-Code:
%+A       outchar('F'); edfdyadc(qi.subc);
%+AE      edfmf(fwf); outword(fSP); outchar(' ');
%+A       edfmf(fmf); outchar(':'); outopr(opr);
%+A       if ListI
%+A       then I_CODE;
%+AE           if NUMID=WTLx167
%+AE           then qereg:=RegAvailable(qi);
%+AE                if qereg <> 0 then ereg:=qereg;
%+AE                else outstring("PUSH   EAX");
%+AE                     I_LINE; ereg:=qEAX;
%+AE                endif;
%+AE                if fmf=FMF_SINT
%+AE                then outstring("MOVSX  "); outreg(ereg);
%+AE                     outstring(",WORD PTR ");
%+AE                else outstring("MOV    "); outreg(ereg);
%+AE                     if fmf=FMF_LREAL
%+AE                     then outstring(",DWORD PTR ");
%+AE                          outopr(opr); I_LINE;
%+AE                          outstring("WFLD   WS1,");
%+AE                          outreg(ereg); I_LINE;
%+AE                          opr.rela.val:=opr.rela.val+4;
%+AE                          outstring("MOV    "); outreg(ereg);
%+AE                     endif;
%+AE                     outstring(",DWORD PTR ");
%+AE                endif;
%+AE                outopr(opr); I_LINE;
%+AE                tx:=fSP-2; fx:=fSP;
%+AE                case 0:7 (qi.subc)
%+AE                when qFCOM:  opc:="WFCMP  "
%+AE                when qFADD:  opc:="WFADD  "
%+AE                when qFSUB:  opc:="WFSUB  "; fx:=tx; tx:=fSP;
%+AE                when qFSUBR: opc:="WFSUB  "
%+AE                when qFMUL:  opc:="WFMUL  "
%+AE                when qFDIV:  opc:="WFDIV  "; fx:=tx; tx:=fSP;
%+AE                when qFDIVR: opc:="WFDIV  "
%+AE                endcase;
%+AE                if (fwf <> fmf) or (tx > fx)
%+AE                then I_LINE; EdWxCONV(fmf,0,fwf,fSP);
%+AE                     outreg(ereg);
%+AE                     I_LINE; outstring(opc);
%+AE                     if fwf=FMF_LREAL
%+AE                     then outstring("WD"); outword(tx);
%+AE                          outstring(",WD"); outword(fx);
%+AE                     else outstring("WS"); outword(tx);
%+AE                          outstring(",WS"); outword(fx);
%+AE                     endif;
%+AE                     if tx > fx
%+AE                     then I_LINE; outstring("WFLD   ");
%+AE                          if fwf=FMF_LREAL
%+AE                          then outstring("WD"); outword(fx);
%+AE                               outstring(",WD"); outword(tx);
%+AE                          else outstring("WS"); outword(fx);
%+AE                               outstring(",WS"); outword(tx);
%+AE                          endif;
%+AE                     endif;
%+AE                else I_LINE; outstring(opc);
%+AE                     if fwf=FMF_LREAL then outstring("WD")
%+AE                     else outstring("WS") endif;
%+AE                     outword(tx);
%+AE                     outchar(','); outreg(ereg);
%+AE                endif;
%+AE                if qereg = 0
%+AE                then I_LINE; outstring("POP    EAX") endif;
%+AE                if qi.subc=qFCOM
%+AE                then I_LINE; outstring("WFSTCTX EAX");
%+AE                     I_LINE; outstring("SAHF");
%+AE                endif;
%+AE           else
%+A                 case 0:6 (fmf)
%+A                 when FMF_SINT:  outstring("FI");
%+A                                 edfdyadc(qi.subc);
%+A                                 outstring("WORD PTR ")
%+A                 when FMF_INT:   outstring("FI");
%+A                                 edfdyadc(qi.subc);
%+A                                 outstring("DWORD PTR ")
%+A                 when FMF_REAL:  outstring("F");
%+A                                 edfdyadc(qi.subc);
%+A                                 outstring("DWORD PTR ")
%+A                 when FMF_LREAL: outstring("F");
%+A                                 edfdyadc(qi.subc);
%+A                                 outstring("QWORD PTR ")
%+A                 when FMF_TEMP:  outstring("F");
%+A                                 edfdyadc(qi.subc);
%+A                                 outstring("TBYTE PTR ")
%+A                 endcase;
%+A                 outopr(opr);
%+A                 if qi.subc = qFCOM
%+A                 then if NUMID < iAPX287
%+A                      then I_LINE; outstring("FSTSW  ");
%+A                           outopr(TMPAREA);
%+A                           I_LINE; outstring("WAIT");
%+A                           I_LINE; outstring("MOV    AX,");
%+A                           outopr(TMPAREA);
%+A                      else I_LINE; outstring("FSTSW  AX") endif;
%+A                      I_LINE; outstring("SAHF");
%+A                 endif;
%+AE           endif;
%+A       endif;
%+A end;

%title *****************   ASSEMBLY  OUTPUT  ROUTINE   *****************
%+A Routine NewFile; import range(0:132) nchr; export ref(File) val;
%+A begin val:=NEWOBZ(size(File:nchr)); val.nchr:=nchr end;

%+A Visible Routine ASMUT;
%+A begin infix(WORD) sx,segid,segx,extid,extx; ref(LinePkt) lpk;
%+A    ref(File) asmscr; infix(String) image,action;
%+A    range(0:132) filled; range(0:2) pflg;
%+A    Range(0:MaxWord) DGROUPx;

%+A    asmscr:=NewFile(80);


%+A    --- Open Assembly Output File ---
%+A    EdSymb(sysedit,ASMID);
%+A    action:="!1!!1!!2!!1!!1!!2!!0!!0!!0!!0!";  -- outfile
%+A    objfile:=open(pickup(sysedit),2,action,0);

%+A    --- Output Module Name ---
%+A    Ed(sysedit,"NAME"); setpos(sysedit,11);
%+A    EdSymb(sysedit,PROGID); A_OUT(pickup(sysedit));

%+A    --- Output Instruction Set Directives ---
%+A    case 0:4 (CPUID)
%+A    when iAPX86:   A_OUT(".8086")
%+A    when iAPX186:  A_OUT(".186")
%+A    when iAPX286:  A_OUT(".286C")
%+A    endcase;
%+A    case 0:2 (NUMID)
%+A    when iAPX87:   A_OUT(".8087")
%+A    when iAPX287:  A_OUT(".287")
%+A    endcase;

%+A    --- Output Macro Definitions ---
%+A    Prt("RETF MACRO  X");
%+A    Prt("  DB 11001010B");
%+A    Prt("  DB X ; Low");
%+A    Prt("  DB 0 ; High");
%+A    Prt("  ENDM");

%+A    --- Output External References ---
%+A    segx.val:=0;
%+A    repeat while segx.val < DIC.nSegm
%+A    do segx.val:=segx.val+1; pflg:=0;
%+A       segid:=DIC.Segm(segx.HI).elt(segx.LO);
%+A       extx.val:=0;
%+A       repeat while extx.val < DIC.nExtr
%+A       do extx.val:=extx.val+1;
%+A          extid:=DIC.Extr(extx.HI).elt(extx.LO);
%+A          if DICREF(extid) qua Extern.segid=segid
%+A          then if pflg = 0
%+A               then if segid.val=0 then pflg:=1
%+A                    else pflg:=2; PrtSEG(segid) endif;
%+A               endif;
%+A               setpos(sysedit,11); Ed(sysedit,"EXTRN   ");
%+A               EdSymb(sysedit,extid);
%+A               if DICREF(segid) qua Segment.type=aCODE
%+A               then Ed(sysedit,":FAR");
%+A               else Ed(sysedit,":WORD") endif;
%+A               A_OUT(pickup(sysedit));
%+A          endif;
%+A       endrepeat;
%+A       if pflg=2 then PrtENDS(segid) endif;
%+A    endrepeat;

%+A    --- Output DGROUP Specification ---
%+A    DGROUPx:=DICREF(DGROUP) qua Segment.segx.val;
%+A    if DGROUPx <> 0
%+A    then Prt("DGROUP    GROUP _DATA");
%+A         Prt("          ASSUME SS:DGROUP");
%+A    endif;

%+A    segx.val:=0;
%+A    repeat while segx.val < DIC.nSegm
%+A    do segx.val:=segx.val+1; pflg:=0;
%+A       segid:=DIC.Segm(segx.HI).elt(segx.LO);
%+A       --- Open Scratch Input File Name ---
%+A       if envpar then edtextinfo(sysedit,7);
%+A       else if SCRID.val = 0
%+A            then Ed(sysedit,"ICODE.TMP")
%+A            else EdSymb(sysedit,SCRID) endif;
%+A       endif;
%+A       action:="!0!!1!!1!!0!!1!!2!!0!!0!!0!!0!";  -- infile
%+A       asmscr.key:=open(pickup(sysedit),1,action,0);
%+A       sx.val:=0;

%+A  NXT1:NXT2:image.chradr:=@asmscr.chr; image.nchr:=asmscr.nchr-1;
%+A       filled:=EnvInImage(asmscr.key,image);
%+A       if status > 0
%+A       then if (status=13) or (status=16)
%+A            then status:=0; goto CLS; --- End-of-File ---
%+A            else FILERR(asmscr.key,"ASMUT-2") endif;
%+A       endif;
%+A       asmscr.pos:=0; image.nchr:=filled;
%+A       if InputTrace > 0
%+A       then outstring("*** ASM-INPUT:  "); outstring(image);
%+A            outimage;
%+A       endif;
%+A       if asmscr.chr='#'
%+A       then sx.val:=(asmscr.chr(1) qua integer) - 48;   --- TEMP
%+A            if InputTrace > 0
%+A            then outstring("*** SEG: "); outint(segx.val);
%+A                 outchar('/'); outint(sx.val);
%+A                 outimage;
%+A            endif;
%+A            goto NXT1;
%+A       endif;
%+A       if sx = segx
%+A       then if pflg = 0
%+A            then pflg:=1; --- Output Segment Heading ---
%+A                 if segid = DSEGID
%+A                 then PrtSEG(DSEGID);
%+A                      setpos(sysedit,11); Ed(sysedit,"ASSUME  DS:");
%+A                      if DSEGID=DGROUP then Ed(sysedit,"DGROUP")
%+A                      else EdSymb(sysedit,DSEGID) endif;
%+A                      A_OUT(pickup(sysedit));
%+A                      Ed(sysedit,"SEG"); edint(sysedit,segx.val);
%+A                      setpos(sysedit,11); Prt("LABEL  WORD");
%+A                 else PrtSEG(segid);
%+A                      setpos(sysedit,11); Ed(sysedit,"ASSUME  CS:");
%+A                      EdSymb(sysedit,segid); A_OUT(pickup(sysedit));
%+A                      Ed(sysedit,"SEG"); edint(sysedit,segx.val);
%+A                      setpos(sysedit,11); Prt("LABEL  NEAR");
%+A                 endif;
%+A            endif;
%+A            A_OUT(image);
%+A       endif; goto NXT2;
%+A  CLS:
%+A       EnvClose(asmscr.key,nostring);
%+A       if status>0 then FILERR(asmscr.key,"ASMUT-4") endif;
%+A       --- Output Segment End ---
%+A       if pflg <> 0 then PrtENDS(segid) endif;
%+A    endrepeat;

%+A    --- Output Program Final End ---
%+A    setpos(sysedit,11); Ed(sysedit,"END");
%+A    A_OUT(pickup(sysedit));

%+A    EnvClose(objfile,nostring);
%+A    if status>0 then FILERR(objfile,"ASMOUT-5") endif; objfile:=0;
%+A end;

%+A Routine A_OUT; import infix(String) image;
%+A begin
%+AD      if listsw > 0
%+AD      then outstring("*** ASM-OUTPUT: "); outstring(image);
%+AD           outimage;
%+AD      endif;
%+A       EnvOutImage(objfile,image);
%+A       if status>0 then FILERR(objfile,"A_OUT") endif;
%+A end;

%+A Routine Prt; import infix(String) mss;
%+A begin Ed(sysedit,mss); A_OUT(pickup(sysedit)) end;

%+A Routine PrtSEG; import infix(WORD) segid;
%+A begin ref(Segment) seg;
%+A       seg:=DICREF(segid); EdSymb(sysedit,segid);
%+A       case 0:3 (seg.type)
%+A       when aDGRP: Prt("  SEGMENT  WORD  PUBLIC  'DATA'");
%+A       when aDATA: Prt("  SEGMENT  WORD  PUBLIC  'FAR_DATA'");
%+A       when aCODE: Prt("  SEGMENT  BYTE  PUBLIC  'FAR_CODE'");
%+A       when aLINE: Prt("  SEGMENT  WORD  PUBLIC  'LIN_CODE'");
%+A       endcase;
%+A end;

%+A Routine PrtENDS; import infix(WORD) segid;
%+A begin EdSymb(sysedit,segid); Prt("  ENDS") end;

end;
