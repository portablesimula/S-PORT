Module
%-E    CNV("iAPX-286");
%+E    CNV("iAPX-386");
begin insert UCOMN,UBASE;
       -----------------------------------------------------------------
       ---  COPYRIGHT 1989 by                                        ---
       ---  Simula a.s., Oslo, Norway                                ---
       ---                                                           ---
       ---          I N T E L   R E L O C A T A B L E   T O          ---
       ---          A T & T   C O F F   C O N V E R S I O N          ---
       ---                                                           ---
       ---  Selection Switches:                                      ---
       ---                                                           ---
       ---     C - Includes Consistency Tests                        ---
       ---     D - Includes tracing dumps                            ---
       -----------------------------------------------------------------

Define MxpNam=2;      -- I.e. max   512 Local Names    (per OBJ-MODULE)
Define MxpSeg=2;      -- I.e. max   512 Local Segments (per OBJ-MODULE)
Define MxpLgr=1;      -- I.e. max   256 Local Groups   (per OBJ-MODULE)
Define MxpExt=4;      -- I.e. max  1024 Local EXTERNs  (per OBJ-MODULE)
Define MxpPub=64;     -- I.e. max 16384 Local PUBLICs  (per OBJ-MODULE)

Macro AllignDiff(1); begin (bAND(4-(%1),3)) endmacro;
Define MXXPUB=4000;         -- Max number of PUBLICs
Define MXXNAM=100;          -- Max no.of Names    (per OBJ-MODULE)
Define MXXSEG=50;           -- Max no.of Segments (per OBJ-MODULE)
Define MXXGRP=4;            -- Max no.of Groups   (per OBJ-MODULE)
Define MXXEXT=200;          -- Max no.of EXTERNs  (per OBJ-MODULE)

Define BufLng=1024;         --- Max body size of :OBJ file records

Define cSTACK=0,cDATA=1,cCODE=2,cLINE=3;
Define iNOP=144,iINT=205,iJMP=233,iJMPF=234,iCALL=232,iCALLF=154;
Define fPOINTER=3,fBASE=2,fOFFSET=1,fHIBYTE=4,fLOBYTE=0;
Define sSEC=0,sPUB=1,sEXT=2;

Define rTHEADR=128; -- 80H -- Relocatable Module Header
Define rCOMENT=136; -- 88H -- Comment Record
Define rMODEND=138; -- 8AH -- 16 bit Module end record
Define r386END=139; -- 8BH -- 32 bit Module end record
Define rEXTDEF=140; -- 8CH -- External Reference
Define rPUBDEF=144; -- 90H -- 16 bit Public Definition
Define rPUB386=145; -- 91H -- 32 bit Public Definition
Define rLINNUM=148; -- 94H -- 16 bit Source Line Number
Define rLIN386=149; -- 95H -- 32 bit Source Line Number
Define rLNAMES=150; -- 96H -- Name List Record
Define rSEGDEF=152; -- 98H -- 16 bit Segment Definition
Define rSEG386=153; -- 99H -- 32 bit Segment Definition
Define rGRPDEF=154; -- 9AH -- Group Definition
Define rFIXUPP=156; -- 9CH -- Fixup previous 16 bit data image
Define rFIX386=157; -- 9DH -- Fixup previous 32 bit data image
Define rLEDATA=160; -- A0H -- 16 bit Enumerated Data Image
Define rLED386=161; -- A1H -- 32 bit Enumerated Data Image
Define rLIDATA=162; -- A2H -- 16 bit Iterated Data Image
Define rLID386=163; -- A3H -- 32 bit Iterated Data Image
Define rMAX=170;

%title ***   B A S I C    R E C O R D S   ***

Define SegAddr=0,GrpAddr=1,ExtAddr=2,NoAddr=3;
Define MaxAddr=3;

Record MemAddr; info "TYPE";
begin Dword Offset;   -- Offset part
      Byte  Kind;     -- Variant kind code
      variant Word Segx; -- SegAddr: CurMod.Seg(Segx)+Offset
      variant Word Grpx; -- GrpAddr: CurMod.Grp(Grpx)+Offset
      variant Word Extx; -- ExtAddr: CurMod.Ext(Extx)+Offset
end;

Record BlkDescr; info "TYPE";
begin ref(SEGMENT) Seg;
      integer Offset;    -- Offset in Seg.Sectn.RawData
      integer Lng;
end;

%title ******    G L O B A L    D A T A    ******
    Word InFileName;    -- INTEL-Rel Input file name
    Word UtFileName;    -- AT&T COFF Output file name
    Infix(ObjCodeBuffer) CBUF;  -- Object Code Input Buffer

    --------------- CURRENT INTEL MODULE DATA ---------------
    Infix(MemAddr) StartAddr; -- Module's StartAddress or NoAddr
    Ref(WrdVector) NamTab;    -- INTEL's Name Table
    Ref(RefVector) SegTab;    -- INTEL's Segment Table
    Ref(RefVector) GrpTab;    -- INTEL's Group Table
    Ref(ExtVector) ExtTab;    -- INTEL's External Table
    Ref(RefVector) PubTab;    -- INTEL's Public Table

-- ??? Word nNam; Ref(WrdBlock) NamTab(MxpNam); -- All Locally Defined Names
-- ??? Word nSeg; Ref(RefBlock) SegTab(MxpSeg); -- All Locally Defined Segments
-- ??? Word nLgr; Ref(RefBlock) LgrTab(MxpLgr); -- All Locally Defined Groups
-- ??? Word nExt; Ref(WrdBlock) ExtTab(MxpExt); -- All Locally Defined Externals
-- ??? Word nPub; Ref(WrdBlock) PubTab(MxpPub); -- All Locally Defined Publics

    --------------- CURRENT MODULE SCAN UTILITIES ---------------
    Infix(BlkDescr) CurBlk;         -- Current Code Buffer during LOADER
    Integer BytPos;                 -- Input byte number
    Integer RecPos;                 -- First byte of current record
    Unsigned RecLng;                -- Length of current record
%+D Byte ChkSum;                    -- Check-sum of current record
    Byte RecTyp;                    -- Current Record Type
    Infix(MemAddr) ImpTarget(4);    -- Implicit Target Table
    Infix(MemAddr) ImpFrame(4);     -- Implicit Frame  Table

    --------------- COFF OUTPUT DATA ---------------

    Infix(DATABUF) DBUF; -- Data Buffer
    infix(CoffFileHeader) Fhdr;      -- COFF File Header
    Define MaxSectn=3;
    Ref(SECTION) CoffSectn(MaxSectn); -- COFF Sections
    Ref(CoffSectionHeader) Shdr(MaxSectn); -- Section Headers
    Integer RawDataPos; -- File pointer to RawData (I.e. pAddr=0)
    Dword StrLng; -- Length of String Table
    Ref(StringTabEntry) FstStr,LstStr; -- String Table

    ------------------- SWITCHES -------------------
%+D Integer LN1POS;                 -- Trace Start-Byte Pos in File
%+D Unsigned LN1CNT;                -- Trace Byte Count
%+D Unsigned LN1TRC;                -- Trace Switces:
    Boolean Verbose;                -- True:  -v option given
    Boolean NameConv;               -- False: -n option given

    --------------- BASIC FILE HANDLING ---------------
    Unsigned Inpt;                  -- .obj  Input File Handle
    Unsigned Oupt;                  -- .o    Output File Handle
%title ***  COFF   F I L E   F O R M A T  ***

Record Ident8; info "TYPE";
begin variant character Char(8);  -- Zero padded Symbol Name
      variant integer Zero;       -- =0 to indicate this variant
              integer Index;      -- String index
end;

Record CoffFileHeader;
begin range(0:MaxWord) Magic;  -- Magic number
      range(0:MaxWord) nSectn; -- Number of Sections
      integer TimDat;          -- Time and Date stamp
      integer SymPtr;          -- File pointer to Symbol Table
      integer nSmb;            -- Number of entries in Symbol Table
      range(0:MaxWord) OptHdr; -- Number of byte in Optional Header
      range(0:MaxWord) Flags;  -- Flags
end;

Record CoffSectionHeader;
begin infix(Ident8) Ident;     -- Zero padded Section Name
      integer pAddr;           -- Physical address of Section
      integer vAddr;           -- Virtual address of Section
      integer Lng;             -- Section size in bytes
      integer ScnPtr;          -- File pointer to raw Data
      integer RelPtr;          -- File pointer to Relocation entries
      integer LnoPtr;          -- File pointer to Line Number entries
      range(0:MaxWord) nReloc; -- Number of Relocation entries
      range(0:MaxWord) nLno;   -- Number of Line Number entries
      integer Flags            -- Flags
end;

--- Relocation Entries ---

Define R_ABS=0;       -- Relocation type: No Relocation
Define R_DIR32=6;     -- Relocation type: Segment relative 32-bit Relocation
Define R_PCRLONG=20;  -- Relocation type: Self-relative 32-bit Relocation

Record CoffRelocPkt;
begin integer vAddr;
      integer SymNdx;
      range(0:MaxWord) Type;  -- Relocation Type
end;

Record RelocObj;
begin ref(RelocObj) next;
      integer sType;
      infix(CoffRelocPkt) Cpkt;
end;

--- Symbol Table Entries ---

Record CoffSymbolEntry;
begin infix(Ident8) Ident;    -- Zero padded Symbol Name or String index
      integer val;            -- Symbol value -- Storage Class Dependent
      range(0:MaxWord) Sectn; -- Section number of Symbol
      range(0:MaxWord) Type;  -- Type specification
      Byte Scls;  -- Storage Class of Symbol
      Byte nAux;  -- Number of auxiliary entries
end;

Record CoffAuxSymbolEntry;
begin
   variant ---- FileName ----
      character fnam(14);      -- Zero padded File Name
      range(0:MaxWord) dum0;   -- Not Used (:=0)
      range(0:MaxWord) dum1;   -- Not Used (:=0)
   variant ---- Section ----
      integer Lng;             -- Section size in bytes
      range(0:MaxWord) nReloc; -- Number of Relocation entries
      range(0:MaxWord) nLno;   -- Number of Line Number entries
      integer dum2;            -- Not Used (:=0)
      integer dum3;            -- Not Used (:=0)
      range(0:MaxWord) dum4;   -- Not Used (:=0)
   variant ---- Block and Function ----
      integer dum5;            -- Not Used (:=0)
      range(0:MaxWord) Lno;    -- Source Line Number
      range(0:MaxWord) dum6;   -- Not Used (:=0)
      integer dum7;            -- Not Used (:=0)
      integer EndNdx;          -- Index of next entry past this block
      range(0:MaxWord) dum8;   -- Not Used (:=0)
end;

Record StringTabEntry;
begin Word smbx;
      ref(StringTabEntry) next;
end;
%title ***   D y n a m i c   O b j e c t s    ***
Record Bytobj;
begin Byte byt(0) end;

Record ObjCodeBuffer;
begin Unsigned nxt; -- Next available Byte position
      variant character chr(BufLng);
      variant Byte byt(BufLng);
end;

Record ExtVector:Vector;    begin infix(EXTERN)    Elt(0)        end;

Record GROUP;
begin Word Ident;    -- Group's Identification
      Unsigned nSeg; -- No.of Segments in Group
      Word Segx(0);  -- Segments in Group
end;

Record SEGMENT;
begin Word Ident;   -- Segment Identification
      Word Class;   -- Segment Combine Class
      Byte cType;   -- Combine Type, 0:STACK,1:DATA,2:CODE,3:LINE
      Byte Align;   -- 1:Byte, 2:Word, 3:Para, 4:Page
      Integer          Length;  -- No.of bytes in segment
      Integer          Filled;  -- No.of bytes filled in segment
      Ref(SECTION)     Sectn;   -- Segment maped into section
      Integer          Offset;  --   and starting at 'Offset'
      Integer          pAddr;   -- =Offset+Shdr(Sectn.Index).pAddr
end;

Record SECTION;
begin Word Ident;   -- Section Identification
      Integer Index;   -- Section Index
-- ???      integer          Length;  -- No.of bytes in Section
      Ref(RelocObj) FstRel,LstRel;
      Ref(Bytobj) RawData;
end;

Record DATABUF;
begin range(0:MaxWord) nxt;   -- Next available byte pos in byt(0:..)
      character byt(1032);    -- 1032 = 1024+8
end;

Record EXTERN; info "TYPE";
begin Word Ident;
end;

Record PUBLIC;
begin Word Ident;
      Ref(SEGMENT) Seg;
      Integer Offset;
end;

%title ***  U T I L I T I E S  ***
Routine String2Id8;
import infix(String) s; export infix(Ident8) id8;
begin if s.nchr>8 then ERROR("COFF:LongString2Id8"); s.nchr:=8 endif;
      APX_SMOVEI(s.nchr,@id8.Char,s.chradr);
      if s.nchr >= 8 then goto E1 endif;
      APX_SFILL(0 qua character,8-s.nchr,@id8.Char(s.nchr));
E1:end;

Routine Symb2Id8;
import Word i; export infix(Ident8) id8;
begin ref(StringTabEntry) x; infix(String) s; s:=DICREF(i);
      if s.nchr > 8
      then id8.Zero:=0; id8.Index:=StrLng.val+4;
           StrLng.val:=StrLng.val+s.nchr+1;
           x:=NEWOBJ(size(StringTabEntry));
           if LstStr=none then FstStr:=LstStr:=x
           else LstStr.next:=x; LstStr:=x endif;
           x.next:=none; x.smbx:=i;
      else APX_SMOVEI(s.nchr,@id8.Char,s.chradr);
           if s.nchr >= 8 then goto E1 endif;
           APX_SFILL(0 qua character,8-s.nchr,@id8.Char(s.nchr));
      endif;
E1:end;

Routine MODERR; import infix(string) msg;
begin ERROR(msg);
      Ed(EdtBuf,"    At Byte "); EdInt(EdtBuf,BytPos);
      Ed(EdtBuf," in "); EdRecType(EdtBuf,RecTyp);
      Ed(EdtBuf,"(At Byte "); EdInt(EdtBuf,RecPos);
      Ed(EdtBuf,") in Module ");
      EdSymb(EdtBuf,InFileName); OutImage;
end;

%title ***   O b j e c t    G e n e r a t i o n   ***

Routine NewBytobj; import integer n; export ref(Bytobj) val;
begin val:=NEWOBJ(Size(Bytobj:n)) end;

Routine NewExtVector;
import range(0:MaxWord) MaxElt; export ref(ExtVector) x;
begin x:=NEWOBJ(Size(ExtVector:MaxElt)); x.MaxElt:=Maxelt; x.nElt:=0 end;

Routine NewSECTION;
import infix(String) Ident; integer Index,Flags; export ref(SECTION) Sectn;
begin Sectn:=NEWOBJ(Size(SECTION));
      Sectn.Ident:=DICDEF(Ident); Sectn.Index:=Index;
      Sectn.FstRel:=none; Sectn.LstRel:=none; Sectn.RawData:=none;
      ----  Initiate Section Header ---
      Shdr(Index):=NEWOBJ(size(CoffSectionHeader));
      Shdr(Index).Ident:=String2Id8(Ident); -- Zero padded Name
      Shdr(Index).pAddr:=0;       -- Physical address of Section
      Shdr(Index).pAddr:=0;       -- Virtual address of Section
      Shdr(Index).Lng:=0;         -- Section size in bytes
      Shdr(Index).ScnPtr:=0;      -- File pointer to raw Data
      Shdr(Index).RelPtr:=0;      -- File pointer to Relocation entries
      Shdr(Index).LnoPtr:=0;      -- File pointer to Line Number entries
      Shdr(Index).nReloc:=0;      -- Number of Relocation entries
      Shdr(Index).nLno:=0;        -- Number of Line Number entries
      Shdr(Index).Flags:=Flags;   -- Flags STYP_TEXT/DATA/BSS
end;
%title ***   P r i n t / E d i t   O b j e c t   ***
Routine ShowGrp; import ref(GROUP) Grp;
begin ref(SEGMENT) Seg; Unsigned i;
      Ed(EdtBuf,"GROUP   "); EdSymb(EdtBuf,Grp.Ident);
      i:=0; repeat while i < Grp.nSeg
      do Seg:=SegTab.Elt(Grp.Segx(i).val-1); i:=i+1;
         EdChar(EdtBuf,' '); EdSymb(EdtBuf,Seg.Ident);
      endrepeat;
      OutImage;
end;

Routine ShowSeg; import ref(SEGMENT) Seg;
begin if Seg.Length <> 0
      then Ed(EdtBuf,"SEGMENT "); EdSymb(EdtBuf,Seg.Ident);
           EdChar(EdtBuf,'('); EdInt(EdtBuf,Seg.Length);
           if Seg.Sectn <> none
           then case 0:MaxSectn (Seg.Sectn.Index)
                when 0: Ed(EdtBuf,")  ==>  .text(")
                when 1: Ed(EdtBuf,")  ==>  .data(")
                when 2: Ed(EdtBuf,")  ==>  .bss(")
                otherwise Ed(EdtBuf,"  ==>  .???(")  endcase;
                EdInt(EdtBuf,Seg.Offset); EdChar(EdtBuf,':');
                EdInt(EdtBuf,Seg.Offset+Seg.Length-1);
           endif;
           EdChar(EdtBuf,')'); OutImage;
      endif;
end;

%+D Routine ShowBlk; import infix(BlkDescr) Blk;
%+D begin integer Ofst; ref(Bytobj) RawData;
%+D       Ofst:=CurBlk.Seg.Offset+Blk.Offset;
%+D       RawData:=Blk.Seg.Sectn.RawData;
%+D       HexDump(0,Blk.Lng,name(RawData.byt(Ofst)));
%+D end;

%+D Routine DumpFhdr;
%+D begin Trc("   * * *    C O F F : F I L E   H E A D E R   * * *");
%+D       Ed(TrcBuf,"Magic number             ");
%+D       EdHex(TrcBuf,Fhdr.Magic,4); OutTrace;
%+D       Ed(TrcBuf,"Number of Sections       ");
%+D       EdInt(TrcBuf,Fhdr.nSectn); OutTrace;
%+D       Ed(TrcBuf,"Time and Date stamp      ");
%+D       EdHex(TrcBuf,Fhdr.TimDat,8); OutTrace;
%+D       Ed(TrcBuf,"Pointer to Symbol Table  ");
%+D       EdInt(TrcBuf,Fhdr.SymPtr); OutTrace;
%+D       Ed(TrcBuf,"Number of Symbols        ");
%+D       EdInt(TrcBuf,Fhdr.nSmb); OutTrace;
%+D       Ed(TrcBuf,"Size of Optional Header  ");
%+D       EdInt(TrcBuf,Fhdr.OptHdr); OutTrace;
%+D       Ed(TrcBuf,"Flags                    ");
%+D       EdHex(TrcBuf,Fhdr.Flags,8); OutTrace;
%+D end;

%+D Routine DumpSectn; import ref(SECTION) Sectn;
%+D begin integer x; x:=Sectn.Index;
%+D       BegTrace("   * * *    C O F F : S E C T I O N ( ");
%+D       EdInt(TrcBuf,Sectn.Index); Ed(TrcBuf," )   * * *"); OutTrace;
%+D       Ed(TrcBuf," Section Name                ");
-- ??? %+D       EdIdent8(TrcBuf,Shdr(x).Ident); OutTrace;
%+D       EdSymb(TrcBuf,Sectn.Ident); OutTrace;
%+D       Ed(TrcBuf," Physical address of Section ");
%+D       EdInt(TrcBuf,Shdr(x).pAddr); OutTrace;
%+D       Ed(TrcBuf," Virtual address of Section  ");
%+D       EdInt(TrcBuf,Shdr(x).vAddr); OutTrace;
%+D       Ed(TrcBuf," Section size in bytes       ");
%+D       EdInt(TrcBuf,Shdr(x).Lng); OutTrace;
%+D       Ed(TrcBuf," Pointer to raw Data         ");
%+D       EdInt(TrcBuf,Shdr(x).ScnPtr); OutTrace;
%+D       Ed(TrcBuf," Pointer to Relocations      ");
%+D       EdInt(TrcBuf,Shdr(x).RelPtr); OutTrace;
%+D       Ed(TrcBuf," Pointer to Line Numbers     ");
%+D       EdInt(TrcBuf,Shdr(x).LnoPtr); OutTrace;
%+D       Ed(TrcBuf," Number of Relocations       ");
%+D       EdInt(TrcBuf,Shdr(x).nReloc); OutTrace;
%+D       Ed(TrcBuf," Number of Line Numbers      ");
%+D       EdInt(TrcBuf,Shdr(x).nLno); OutTrace;
%+D       Ed(TrcBuf," Flags                       ");
%+D       EdInt(TrcBuf,Shdr(x).Flags); OutTrace;
%+D end;

%+D Routine DumpReloc; import ref(RelocObj) RelObj;
%+D begin infix(AnyType) x; x.AsOaddr:=RelObj.next
%+D       Ed(TrcBuf,"Relocation at "); EdInt(TrcBuf,RelObj.Cpkt.vAddr);
%+D       Ed(TrcBuf," rType:"); EdInt(TrcBuf,RelObj.Cpkt.Type);
%+D       Ed(TrcBuf," sType:"); EdInt(TrcBuf,RelObj.sType);
%+D       Ed(TrcBuf," Smbx:"); EdInt(TrcBuf,RelObj.Cpkt.SymNdx);
%+D       Ed(TrcBuf," Next:"); EdHex(TrcBuf,x.AsInt,8);
%+D       OutTrace;
%+D end;
%title ***   E D I T I N G   ***

Routine EdAddr; import ref(EdBuff) F; infix(MemAddr) adr;
begin ref(SEGMENT) Seg; integer Ofst; Ofst:=adr.Offset.val;
      case 0:MaxAddr (adr.Kind)
      when SegAddr: Seg:=SegTab.Elt(adr.Segx.val-1);
                    if Seg.Offset <> 0
                    then EdSymb(F,Seg.Ident);
                         if Ofst <> 0 then EdChar(F,'+'); EdInt(F,Ofst) endif;
                         EdChar(F,'='); Ofst:=Ofst+Seg.Offset;
                    endif;
                    EdSymb(F,Seg.Sectn.Ident);
      when GrpAddr: EdSymb(F,GrpTab.Elt(adr.Grpx.val-1) qua GROUP.Ident);
      when ExtAddr: EdSymb(F,ExtTab.Elt(adr.Extx.val-1).Ident);
      when NoAddr:  Ed(F,"NoAddr"); goto E1;
      endcase;
      if Ofst <> 0 then EdChar(F,'+'); EdInt(F,Ofst) endif;
E1:end;

Routine EdRecType; import ref(EdBuff) F; Byte t;
begin if    t=110 then Ed(F,"RHEADR") elsif t=112 then Ed(F,"REGINT")
      elsif t=114 then Ed(F,"REDATA") elsif t=116 then Ed(F,"RIDATA")
      elsif t=118 then Ed(F,"OVLDEF") elsif t=120 then Ed(F,"ENDREC")
      elsif t=122 then Ed(F,"BLKDEF") elsif t=124 then Ed(F,"BLKEND")
      elsif t=126 then Ed(F,"DEBSYM") elsif t=128 then Ed(F,"THEADR")
      elsif t=130 then Ed(F,"LHEADR") elsif t=132 then Ed(F,"PEDATA")
      elsif t=134 then Ed(F,"PIDATA") elsif t=136 then Ed(F,"COMENT")
      elsif t=138 then Ed(F,"MODEND") elsif t=140 then Ed(F,"EXTDEF")
      elsif t=139 then Ed(F,"386END")
      elsif t=142 then Ed(F,"TYPDEF") elsif t=144 then Ed(F,"PUBDEF")
                                      elsif t=145 then Ed(F,"PUB386")
      elsif t=146 then Ed(F,"LOCSYM") elsif t=148 then Ed(F,"LINNUM")
                                      elsif t=149 then Ed(F,"LIN386")
      elsif t=150 then Ed(F,"LNAMES") elsif t=152 then Ed(F,"SEGDEF")
                                      elsif t=153 then Ed(F,"SEG386")
      elsif t=154 then Ed(F,"GRPDEF") elsif t=156 then Ed(F,"FIXUPP")
                                      elsif t=157 then Ed(F,"FIX386")
                                      elsif t=160 then Ed(F,"LEDATA")
                                      elsif t=161 then Ed(F,"LED386")
      elsif t=162 then Ed(F,"LIDATA") elsif t=164 then Ed(F,"LIBHED")
      elsif t=163 then Ed(F,"LID386")
      elsif t=166 then Ed(F,"LIBNAM") elsif t=168 then Ed(F,"LIBLOC")
      elsif t=170 then Ed(F,"LIBDIC") else Ed(F,"??????") endif;
end;
%title *********    O u t p u t    R o u t i n e s    *********

Macro CoffSpace(1);
begin if DBUF.nxt >= (1025-(%1)) then OutCOFFBLK endif; endmacro;

Routine BegCOFFBLK; begin DBUF.nxt:=0 end;

Routine OutCOFFBLK; -- COFF: Write COFF-Buffer to UtFile ---
begin integer n; n:=XNX_WRITE(DBUF.nxt,Name2Ref(@DBUF.byt(0)),Oupt);
      if OsStat <> 0 then ERROR("OutCOFFBLK-1"); OsStat:=0
      elsif n <> DBUF.nxt then ERROR("OutCOFFBLK-2") endif;
      DBUF.nxt:=0;
end;

Macro PutByte(1);
begin DBUF.byt(DBUF.nxt):=%1 qua character;
      DBUF.nxt:=DBUF.nxt+1;
endmacro;

Macro PutDWord(1);
begin DBUF.byt(DBUF.nxt):=%1 .LO   qua character; DBUF.nxt:=DBUF.nxt+1;
      DBUF.byt(DBUF.nxt):=%1 .LOHI qua character; DBUF.nxt:=DBUF.nxt+1;
      DBUF.byt(DBUF.nxt):=%1 .HILO qua character; DBUF.nxt:=DBUF.nxt+1;
      DBUF.byt(DBUF.nxt):=%1 .HI   qua character; DBUF.nxt:=DBUF.nxt+1;
endmacro;

Routine PutChars;
import Unsigned nchr; name(character) chradr;
begin Unsigned n; n:=0;
      repeat while n < nchr
      do PutByte(%var(chradr)(n) qua integer%); n:=n+1 endrepeat;
end;

%+D Routine ChkFilPos; import integer h,pos; infix(String) msg;
%+D begin integer lng; lng:=XNX_LSEEK(2,0,h);
%+D       if OsStat <> 0 then ERROR("ChkFilPos-Status"); OsStat:=0 endif;
%+D       if lng <> pos
%+D       then Ed(ErrMsg,msg); Ed(ErrMsg," FilPos:"); EdInt(ErrMsg,lng);
%+D            Ed(ErrMsg," ExpectedPos:"); EdInt(ErrMsg,pos);
%+D            ERROR(" -- Wrong FileSize");
%+D       endif;
%+D end;

%title ***  B A S I C    O B J - C O D E    I N P U T  ***

Routine InitObjCode;
begin CBUF.nxt:=BufLng; InCbuffer end;

Routine InCbuffer;
begin infix(String) bf; Unsigned n,k; n:=BufLng-CBUF.nxt;
      if n>0 then APX_SMOVEI(n,@CBUF.chr,@CBUF.chr(CBUF.nxt)) endif;
      READ(Inpt,BufLng-n,%@CBUF.chr(n)%,k);
      if OsStat <> 0 then MODERR("InCbuffer") endif;
      if k < (BufLng-n) then CBUF.byt(n+k):=0 endif;
      CBUF.nxt:=0;
end;

Macro InByte(1);
begin if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
%+D   ChkSum:=ChkSum+CBUF.byt(CBUF.nxt); --- ChkSum:=(ChkSum+ ..) rem 256;
      %1:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
      RecLng:=RecLng-1; BytPos:=BytPos+1;
endmacro;

Macro SkipByte:
      if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
%+D   ChkSum:=ChkSum+CBUF.byt(CBUF.nxt); --- ChkSum:=(ChkSum+ ..) rem 256;
      CBUF.nxt:=CBUF.nxt+1;
      RecLng:=RecLng-1; BytPos:=BytPos+1;
endmacro;

Routine SkipBytes; import Unsigned n;
begin Integer Loc; Byte b;
%+D   if TrcSw > 3
%+D   then if n > 1
%+D        then OutTrace; Ed(TrcBuf,"*** "); EdWrd(TrcBuf,n-1);
%+D             Ed(TrcBuf," Bytes Skiped"); OutTrace;
%+D        endif;
%+D        repeat n:=n-1 while n > 0
%+D        do if TrcBuf.Pos > 63 then OutTrace endif;
%+D           EdChar(TrcBuf,' '); InByte(%b%); EdHex(TrcBuf,b,2);
%+D        endrepeat;
%+D        InByte(%b%);
%+D   else --- Locate Next Record ---
           CBUF.nxt:=CBUF.nxt+n;
           if CBUF.nxt > BufLng
           then LOCATE(Inpt,1,CBUF.nxt-BufLng,Loc); CBUF.nxt:=BufLng
                if OsStat <> 0 then MODERR("SkipBytes"); OsStat:=0 endif;
           endif;
           if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
%+D        ChkSum:=0; --- Bypass ChkSum Testing
%+D   endif;
end;

Routine ScanData; import Unsigned Lng; name(Character) BlkPos;
begin Unsigned Rst,k;

%+D   Unsigned DmpLng; name(Character) DmpPos; DmpLng:=Lng; DmpPos:=BlkPos;
      if Lng >= RecLng then MODERR("ScanData-1"); Lng:=RecLng-1 endif;
      RecLng:=RecLng-Lng; BytPos:=BytPos+Lng;
      repeat Rst:=BufLng-CBUF.nxt while Lng > 0
      do k:=if Rst < Lng then Rst else Lng;
         APX_SMOVEI(k,BlkPos,@CBUF.chr(CBUF.nxt)); Lng:=Lng-k;
         CBUF.nxt:=CBUF.nxt+k;
         BlkPos:=name(var(BlkPos)(k));
         if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
      endrepeat;
%+D   if TrcSw > 3 then HexDump(0,DmpLng,DmpPos) endif;
end;

Macro ScanByte(2);
begin
%-D  %1:=DoScanByte;
%+D  %1:=DoScanByte(%2);
endmacro;
Routine DoScanByte;
%+D import infix(string) id;
export Byte n;
begin InByte(%n%);
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdHex(TrcBuf,n,2);
%+D   endif;
end;

Macro ScanIndex(2);
begin
%-D  %1:=DoScanIndex;
%+D  %1:=DoScanIndex(%2);
endmacro;
Routine DoScanIndex;
%+D import infix(string) id;
export Word w;
begin InByte(%w.val%);
      if w.val>127 then w.HI:=w.LO-128; InByte(%w.LO%) endif;
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdWrd(TrcBuf,w.val);
%+D   endif;
end;

Macro ScanName(2);
begin
%-D  %1:=DoScanName;
%+D  %1:=DoScanName(%2);
endmacro;
Routine DoScanName;
%+D import infix(string) id;
export Word res;
begin Byte lng,n,c; InByte(%lng%); if lng=0 then res.val:=0; goto E endif;
      n:=lng; repeat while n>0
      do InByte(%c%);
         if NameConv
         then if    c qua character='_' then if n=lng then goto R endif
-- ????       elsif c qua character='@' then c:='.' qua integer
              endif;
         endif;
         EdChar(EdtBuf,c qua character);
      R: n:=n-1;
      endrepeat;
      res:=DICDEF(PickUp(EdtBuf));
E:
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdSymb(TrcBuf,res);
%+D   endif
end;

Macro ScanWord(2);
begin
%-D  %1:=DoScanWord;
%+D  %1:=DoScanWord(%2);
endmacro;
Routine DoScanWord;
%+D import infix(string) id;
export Word w;
begin InByte(%w.LO%); InByte(%w.HI%);
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdWrd(TrcBuf,w.val);
%+D   endif;
end;

Macro ScanDword(2);
begin
%-D  %1:=DoScanDword;
%+D  %1:=DoScanDword(%2);
endmacro;
Routine DoScanDword;
%+D import infix(string) id;
export Dword w;
begin InByte(%w.LO%); InByte(%w.LOHI%);
      InByte(%w.HILO%); InByte(%w.HI%);
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdInt(TrcBuf,w.val);
%+D   endif;
end;

Routine ScanChk;
begin if RecLng > 0 then SkipBytes(RecLng) endif;
%+D   if ChkSum <> 0 then MODERR("Check-Sum Error") endif;
%+D   ChkSum:=0;
end;

Routine ScanHead;
begin Word w;
      RecPos:=BytPos; InByte(%w.LO%); InByte(%w.HI%); RecLng:=w.val;
%+D   if TrcSw > 2
%+D   then EdInt(TrcBuf,RecPos); Ed(TrcBuf,": ");
%+D        EdRecType(TrcBuf,RecTyp);
%+D        EdChar(TrcBuf,'='); EdHex(TrcBuf,RecTyp,2);
%+D        Ed(TrcBuf,"H Lng:"); EdInt(TrcBuf,RecLng);
%+D   endif;
end;

%title ***    L o g i c a l    A d d r e s s    ***

Routine ScanLogicalAddr; import Boolean Ofst32; export infix(MemAddr) Adr;
begin Byte n,TARGT,FRAM,P,T,F; Word UnUsed;
      infix(MemAddr) FrmAdr; Boolean Fchk;
%+C   infix(MemAddr) a1,a2;
%+D   Byte OldTrcSw; OldTrcSw:=TrcSw;
      Fchk:=false;
      if RecLng<2 then MODERR("LogicalAddr-1"); goto E1 endif;
      InByte(%n%);              TARGT:=bAND(n,3);
      P:=bAND(bSHR(n,2),1);     T:=bAND(bSHR(n,3),1);
      FRAM:=bAND(bSHR(n,4),7);  F:=bAND(bSHR(n,7),1);
%+D   if TrcSw > 4
%+D   then OutTrace; SetPos(TrcBuf,10);
%+D        Ed(TrcBuf,"<F:");      EdInt(TrcBuf,F);
%+D        Ed(TrcBuf," FRAME:");  EdInt(TrcBuf,FRAM);
%+D        Ed(TrcBuf," T:");      EdInt(TrcBuf,T);
%+D        Ed(TrcBuf," P:");      EdInt(TrcBuf,P);
%+D        Ed(TrcBuf," TARGT:");  EdInt(TrcBuf,TARGT);
%+D   else TrcSw:=0 endif;
      if F=1 then FrmAdr:=ImpFrame(FRAM); Fchk:=true;
      elsif FRAM < 4
      then FrmAdr.kind:=FRAM; Fchk:=true; FrmAdr.Offset.val:=0;
           if RecLng<2 then MODERR("LogicalAddr-2"); goto E2 endif;
           case 0:3 (FRAM)
           when SegAddr: ScanIndex(FrmAdr.Segx,"Segx")
           when GrpAddr: ScanIndex(FrmAdr.Grpx,"Grpx")
           when ExtAddr: ScanIndex(FrmAdr.Extx,"Extx")
           otherwise MODERR("Address with FrameNumber -- Not supported");
                     ScanWord(UnUsed,"FrameNumber");
           endcase;
      endif;
      if T=1 then Adr:=ImpTarget(TARGT);
      else Adr.kind:=TARGT;
           if RecLng<2 then MODERR("LogicalAddr-2"); goto E3 endif;
           case 0:3 (TARGT)
           when SegAddr: ScanIndex(Adr.Segx,"Segx")
           when GrpAddr: ScanIndex(Adr.Grpx,"Grpx")
           when ExtAddr: ScanIndex(Adr.Extx,"Extx")
           otherwise MODERR("Address with FrameNumber -- Not supported");
                     ScanWord(UnUsed,"FrameNumber");
           endcase;
      endif;
      if P=1 then Adr.Offset.val:=0
      else if RecLng<3 then MODERR("LogicalAddr-4"); goto E4 endif;
           if Ofst32 then ScanDword(Adr.Offset,"Disp")
           else ScanWord(%Adr.Offset.AsWord(0)%,"Disp");
                Adr.Offset.AsWord(1).val:=0;
           endif;
      endif;
E1:E2:E3:E4:
%+D   if TrcSw>4 then EdChar(TrcBuf,'>'); OutTrace else TrcSw:=OldTrcSw endif;
end;

%title ***   T H E A D R / M O D E N D / L N A M E S / P U B D E F  ***
Routine THEADR; begin Word w; ScanName(w,"ModuleName") end; 

Routine MODEND; import Boolean Ofst32;
begin Byte n,Mattr,L; Word UnUsed;
      InByte(%n%); -- FORMAT: <Mattr>2<-->5<L>1
      Mattr:=bAND(bSHR(n,6),3); L:=bAND(n,1); StartAddr.Kind:=NoAddr;
      if (Mattr=1) or (Mattr=3)
      then --- Start Address ---;
           if L=1 then StartAddr:=ScanLogicalAddr(Ofst32)
           else if RecLng<5 then ERROR("MODEND"); goto E endif;
                ScanWord(UnUsed,"FrameNumber"); ScanWord(UnUsed,"Offset");
           endif;
      endif;
E:
%+D   if TrcSw > 2
%+D   then Ed(TrcBuf," ModuleType:"); EdInt(TrcBuf,Mattr);
%+D        Ed(TrcBuf," L:"); EdInt(TrcBuf,L);
%+D        if StartAddr.Kind <> NoAddr
%+D        then OutTrace; SetPos(TrcBuf,18);
%+D             Ed(TrcBuf,"Start Address: "); EdAddr(TrcBuf,StartAddr);
%+D        endif;
%+D   endif;
end;

Routine LNAMES;
begin Word nam;
%+D   Byte p; p:=TrcBuf.Pos;
      repeat while RecLng > 1
      do
%+D      if TrcBuf.Pos>50 then OutTrace; SetPos(TrcBuf,p) endif;
         ScanName(nam,"Name");
         NamTab.Elt(NamTab.nElt):=nam;
         if NamTab.nElt >= MXXNAM then MODERR("Too many LNAMES's in Module")
         else NamTab.nElt:=NamTab.nElt+1 endif;
      endrepeat;
end;

Routine PUBDEF; import Boolean Ofst32;
begin Word Grpx,Segx,Ident,UnUsed; Dword Ofst;
      ref(SEGMENT) Seg; ref(PUBLIC) Pub;
%+D   Byte p; p:=TrcBuf.Pos;
      ScanIndex(Grpx,"Grpx"); ScanIndex(Segx,"Segx");
      if Segx.val=0
      then ScanWord(UnUsed,"FrameNumber");
           MODERR("PUBDEF with FrameNumber - Not Supported"); goto E;
      endif;
      Seg:=SegTab.Elt(Segx.val-1);
      repeat while RecLng > 2
      do
%+D      if TrcBuf.Pos > 40 then OutTrace; SetPos(TrcBuf,p) endif;
         ScanName(Ident,"Name");
         if Ofst32 then ScanDword(Ofst,"Offset")
         else ScanWord(%Ofst.AsWord(0)%,"Offset");
              Ofst.AsWord(1).val:=0;
         endif;
         ScanIndex(UnUsed,"Type");
         if PubTab.nElt >= MXXPUB then MODERR("Public-Table Overflow")
         else Pub:=NEWOBJ(Size(PUBLIC)); Pub.Ident:=Ident;
              PubTab.Elt(PubTab.nElt):=Pub; Pub.Seg:=Seg;
              Pub.Offset:=Ofst.val;
              PubTab.nElt:=PubTab.nElt+1;
         endif;
      endrepeat;
E:end;
%title ***  L I D A T A  ***
Routine ScanBlock; import Boolean Ofst32; integer Rep,Ofst;
begin Dword RepCnt; Word nBlk; Unsigned n,p,i; infix(BlkDescr) Blk;
      name(Character) BlkPos;
%+D   Byte b;
%+D   if TrcSw > 2 then OutTrace; SetPos(TrcBuf,18) endif;
      if Ofst32 then ScanDword(RepCnt,"RepCount")
      else ScanWord(%RepCnt.AsWord(0)%,"RepCount");
           RepCnt.AsWord(1).val:=0;
      endif;
      Rep:=Rep*RepCnt.val; ScanWord(nBlk,"BlkCount");
      if nBlk.val = 0
      then if RecLng < 2 then MODERR("ScanBlock-1"); goto E endif;
           InByte(%n%);
           Blk.Seg:=CurBlk.Seg; Blk.Lng:=n; Blk.Offset:=Ofst+CurBlk.Seg.Offset;
           BlkPos:=@Blk.Seg.Sectn.RawData.byt(Blk.Offset);
           ScanData(n,BlkPos);
%+D        repeat while n>0
%+D        do n:=n-1; b:=Blk.Seg.Sectn.RawData.byt(Blk.Offset+n);
%+D           ChkSum:=ChkSum+b
%+D        endrepeat;
%+D        if TrcSw > 3 then ShowBlk(Blk) endif;
           n:=p:=Blk.Lng;
           repeat Rep:=Rep-1 while Rep > 0
           do i:=0; repeat while i < n
              do Blk.Seg.Sectn.RawData.byt(Blk.Offset+p);
                 := Blk.Seg.Sectn.RawData.byt(Blk.Offset+i);
                 p:=p+1; i:=i+1;
              endrepeat;
              if p > 1023 then WARNING("LIDATA: Large Text Block") endif;
           endrepeat;
           Blk.Lng:=p;
%+D        if TrcSw > 3 then ShowBlk(Blk) endif;
           if Blk.Lng+Blk.Offset > CurBlk.Seg.Length
           then MODERR("Text Larger than Segment") endif;
      else repeat while nBlk.val > 0
           do ScanBlock(Ofst32,Rep,Ofst); nBlk.val:=nBlk.val-1 endrepeat;
      endif;
E:end;

Routine LIDATA; import Boolean Ofst32;
begin Word Segx; Dword Ofst;
      ScanIndex(Segx,"Segx");
      if Ofst32 then ScanDword(Ofst,"Offset")
      else ScanWord(%Ofst.AsWord(0)%,"Offset");
           Ofst.AsWord(1).val:=0;
      endif;
      CurBlk.Seg:=SegTab.Elt(Segx.val-1);
      repeat while RecLng > 2 do ScanBlock(Ofst32,1,Ofst.val) endrepeat;
end;
%title ***  L E D A T A  ***

Routine LEDATA; import Boolean Ofst32;
begin Word Segx; Dword SegOfst; integer n,SectnOfst; name(Character) BlkPos;
%+D   Byte b,p; p:=TrcBuf.Pos;
      ScanIndex(Segx,"Segx");
      if Ofst32 then ScanDword(SegOfst,"Offset")
      else ScanWord(%SegOfst.AsWord(0)%,"Offset");
           SegOfst.AsWord(1).val:=0;
      endif;
%+D   if TrcSw > 2 then OutTrace; SetPos(TrcBuf,p) endif;
      CurBlk.Seg:=SegTab.Elt(Segx.val-1);
      CurBlk.Lng:=RecLng-1;
      CurBlk.Offset:=SegOfst.val; SectnOfst:=SegOfst.val+CurBlk.Seg.Offset;
      if CurBlk.Lng+SegOfst.val > CurBlk.Seg.Length
      then MODERR("Text Larger than Segment") endif;
      BlkPos:=@CurBlk.Seg.Sectn.RawData.byt(SectnOfst);
      ScanData(CurBlk.Lng,BlkPos);
%+D   n:=CurBlk.Lng; repeat while n>0
%+D   do n:=n-1;
%+D      b:=CurBlk.Seg.Sectn.RawData.byt(SectnOfst+n);
%+D      ChkSum:=ChkSum+b
%+D   endrepeat;
%+D   if TrcSw > 3 then ShowBlk(CurBlk) endif;
end;
%title ***   F I X U P P  ***
Routine FIXUPP; import Boolean Ofst32;
begin Byte n,M,S,D,Z,Thx,Fld; infix(MemAddr) adr; Word UnUsed,Pos;
%+D   Byte OldTrc;
%+D   OldTrc:=TrcSw; if TrcSw < 4 then TrcSw:=0 endif;
      repeat while RecLng > 1
      do inbyte(%n%);
         if n < 128
         then adr.Offset.val:=0;                         --- THREAD ---;
              -- FORMAT: n=<+0>1<D>1<Z>1<METHOD>3<THRED>2
              Thx:=bAND(n,3);
              adr.Kind:=bAND(bSHR(n,2),7);
              Z:=bAND(bSHR(n,5),1);
              D:=bAND(bSHR(n,6),1);
%+D           if TrcSw > 3
%+D           then OutTrace; SetPos(TrcBuf,10);
%+D                Ed(TrcBuf,"THREAD D:");  EdInt(TrcBuf,D);
%+D                Ed(TrcBuf," Z:");        EdInt(TrcBuf,Z);
%+D                Ed(TrcBuf," METHOD:");   EdInt(TrcBuf,adr.Kind);
%+D                Ed(TrcBuf," THRED:");    EdInt(TrcBuf,Thx);
%+D           endif;
              if D*adr.Kind < 4
              then if RecLng < 2 then MODERR("THREAD-1"); goto E1 endif;
                   case 0:3 (adr.Kind)
                   when SegAddr: ScanIndex(adr.Segx,"Segx")
                   when GrpAddr: ScanIndex(adr.Grpx,"Grpx")
                   when ExtAddr: ScanIndex(adr.Extx,"Extx")
                   otherwise MODERR("FIXUP with FrameNumber -- Not supported");
                             ScanWord(UnUsed,"FrameNumber");
                   endcase;
              endif;
              if D=1 then ImpFrame(Thx):=adr
                     else ImpTarget(Thx):=adr endif;
         else                                            --- FIXUPP ---;
              if RecLng<2 then MODERR("FIXUPP"); goto E2 endif;
              -- FORMAT: n=<+1>1<M>1<S>1<LOC>3<OFFSET-HI>2 <OFFSET-LO>8
              Pos.HI:=bAND(n,3); InByte(%Pos.LO%);
              Fld:=bAND(bSHR(n,2),7);
              S:=bAND(bSHR(n,5),1);
              M:=bAND(bSHR(n,6),1);
%+D           if TrcSw > 4
%+D           then OutTrace; SetPos(TrcBuf,6);
%+D                Ed(TrcBuf,"FIXUPP M:");  EdInt(TrcBuf,M);
%+D                Ed(TrcBuf," S:");        EdInt(TrcBuf,S);
%+D                Ed(TrcBuf," Fld:");      EdInt(TrcBuf,Fld);
%+D                Ed(TrcBuf," OFFSET:");   EdInt(TrcBuf,Pos.val);
%+D                OutTrace;
%+D           endif;
              adr:=ScanLogicalAddr(Ofst32);
%+D           if TrcSw > 3
%+D           then OutTrace; SetPos(TrcBuf,10);
%+D                if    Fld=fLOBYTE  then Ed(TrcBuf,"LowByte(")
%+D                elsif Fld=fOFFSET  then Ed(TrcBuf,"Offset(")
%+D                elsif Fld=fBASE    then Ed(TrcBuf,"Base(")
%+D                elsif Fld=fPOINTER then Ed(TrcBuf,"Pointer(")
%+D                elsif Fld=fHIBYTE  then Ed(TrcBuf,"HighByte(")
%+D                else  Ed(TrcBuf,"????(") endif;
%+D                if CurBlk.Seg.Offset <> 0
%+D                then EdSymb(TrcBuf,CurBlk.Seg.Ident); EdChar(TrcBuf,'+');
%+D                     EdInt(TrcBuf,CurBlk.Offset+Pos.val); EdChar(TrcBuf,'=');
%+D                endif;
%+D                EdSymb(TrcBuf,CurBlk.Seg.Sectn.Ident); EdChar(TrcBuf,'+');
%+D                EdInt(TrcBuf,CurBlk.Seg.Offset+CurBlk.Offset+Pos.val);
%+D                if M=0 then Ed(TrcBuf,")  <= Self")
%+D                       else Ed(TrcBuf,")  <= Segm") endif;
%+D                Ed(TrcBuf,"Rel <=  "); EdAddr(TrcBuf,adr);
%+D           endif;
              if Fld <> fOFFSET
              then MODERR("Illegal Relocation Field")
              elsif M=0 then SelfReloc(Pos.val,adr)
              else           SegmReloc(Pos.val,adr)    endif;
         endif;
      endrepeat;
E1:E2:
%+D   TrcSw:=OldTrc;
%+D   if TrcSw > 4 then ShowBlk(CurBlk) endif;
end;


Routine SelfReloc;
import range(0:1023) Pos; infix(MemAddr) adr;
begin ref(AnyType) x; Byte instr;
      ref(SEGMENT) rSeg; integer aPos;
      aPos:=CurBlk.Seg.Offset+CurBlk.Offset+Pos;
      x:=Name2Ref(name(CurBlk.Seg.Sectn.RawData.byt(aPos)));
%+C   instr:=CurBlk.Seg.Sectn.RawData.byt(aPos-1);
%+C   if instr=iJMP then elsif instr=iCALL then -- OK
%+C   else EdHex(ErrMsg,instr,2);
%+C        MODERR("Illegal Self-Relocation -- Instr: ");
%+C   endif;
%+D   if TrcSw > 4
%+D   then OutTrace; SetPos(TrcBuf,10); Ed(TrcBuf,"SelfReloc-Ofst: ");
%+D        EdInt(TrcBuf,x.AsInt); OutTrace;
%+D   endif;
      x.AsInt:=(x.AsInt+adr.Offset.val) - (aPos+AllignFac);
      case 0:MaxAddr (adr.Kind)
      when SegAddr: rSeg:=SegTab.Elt(adr.Segx.val-1);
                    if CurBlk.Seg.Sectn <> rSeg.Sectn
                    then MODERR("Self-Relocation Outside Section") endif;
                    x.AsInt:=x.AsInt+rSeg.pAddr-CurBlk.Seg.pAddr;
      when GrpAddr: MODERR("SelfReloc-1")
      when ExtAddr: NewReloc(aPos,sExt,adr.Extx.val-1,R_PCRLONG)
      otherwise   MODERR("SelfReloc-2")  endcase;
%+D   if TrcSw > 4
%+D   then OutTrace; SetPos(TrcBuf,10); Ed(TrcBuf,"SelfReloc-Disp: ");
%+D        EdInt(TrcBuf,x.AsInt); OutTrace;
%+D   endif;
end;
%page

Routine SegmReloc;
import range(0:1023) Pos; infix(MemAddr) adr;
begin ref(AnyType) x; ref(SEGMENT) rSeg; integer aPos;
      aPos:=CurBlk.Seg.Offset+CurBlk.Offset+Pos;
      x:=Name2Ref(name(CurBlk.Seg.Sectn.RawData.byt(aPos)));
      x.AsInt:=x.AsInt+adr.Offset.val;
%+D   if TrcSw > 4
%+D   then BegTrace("          SegmReloc-Offset: ");
%+D        EdInt(TrcBuf,x.AsWord); OutTrace;
%+D   endif;
      case 0:MaxAddr (adr.Kind)
      when SegAddr: rSeg:=SegTab.Elt(adr.Segx.val-1);
                    if rSeg.Align=0
                    then --- ABSOLUTE SEGMENT -- DO NOT RELOCATE !!!
%+D                      if TrcSw > 4
%+D                      then BegTrace("SKIPPED"); OutTrace endif;
                    else x.AsInt:=x.AsInt+rSeg.pAddr;
                         NewReloc(aPos,sSec,2*rSeg.Sectn.Index,R_DIR32)
                    endif;
      when GrpAddr: MODERR("SegmReloc-1")
      when ExtAddr: NewReloc(aPos,sExt,adr.Extx.val-1,R_DIR32)
      otherwise  MODERR("SegmReloc-2")  endcase;
end;

Routine NewReloc; import integer Ofst,sType,Smbx; range(0:MaxWord) Type;
begin ref(SECTION) Sectn; ref(RelocObj) x;
      Sectn:=CurBlk.Seg.Sectn; x:=NEWOBJ(size(RelocObj)); x.next:=none;
      if Sectn.LstRel=none then Sectn.FstRel:=Sectn.LstRel:=x
      else Sectn.LstRel.next:=x; Sectn.LstRel:=x endif;
      Shdr(Sectn.Index).nReloc:=Shdr(Sectn.Index).nReloc+1;
      x.Cpkt.vAddr:=Ofst+Shdr(Sectn.Index).pAddr;
      x.Cpkt.SymNdx:=Smbx; x.Cpkt.Type:=Type; x.sType:=sType;
end;

%title ***   C O M E N T / L I N N U M / E X T D E F   ***

Routine COMENT;
begin Unsigned n,NP,NL,CLS;
      InByte(%n%); -- FORMAT: <NP>1<NL>1<-->6 <CLS>8
      NL:=bAND(bSHR(n,6),1);
      NP:=bAND(bSHR(n,7),1);
      InByte(%CLS%);
%+D   if TrcSw > 2
%+D   then Ed(TrcBuf," NP:"); EdInt(TrcBuf,NP);
%+D        Ed(TrcBuf," NL:"); EdInt(TrcBuf,NL);
%+D        Ed(TrcBuf," CLASS:"); EdInt(TrcBuf,CLS);
%+D   endif;
end;

Routine LINNUM;
begin

      -- ...   MERE SENERE ... ;
      -- ...   MERE SENERE ... ;

end;


Routine EXTDEF;
begin Word Ident,UnUsed;
%+D   Byte p; p:=TrcBuf.Pos;
      repeat while RecLng > 2
      do
%+D      if TrcBuf.Pos>40 then OutTrace; SetPos(TrcBuf,p) endif;
         ScanName(Ident,"Name"); ScanIndex(UnUsed,"Type");
         if ExtTab.nElt >= MXXEXT
         then MODERR("Too many EXTDEF's in Module")
         else ExtTab.Elt(ExtTab.nElt).Ident:=Ident;
              ExtTab.nElt:=ExtTab.nElt+1;
         endif;
      endrepeat;
end;
%title ***   G R P D E F   ***

Routine GRPDEF;
begin Word Ident,x,Grpx; Byte n;
      range(0:MaxWord) nGrp,nSeg; Word Segx(20); ref(GROUP) Grp;
%+D   Byte p; p:=TrcBuf.Pos;
      nGrp:=GrpTab.nElt; nSeg:=0;
      ScanIndex(Grpx,"GrpNamx");
      Ident:=NamTab.Elt(Grpx.val-1);
      repeat while RecLng > 2
      do
%+D      if TrcBuf.Pos>40 then OutTrace; SetPos(TrcBuf,p) endif;
         if nSeg >= 20
         then MODERR("Too many Segments in GROUP"); nSeg:=nSeg-1 endif;
         InByte(%n%); ScanIndex(x,"Segx");
         Segx(nSeg):=x; nSeg:=nSeg+1;
      endrepeat;
      if nSeg = 0 then MODERR("Empty GROUP in Module")
      elsif nGrp >= MXXGRP then MODERR("Too many GROUP's in Module")
      else Grp:=NEWOBJ(size(GROUP:nSeg));
           Grp.Ident:=Ident; Grp.nSeg:=nSeg;
           repeat while nSeg > 0
           do nSeg:=nSeg-1; Grp.Segx(nSeg):=Segx(nSeg) endrepeat;
           GrpTab.Elt(nGrp):=Grp; GrpTab.nElt:=nGrp+1;
%+D        if TrcSw > 4 then ShowGrp(Grp) endif;
      endif;
end;

%title ***   S E G D E F  ***

Routine SEGDEF; import Boolean Ofst32;
begin ref(SEGMENT) Seg; infix(String) s;
      Byte n,A,C,B,PP,LTL;
      range(0:MaxWord) nSeg;
      Dword SegLng;
      Word FrameNumber,Offset,MaxLng;
      Word SegNamx,ClassNamx,OvlNamx;
%+D   Byte p; p:=TrcBuf.Pos;
      InByte(%n%); -- FORMAT: <A>3<C>3<B>1<P>1
      PP:=bAND(n,1);          B:=bAND(bSHR(n,1),1);
      C:=bAND(bSHR(n,2),7);   A:=bAND(bSHR(n,5),7);
%+D   if TrcSw > 2
%+D   then Ed(TrcBuf," A:"); EdInt(TrcBuf,A);
%+D        Ed(TrcBuf," C:"); EdInt(TrcBuf,C);
%+D        Ed(TrcBuf," B:"); EdInt(TrcBuf,B);
%+D        Ed(TrcBuf," P:"); EdInt(TrcBuf,PP);
%+D        OutTrace; SetPos(TrcBuf,p);
%+D   endif;
      if (A=0) -- ?????    or (A=5)   MEANS 32-bit
      then ScanWord(FrameNumber,"FrameNumber");
           ScanByte(n,"Offset");
      elsif A=6
      then ScanByte(LTL,"LTL");
           ScanWord(MaxLng,"MaxSegLength");
           ScanWord(Offset,"GroupOffset");
      endif;
      if Ofst32 then ScanDword(SegLng,"SegLength")
      else ScanWord(%SegLng.AsWord(0)%,"SegLength");
           SegLng.AsWord(1).val:=0;
      endif;
      if RecLng>1
      then ScanIndex(SegNamx,"SegNamx");
           if RecLng>1 then ScanIndex(ClassNamx,"ClassNamx") endif;
           if RecLng>1 then ScanIndex(OvlNamx,"OvlNamx") endif;
      endif;
      nSeg:=SegTab.nElt;
      if nSeg >= MXXSEG then MODERR("Too many SEGDEF's in Module")
      else Seg:=NEWOBJ(Size(SEGMENT)); Seg.Ident:=NamTab.Elt(SegNamx.val-1);
           Seg.Align:=A; Seg.Length:=SegLng.val; Seg.Filled:=0;
           Seg.Class:=NamTab.Elt(ClassNamx.val-1);
           if Seg.Class=DICDEF("STACK") then Seg.cType:=cSTACK
           else EdSymb(EdtBuf,Seg.Class); s:=PickUp(EdtBuf);
                if s.nchr < 4 then Seg.cType:=cDATA
                else s.chradr:=name(var(s.chradr)(s.nchr-4)); s.nchr:=4;
                     if SEQ(s,"CODE")
                     then EdSymb(EdtBuf,Seg.Ident); s:=PickUp(EdtBuf);
                          if s.nchr < 4 then Seg.cType:=cCODE
                          else s.chradr:=name(var(s.chradr)(s.nchr-4));
                               s.nchr:=4;
                               Seg.cType:=if SEQ(s,"LINE")
                                          then cLINE else cCODE;
                          endif;
                     else Seg.cType:=cDATA endif;
                endif;
           endif;
           SegTab.Elt(nSeg):=Seg; SegTab.nElt:=nSeg+1;
      endif;
end;

%title ***    M  O  D  U  L  E     H  E  A  D    ***

Routine ModuleHead;
begin
%+D   if TrcSw > 0
%+D   then Ed(TrcBuf,"OBJECT HEAD SCANNER: ");
%+D        EdSymb(TrcBuf,InFileName); OutTrace;
%+D   endif;

      BytPos:=0;            -- Input byte number
      RecPos:=0;            -- Input byte number
      RecLng:=0;            -- Length of current record
%+D   ChkSum:=0;            -- Check-sum of current record
      RecTyp:=0;            -- Current Record Code
      InitObjCode;
NESTE:
%+D   if TrcSw > 2 then OutTrace endif;
      InByte(%RecTyp%);
%+D   if LN1POS <> 0
%+D   then if BytPos >= LN1POS
%+D        then if LN1TRC=0
%+D             then TrcSw:=0; LN1POS:=0
%+D                  Ed(TrcBuf,"MODULE TRACE TERMINATED"); OutTrace;
%+D             else TrcSw:=LN1TRC; 
%+D                  LN1TRC:=0; LN1POS:=LN1POS+LN1CNT;
%+D             endif;
%+D        endif;
%+D   endif;
      ScanHead;
      if    RecTyp=rTHEADR then THEADR
      elsif RecTyp=rCOMENT then COMENT
      elsif RecTyp=rMODEND then goto T1 -- MODEND treated by ModuleTail
      elsif RecTyp=r386END then goto T2 -- MODEND treated by ModuleTail
      elsif RecTyp=rEXTDEF then EXTDEF
      elsif RecTyp=rPUBDEF then goto T3 -- PUBDEF treated by ModuleTail
      elsif RecTyp=rPUB386 then goto T4 -- PUB386 treated by ModuleTail
      elsif RecTyp=rLINNUM then goto B1 -- LINNUM treated by ModuleBody
      elsif RecTyp=rLNAMES then LNAMES
      elsif RecTyp=rSEGDEF then SEGDEF(false)
      elsif RecTyp=rSEG386 then SEGDEF(true)
      elsif RecTyp=rGRPDEF then GRPDEF
      elsif RecTyp=rFIXUPP then goto B2 -- FIXUPP treated by ModuleBody
      elsif RecTyp=rFIX386 then goto B3 -- FIX386 treated by ModuleBody
      elsif RecTyp=rLEDATA then goto B4 -- LEDATA treated by ModuleBody
      elsif RecTyp=rLED386 then goto B5 -- LED386 treated by ModuleBody
      elsif RecTyp=rLIDATA then goto B6 -- LIDATA treated by ModuleBody
      elsif RecTyp=rLID386 then goto B7 -- LID386 treated by ModuleBody
      else  EdInt(ErrMsg,RecPos); Ed(ErrMsg,": ");
            EdRecType(ErrMsg,RecTyp);
            EdChar(ErrMsg,'='); EdHex(ErrMsg,RecTyp,2);
            Ed(ErrMsg,"H Lng:"); EdInt(ErrMsg,RecLng);
            MODERR(" -- Unknown record type"); 
            TERMIN(3,"Converter Terminated in Part 1");
      endif;

      ScanChk; goto NESTE;

T1:T2:T3:T4:B1:B2:B3:B4:B5:B6:B7:

end;
%title ***    M  O  D  U  L  E     B  O  D  Y    ***
Routine ModuleBody;
begin Unsigned i,x; infix(string) F;
      ref(SEGMENT) Seg; ref(FRAME) Frm; infix(EXTERN) dext;
%+D   if TrcSw > 0
%+D   then OutTrace; Ed(TrcBuf,"SWITCHING TO OBJECT BODY SCANNER: ");
%+D        EdSymb(TrcBuf,InFileName); OutTrace; OutTrace;
%+D   endif;

      CoffInit; goto START; NESTE:
%+D   if TrcSw > 2 then OutTrace endif;
      InByte(%RecTyp%);
%+D   if LN1POS <> 0
%+D   then if BytPos >= LN1POS
%+D        then if LN1TRC=0
%+D             then TrcSw:=0; LN1POS:=0
%+D                  Ed(TrcBuf,"MODULE TRACE TERMINATED"); OutTrace;
%+D             else TrcSw:=LN1TRC; 
%+D                  LN1TRC:=0; LN1POS:=LN1POS+LN1CNT;
%+D             endif;
%+D        endif;
%+D   endif;
      ScanHead;
START:
      if    RecTyp=rTHEADR then -- THEADR  treated by ModuleHead
      elsif RecTyp=rCOMENT then COMENT
      elsif RecTyp=rMODEND then goto T1 -- MODEND  treated by ModuleTail
      elsif RecTyp=r386END then goto T2 -- 386END  treated by ModuleTail
      elsif RecTyp=rEXTDEF then -- EXTDEF  treated by ModuleHead
      elsif RecTyp=rPUBDEF then goto T3 -- PUBDEF  treated by ModuleTail
      elsif RecTyp=rPUB386 then goto T4 -- PUB386  treated by ModuleTail
      elsif RecTyp=rLINNUM then LINNUM
      elsif RecTyp=rLNAMES then -- LNAMES  treated by ModuleHead
      elsif RecTyp=rSEGDEF then -- SEGDEF  treated by ModuleHead
      elsif RecTyp=rGRPDEF then -- GRPDEF  treated by ModuleHead
      elsif RecTyp=rFIXUPP then FIXUPP(false)
      elsif RecTyp=rFIX386 then FIXUPP(true)
      elsif RecTyp=rLEDATA then LEDATA(false)
      elsif RecTyp=rLED386 then LEDATA(true)
      elsif RecTyp=rLIDATA then LIDATA(false)
      elsif RecTyp=rLID386 then LIDATA(true)
      else  EdInt(ErrMsg,RecPos); Ed(ErrMsg,": ");
            EdRecType(ErrMsg,RecTyp);
            EdChar(ErrMsg,'='); EdHex(ErrMsg,RecTyp,2);
            Ed(ErrMsg,"H Lng:"); EdInt(ErrMsg,RecLng);
            MODERR(" -- Unknown record type"); 
            TERMIN(3,"Linker Terminated in Part 2");
      endif;

      ScanChk; goto NESTE;

T1:T2:T3:T4:
end;
%title ***    M  O  D  U  L  E    T  A  I  L    ***

Routine ModuleTail;
begin
%+D   if TrcSw > 0
%+D   then OutTrace; Ed(TrcBuf,"SWITCHING TO OBJECT TAIL SCANNER: ");
%+D        EdSymb(TrcBuf,InFileName); OutTrace;
%+D   endif;
      goto START;
NESTE:
%+D   if TrcSw > 2 then OutTrace endif;
      InByte(%RecTyp%);
%+D   if LN1POS <> 0
%+D   then if BytPos >= LN1POS
%+D        then if LN1TRC=0
%+D             then TrcSw:=0; LN1POS:=0
%+D                  Ed(TrcBuf,"MODULE TRACE TERMINATED"); OutTrace;
%+D             else TrcSw:=LN1TRC; 
%+D                  LN1TRC:=0; LN1POS:=LN1POS+LN1CNT;
%+D             endif;
%+D        endif;
%+D   endif;
      ScanHead;
START:
      if    RecTyp=rTHEADR then -- THEADR treated by ModuleHead
      elsif RecTyp=rCOMENT then COMENT
      elsif RecTyp=rMODEND then MODEND(false); goto FIN1;
      elsif RecTyp=r386END then MODEND(true);  goto FIN2;
      elsif RecTyp=rEXTDEF then -- EXTDEF treated by ModuleHead
      elsif RecTyp=rPUBDEF then PUBDEF(false)
      elsif RecTyp=rPUB386 then PUBDEF(true)
      elsif RecTyp=rLINNUM then -- LINNUM treated by ModuleBody
      elsif RecTyp=rLNAMES then -- LNAMES treated by ModuleHead
      elsif RecTyp=rSEGDEF then -- SEGDEF treated by ModuleHead
      elsif RecTyp=rGRPDEF then -- GRPDEF treated by ModuleHead
      elsif RecTyp=rFIXUPP then -- FIXUPP treated by ModuleBody
      elsif RecTyp=rFIX386 then -- FIX386 treated by ModuleBody
      elsif RecTyp=rLEDATA then -- LEDATA treated by ModuleBody
      elsif RecTyp=rLED386 then -- LED386 treated by ModuleBody
      elsif RecTyp=rLIDATA then -- LIDATA treated by ModuleBody
      elsif RecTyp=rLID386 then -- LID386 treated by ModuleBody
      else  EdInt(ErrMsg,RecPos); Ed(ErrMsg,": ");
            EdRecType(ErrMsg,RecTyp);
            EdChar(ErrMsg,'='); EdHex(ErrMsg,RecTyp,2);
            Ed(ErrMsg,"H Lng:"); EdInt(ErrMsg,RecLng);
            MODERR(" -- Unknown record type"); 
            TERMIN(3,"Converter Terminated in Part 3");
      endif;

      ScanChk; goto NESTE;

FIN1:FIN2:
      Oupt:=Open(UtFileName,".o",accwrite);
      if Oupt <> 0 then CoffTerm endif;
end;
%title ***  U N I X - C O F F    I N I T I A T E  ***
Routine CoffInit;
begin ref(SEGMENT) Seg; integer Segx,secx,grpx;
      ----  Initiate File Header  ---
      Fhdr.Magic:=332;  -- Magic number (AT&T-COFF 386)
      Fhdr.nSectn:=3;   -- Number of Sections
      Fhdr.TimDat:=0;   -- Time and Date stamp
      Fhdr.SymPtr:=0;   -- File pointer to Symbol Table
      Fhdr.nSmb:=0;     -- Number of entries in Symbol Table
      Fhdr.OptHdr:=0;   -- Number of byte in Optional Header
      Fhdr.Flags:=260;  -- Flags
      ----  Initiate Section Headers ---
      CoffSectn(0):=NewSECTION(".text",0,32); -- Flags STYP_TEXT
      CoffSectn(1):=NewSECTION(".data",1,64); -- Flags STYP_DATA
      CoffSectn(2):=NewSECTION(".bss",2,128); -- Flags STYP_BSS
      ----  Map Segments  ==>  Sections  ----
      Segx:=0; repeat while Segx < SegTab.nElt
      do Seg:=SegTab.Elt(Segx); Segx:=Segx+1;
         case 0:3 (Seg.cType)
         when cLINE,cDATA: Seg.Sectn:=CoffSectn(1)
         when cCODE: Seg.Sectn:=CoffSectn(0)
         otherwise  ERROR("MapSeg-1")  endcase;
         Shdr(Seg.Sectn.Index).Lng:=
                               Shdr(Seg.Sectn.Index).Lng+Seg.Length;
      endrepeat;
      Shdr(0).Lng:=Shdr(0).Lng+AllignDiff(%Shdr(0).Lng%);
      Shdr(1).Lng:=Shdr(1).Lng+AllignDiff(%Shdr(1).Lng%);
      Shdr(2).Lng:=Shdr(2).Lng+AllignDiff(%Shdr(2).Lng%);
      Shdr(0).ScnPtr:=RawDataPos:=(Fhdr.nSectn*40)+20;
      Shdr(1).ScnPtr:=Shdr(0).ScnPtr+Shdr(0).Lng;
      Shdr(0).vAddr:=Shdr(0).pAddr:=0;
      Shdr(1).vAddr:=Shdr(1).pAddr:=Shdr(0).pAddr+Shdr(0).Lng;
      Shdr(2).vAddr:=Shdr(2).pAddr:=Shdr(1).pAddr+Shdr(1).Lng;

      Segx:=0; repeat while Segx < SegTab.nElt
      do Seg:=SegTab.Elt(Segx); Segx:=Segx+1;
         Seg.Offset:=Shdr(Seg.Sectn.Index).pAddr-Shdr(Seg.Sectn.Index).vAddr;
         Seg.pAddr:=Seg.Offset+Shdr(Seg.Sectn.Index).vAddr;
         Shdr(Seg.Sectn.Index).pAddr:=Shdr(Seg.Sectn.Index).pAddr+Seg.Length;
      endrepeat
      ----  Final Initiate Sections ---
      secx:=0; repeat while secx < MaxSectn
      do Shdr(secx).pAddr:=Shdr(secx).vAddr;
         if Shdr(secx).Lng=0 then Shdr(secx).ScnPtr:=0
         else CoffSectn(secx).RawData:=NewBytobj(Shdr(secx).Lng) endif;
         secx:=secx+1;
      endrepeat;
%+D   if TrcSw <> 0
%+D   then grpx:=0; repeat while grpx < GrpTab.nElt
%+D        do ShowGrp(GrpTab.Elt(grpx)); grpx:=grpx+1 endrepeat;
%+D        Segx:=0; repeat while Segx < SegTab.nElt
%+D        do ShowSeg(SegTab.Elt(Segx)); Segx:=Segx+1 endrepeat;
%+D        DumpFhdr;                 DumpSectn(CoffSectn(0));
%+D        DumpSectn(CoffSectn(1));  DumpSectn(CoffSectn(2));
%+D   endif;
end;
%title ***  U N I X - C O F F    T E R M I N A T E  ***

Routine CoffTerm;
begin integer secx,i,n,Lng,SecDisp,PubDisp,ExtDisp,TxtLng,RelLng,RelPtr;
      Word smbx;
      infix(string) filid,s;
      infix(CoffSymbolEntry) Csmb;
      infix(CoffAuxSymbolEntry) Caux;
      ref(RelocObj) RelObj;
      ref(Bytobj) RawData;
      ref(PUBLIC) pub;
%+D   integer nSmb,nRel;

      SecDisp:=2;                   PubDisp:=SecDisp+(2*Fhdr.nSectn);
      ExtDisp:=PubDisp+PubTab.nElt; Fhdr.nSmb:=ExtDisp+ExtTab.nElt;
      Fhdr.SymPtr:=20+(40*Fhdr.nSectn); RelPtr:=20+(40*Fhdr.nSectn);
      ----  Add size of RawData and Relocations for each Section  ----
      i:=0; repeat while i < Fhdr.nSectn
      do TxtLng:=Shdr(i).Lng; RelLng:=10*Shdr(i).nReloc; i:=i+1;
         Fhdr.SymPtr:=Fhdr.SymPtr+TxtLng+RelLng; RelPtr:=RelPtr+TxtLng;
      endrepeat;
      ----  Set Relocation-pointer for each Section  ----
      i:=0; repeat while i < Fhdr.nSectn
      do RelLng:=10*Shdr(i).nReloc;
         if RelLng<>0 then Shdr(i).RelPtr:=RelPtr; RelPtr:=RelPtr+RelLng endif;
         i:=i+1;
      endrepeat;
%+D   if TrcSw <> 0
%+D   then i:=0; repeat while i < GrpTab.nElt
%+D        do ShowGrp(GrpTab.Elt(i)); i:=i+1 endrepeat;
%+D        i:=0; repeat while i < SegTab.nElt
%+D        do ShowSeg(SegTab.Elt(i)); i:=i+1 endrepeat;
%+D        DumpFhdr;                 DumpSectn(CoffSectn(0));
%+D        DumpSectn(CoffSectn(1));  DumpSectn(CoffSectn(2));
%+D   endif;
      if Verbose
      then i:=0; repeat while i < SegTab.nElt
           do ShowSeg(SegTab.Elt(i)); i:=i+1 endrepeat;
      endif;
    
%+D   Trc("----  Output File and Section Headers  ----");
      n:=XNX_WRITE(20,Name2Ref(@Fhdr.Magic),Oupt);
      if OsStat <> 0 then ERROR("COFFUT-1"); OsStat:=0
      elsif n <> 20 then ERROR("COFFUT-2") endif;
      i:=0; repeat while i < Fhdr.nSectn
      do n:=XNX_WRITE(40,Name2Ref(@Shdr(i).Ident.Char),Oupt);
         if OsStat <> 0 then ERROR("COFFUT-3"); OsStat:=0
         elsif n <> 40 then ERROR("COFFUT-4") endif;
         i:=i+1;
      endrepeat;
    
%+D   Trc("----  Output Raw Data for each Section  ----");
      i:=0; repeat while i < Fhdr.nSectn
      do RawData:=CoffSectn(i).RawData; Lng:=Shdr(i).Lng
         if Lng <> 0
         then
%+D           ChkFilPos(Oupt,Shdr(i).ScnPtr,"RawDat");
              n:=XNX_WRITE(Lng,Name2Ref(@RawData.byt),Oupt);
              if OsStat <> 0 then ERROR("COFFUT-5"); OsStat:=0
              elsif n <> Lng then ERROR("COFFUT-6") endif;
         endif;
         i:=i+1;
      endrepeat;
   
%+D   Trc("---  Output Relocations for each Sectn  ---");
      BegCOFFBLK;
      n:=0; repeat while n < Fhdr.nSectn
      do
%+D      Trc("---  Output Relocations for Sectn(x)  ---");
         RelObj:=CoffSectn(n).FstRel
%+D      if RelObj <> none
%+D      then ChkFilPos(Oupt,Shdr(n).RelPtr-DBUF.nxt,"RelTab") endif;
%+D      nRel:=0;
         repeat while RelObj <> none
         do
%+D         if TrcSw <> 0 then DumpReloc(RelObj) endif;
%+D         if (RelObj.sType<0) or (RelObj.sType>2)
%+D         then Ed(ErrMsg,"Reloc-sType: "); EdInt(ErrMsg,RelObj.sType);
%+D              ERROR(" -- Wrong SymbolType"); RelObj.sType:=0;
%+D         endif;
            case 0:2 (RelObj.sType)
            when sSEC: RelObj.Cpkt.SymNdx:=RelObj.Cpkt.SymNdx+SecDisp
            when sEXT: RelObj.Cpkt.SymNdx:=RelObj.Cpkt.SymNdx+ExtDisp
            endcase;
            CoffSpace(%10%); PutChars(10,@RelObj.Cpkt.vAddr);
%+D         nRel:=nRel+1;
            RelObj:=RelObj.next;
         endrepeat;
%+D      if nRel <> Shdr(n).nReloc then ERROR("COFF:nReloc") endif;
         n:=n+1;
      endrepeat
      OutCOFFBLK;
   
%+D   Trc("---  Output Line Numbers for each Sectn  ---");
  
%+D   Trc("----  Output Symbol Table  ----");
%+D   ChkFilPos(Oupt,Fhdr.SymPtr,"SymTab");
%+D   nSmb:=0;
%+D   Trc("-- Output  .file <FileName>");
      Csmb.Ident:=String2Id8(".file"); Csmb.val:=0; Csmb.Sectn:=65534;
      Csmb.Type:=0; Csmb.Scls:=103; Csmb.nAux:=1;
      CoffSpace(%18%); PutChars(18,@Csmb.Ident.Char);
%+D   nSmb:=nSmb+1;
      EdSymb(EdtBuf,UtFileName); filid:=Pickup(EdtBuf);
      if filid.nchr > 14 then filid.nchr:=14 endif;
      APX_SMOVEI(filid.nchr,@Caux.Fnam,filid.chradr);
      APX_SFILL(0 qua character,18-filid.nchr,@Caux.Fnam(filid.nchr));
      Caux.dum0:=0; Caux.dum1:=0;
      CoffSpace(%18%); PutChars(18,@Caux.Fnam);
%+D   nSmb:=nSmb+1;

%+D   Trc("-- Output  .text <SectionSpec>");
%+D   if nSmb <> SecDisp then ERROR("COFF:SymbDisp-1") endif;
      Csmb.Ident:=String2Id8(".text"); Csmb.val:=Shdr(0).pAddr;
      Csmb.Sectn:=1; Csmb.Type:=0; Csmb.Scls:=3; Csmb.nAux:=1;
      CoffSpace(%18%); PutChars(18,@Csmb.Ident.Char);
%+D   nSmb:=nSmb+1;
      Caux.Lng:=Shdr(0).Lng; Caux.nReloc:=Shdr(0).nReloc;
      Caux.nLno:=Shdr(0).nLno; Caux.dum2:=0; Caux.dum3:=0; Caux.dum4:=0;
      CoffSpace(%18%); PutChars(18,@Caux.Fnam);
%+D   nSmb:=nSmb+1;

%+D   Trc("-- Output  .data <SectionSpec>");
      Csmb.Ident:=String2Id8(".data"); Csmb.val:=Shdr(1).pAddr;
      Csmb.Sectn:=2; Csmb.Type:=0; Csmb.Scls:=3; Csmb.nAux:=1;
      CoffSpace(%18%); PutChars(18,@Csmb.Ident.Char);
%+D   nSmb:=nSmb+1;
      Caux.Lng:=Shdr(1).Lng; Caux.nReloc:=Shdr(1).nReloc;
      Caux.nLno:=Shdr(1).nLno; Caux.dum2:=0; Caux.dum3:=0; Caux.dum4:=0;
      CoffSpace(%18%); PutChars(18,@Caux.Fnam);
%+D   nSmb:=nSmb+1;

%+D   Trc("-- Output  .bss <SectionSpec>");
      Csmb.Ident:=String2Id8(".bss"); Csmb.val:=Shdr(2).pAddr;
      Csmb.Sectn:=3; Csmb.Type:=0; Csmb.Scls:=3; Csmb.nAux:=1;
      CoffSpace(%18%); PutChars(18,@Csmb.Ident.Char);
%+D   nSmb:=nSmb+1;
      Caux.Lng:=Shdr(2).Lng; Caux.nReloc:=Shdr(2).nReloc;
      Caux.nLno:=Shdr(2).nLno; Caux.dum2:=0; Caux.dum3:=0; Caux.dum4:=0;
      CoffSpace(%18%); PutChars(18,@Caux.Fnam);
%+D   nSmb:=nSmb+1;
    
%+D   Trc("----  Output Public Definitions  ----");
%+D   if nSmb <> PubDisp then ERROR("COFF:SymbDisp-2") endif;
      n:=0; repeat while n < PubTab.nElt
      do pub:=PubTab.Elt(n); n:=n+1; secx:=pub.Seg.Sectn.Index;
         Csmb.Ident:=Symb2Id8(pub.Ident);
         Csmb.val:=pub.Offset+pub.Seg.Offset+Shdr(secx).pAddr;
         Csmb.Sectn:=secx+1; Csmb.Type:=0; Csmb.Scls:=2; Csmb.nAux:=0;
         CoffSpace(%18%); PutChars(18,@Csmb.Ident.Char);
%+D      nSmb:=nSmb+1;
      endrepeat;
   
%+D   Trc("----  Output External References  ----");
%+D   if nSmb <> ExtDisp then ERROR("COFF:SymbDisp-3") endif;
      n:=0; repeat while n < ExtTab.nElt
      do smbx:=ExtTab.Elt(n).Ident; n:=n+1;
         Csmb.Ident:=Symb2Id8(smbx); Csmb.val:=0; Csmb.Sectn:=0;
         Csmb.Type:=0; Csmb.Scls:=2; Csmb.nAux:=0;
         CoffSpace(%18%); PutChars(18,@Csmb.Ident.Char);
%+D      nSmb:=nSmb+1;
      endrepeat;
%+D   if nSmb <> Fhdr.nSmb then ERROR("COFF:SymbDisp-4") endif;
      OutCOFFBLK;

      if StrLng.val <> 0
      then
%+D        Trc("----  Output String Table  ----");
           CoffSpace(%4%);
           StrLng.val:=StrLng.val+4; PutDWord(%StrLng%);
           repeat while FstStr <> none
           do EdSymb(EdtBuf,FstStr.smbx); s:=Pickup(EdtBuf);
              FstStr:=FstStr.next; CoffSpace(%s.nchr+1%);
              PutChars(s.nchr,s.chradr); PutByte(%0%);
           endrepeat; 
           OutCOFFBLK;
      endif;
  
      Close(Oupt); Oupt:=0;
end;
%title ***   M  O  N  I  T  O  R   ***

Routine GetInt; import infix(String) itm; export integer val;
begin character c; integer i; i:=0; val:=0;
      repeat c:=if i<itm.nchr then var(itm.chradr)(i) else 'x'
      while c=' ' do i:=i+1 endrepeat;
      repeat c:=if i<itm.nchr then var(itm.chradr)(i) else 'x'
      while (c>='0') and (c<='9')
      do val:=(val*10)+(c qua integer -48); i:=i+1 endrepeat;
end;

Visible Routine MONITOR; import infix(String) verid;
begin Unsigned itm,SegNam,nPrd,i,n,PreDot; ref(SEGMENT) Seg;
      infix(String) s,par,val; Character c,opt;
      INITIATE; InFileName.val:=0; UtFileName.val:=0;
      Verbose:=false;
      NameConv:=true;
      EndFile:=false;       -- Set true whenever EOF on any file
      NamTab:=NewWrdVector(MXXNAM); GrpTab:=NewRefVector(MXXSEG);
      SegTab:=NewRefVector(MXXSEG); ExtTab:=NewExtVector(MXXEXT);
      PubTab:=NewRefVector(MXXPUB);  
      i:=0; repeat i:=i+1 while i < XNXREF.argc
      do par:=GetPar(i); 
-- ???   Ed(EdtBuf,"Parameter: "); Ed(EdtBuf,par); OutImage; 
         if (par.nchr > 1) and (var(par.chradr) = '-')
         then opt:=var(par.chradr)(1);   
-- ???        Ed(EdtBuf,"Option: "); EdChar(EdtBuf,opt); OutImage;
              if    opt='V' then Ed(EdtBuf,"SIMULA Utility Software, Version ")
                                 Ed(EdtBuf,verid); PrintOut(EdtBuf);
              elsif opt='v' then Verbose:=true
              elsif opt='n' then NameConv:=false
%+D           else if (par.nchr > 2)
%+D                then val.chradr:=name(var(par.chradr)(2));
%+D                     val.nchr:=par.nchr-2;
%+D                else i:=i+1; val:=GetPar(i) endif;
-- ???             Ed(EdtBuf,"  Value: "); Ed(EdtBuf,val); OutImage; 
%+D                if opt='t' then TrcSw:=GetInt(val)
%+D                elsif opt='d'
%+D                then LN1POS:=GetInt(val) i:=i+1; val:=GetPar(i);
%+D                     Ed(EdtBuf,"  Value: "); Ed(EdtBuf,val); OutImage; 
%+D                     LN1CNT:=GetInt(val) i:=i+1; val:=GetPar(i);
%+D                     Ed(EdtBuf,"  Value: "); Ed(EdtBuf,val); OutImage; 
%+D                     LN1TRC:=GetInt(val)
                   else Ed(EdtBuf,"cnv: Illegal option: -");
                        EdChar(EdtBuf,opt); Ed(EdtBuf,val); OutImage; 
%+D                endif;
              endif;
         elsif InFileName.val=0 then InFileName:=DICDEF(par)
         elsif UtFileName.val=0 then UtFileName:=DICDEF(par)
         else Ed(EdtBuf,"cnv: Illegal parameter: ");
              Ed(EdtBuf,par); OutImage;
         endif;
      endrepeat;

      if Verbose
      then Ed(EdtBuf,"INTEL RELOCATABLE to AT&T COFF Conversion"); OutImage;
           Ed(EdtBuf,"Copyright (C) Simula a.s. 1989."); OutImage;
      endif;

      if InFileName.val=0
      then Prt("cnv: Insufficient arguments");
           Prt("Usage: cnv {opt}.. file1 file2");
           Prt("       -V                   # Print Version Ident    ");
           Prt("       -v                   # Set Verbose Mode       ");
           Prt("       -n                   # Disable Name-Conversion");
%+D        Prt("       -t level             # Tracing Dumps");
%+D        Prt("       -d start count level # Tracing Dumps");
           goto T1;
      endif;
 
      if InFileName.val <> 0
      then Inpt:=Open(InFileName,".obj",accread); 
           if UtFileName.val=0
           then s:=DICREF(InFileName); PreDot:=0;
                i:=0; repeat while i < s.nchr
                do c:=var(s.chradr)(i); i:=i+1;
                   if (c='/') or (c='\') then PreDot:=0; PickUp(EdtBuf)
                   elsif c='.' then PreDot:=EdtBuf.pos
                   else EdChar(EdtBuf,c) endif;
                endrepeat;
                if PreDot <> 0 then EdtBuf.pos:=PreDot endif;   
                Ed(EdtBuf,".o"); UtFileName:=DICDEF(PickUp(EdtBuf))
           endif;
           if EndFile then
           else ModuleHead; ModuleBody; ModuleTail; endif;
           Close(Inpt); Inpt:=0;
%+D        if TrcSw > 1
%+D        then OutTrace; Ed(TrcBuf,"END  --  Input Bytes ");
%+D             EdInt(TrcBuf,BytPos-1); OutTrace;
%+D        endif;
      endif;

   T1:if Verbose
      then Ed(EdtBuf,"End "); EdSymb(EdtBuf,InFileName); Ed(EdtBuf," to ");
           EdSymb(EdtBuf,UtFileName); Ed(EdtBuf," Conversion");
           if ErrCnt <> 0
           then Ed(EdtBuf,",  Errors: "); EdInt(EdtBuf,ErrCnt) endif;
           OutImage;
      endif;
end;

end;
