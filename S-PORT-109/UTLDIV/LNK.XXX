Module
%-E    LNK("iAPX-286");
%+E    LNK("iAPX-386");
begin insert UCOMN,UBASE;
       -----------------------------------------------------------------
       ---  COPYRIGHT 1989 by                                        ---
       ---  Simula a.s., Oslo, Norway                                ---
       ---                                                           ---
       ---              P O R T A B L E     S I M U L A              ---
       ---                                                           ---
       ---             F O R    i A P X    2 8 6 / 3 8 6             ---
       ---                                                           ---
       ---     T  H  E     M  S  -  D  O  S     L  I  N  K  E  R     ---
       ---                                                           ---
       ---  Selection Switches:                                      ---
       ---                                                           ---
       ---     C - Includes Consistency Tests                        ---
       ---     D - Includes tracing dumps                            ---
       ---     M - Generate code for MS-DOS                          ---
       ---     O - Generate code for MS-OS2                          ---
       ---     X - Generate code for XENIX                           ---
       ---     E - Extended Mode I.e XENIX/386, UNIX/386             ---
       -----------------------------------------------------------------

Define MxpNam=2;      -- I.e. max   512 Local Names    (per OBJ-MODULE)
Define MxpSeg=2;      -- I.e. max   512 Local Segments (per OBJ-MODULE)
Define MxpLgr=1;      -- I.e. max   256 Local Groups   (per OBJ-MODULE)
Define MxpExt=4;      -- I.e. max  1024 Local EXTERNs  (per OBJ-MODULE)
Define MxpBnk=1;      -- I.e. max   256 Global BANKs
Define MxpGrp=1;      -- I.e. max   256 Global GROUPs
Define MxpFrm=8;      -- I.e. max  2048 Global FRAMEs
Define MxpMod=4;      -- I.e. max  1024 Global OBJ-MODULEs
Define MxpLib=2;      -- I.e. max   512 Global LIBRARIES
Define BufLng=4096;   -- size of .LIB and .OBJ file buffers

Define cSTACK=0,cDATA=1,cCODE=2,cLINE=3;
Define fPOINTER=3,fBASE=2,fOFFSET=1,fHIBYTE=4,fLOBYTE=0;
Define iNOP=144,iINT=205,iJMP=233,iJMPF=234,iCALL=232,iCALLF=154;

Define SegAddr=0,GrpAddr=1,ExtAddr=2,NoAddr=3;
Define MaxAddr=3;

Record MemAddr; info "TYPE";
begin Byte Kind;  -- Variant kind code
      Word Ofst;  -- Offset part
      variant Word Segx; -- SegAddr: Mod.SegTab(Segx-1)+Offset
      variant Word Grpx; -- GrpAddr: Mod.GrpTab(Grpx-1)+Offset
      variant Word Extx; -- ExtAddr: Mod.ExtTab(Extx-1)+Offset
end;
%title ******    G L O B A L    D A T A    ******
    Boolean Verbose;
    boolean mergeLinbnk;            -- true if only root AND linbnk
    boolean onebank;                -- true if only root (and linbnk)
    Unsigned HDSIZE;                -- Default size of .EXE-File Header
                                    -- (in 512-Byte Pages)
    Byte xGOTO;                     -- INT-vector index
    Byte xJMPF;                     -- INT-vector index
    Byte xCALL;                     -- INT-vector index
    Byte xCALF;                     -- INT-vector index

--  Boolean BankDefining;           -- 
    Ref(BANK) RotBnk;               -- Root Bank (EXE/Resident part)
    Ref(BANK) LinBnk;               -- LineNumber Bank
    Character NextChar;             -- Next Character from Standard Input
    Integer Total;                  -- Total size in Bytes
    Unsigned NextFrmx;              -- Next available FRAME index
    Ref(FRAME) FrmTab(256);         -- Used as Frmx to FRAME mapping
                                    --      during Module Loading.
    Infix(MemAddr) StartAddr;       -- Program's Start Address
    Ref(OBJMODULE) StartMod;        -- The OBJMODULE With Start Address
    Ref(FRAME) StackFrm;            -- Program's Stack Frame

    Word nBnk; Ref(RefBlock) BNKMAP(MxpBnk);   -- All Defined BANKs
    Word nGrp; Ref(RefBlock) GRPMAP(MxpGrp);   -- All Defined GROUPs
    Word nFrm; Ref(RefBlock) FRMMAP(MxpFrm);   -- All Defined FRAMEs
    Word nMod; Ref(RefBlock) MODMAP(MxpMod);   -- All Defined OBJ-MODULEs
    Word nLib; Ref(RefBlock) LIBMAP(MxpLib);   -- All Defined LIBRARIES
    Infix(ObjCodeBuffer) CBUF;      -- Object Code and LIB-DIC Input Buffer

    --------------- BANK INFO TABLE ---------------
    Unsigned TabLng;                -- Length of BankInfo Table
    Ref(WrdVector) BnkTab;          -- The BankInfo Table

    --------------- CURRENT MODULE UTILITIES ---------------
    Ref(OBJMODULE) CurMod;          -- Current OBJMODULE (During LOADING)
    Ref(FRAME) CurFrm;              -- Current FRAME
    Ref(SEGMENT) CurSeg;            -- Current SEGMENT
%+D Integer BytPos;                 -- Input Byte number
%+D Integer RecPos;                 -- First Byte of current record
    Unsigned RecLng;                -- Length of current record
%+D Byte ChkSum;                    -- Check-sum of current record
%+D Byte RecTyp;                    -- Current Record Type
    Infix(MemAddr) ImpTarget(4);    -- Implicit Target Table
    Infix(MemAddr) ImpFrame(4);     -- Implicit Frame  Table
    Word nNam; Ref(WrdBlock) NamTab(MxpNam); -- All Locally Defined Names
    Word nSeg; Ref(RefBlock) SegTab(MxpSeg); -- All Locally Defined Segments
    Word nLgr; Ref(RefBlock) LgrTab(MxpLgr); -- All Locally Defined Groups
    Word nExt; Ref(WrdBlock) ExtTab(MxpExt); -- All Locally Defined Externals

    --------------- TRACING SWITCHES ---------------
%+D Byte AtrSw;                     -- Allocation Trace mode switch
    Byte LstSw;                     -- Listing Level
%+D Word LN1MOD,LN2MOD;             -- Trace Module's FileName
%+D Integer LN1POS,LN2POS;          -- Trace Start-Byte Pos in File
%+D Unsigned LN1CNT,LN2CNT;         -- Trace Byte Count
%+D Unsigned LN1TRC,LN2TRC;         -- Trace Switces:

    --------------- BASIC FILE HANDLING ---------------
    record IObuffer;
    begin ref(IObuffer) suc;
          word filled;              -- number of bytes valid
          unsigned handle;          -- handle of ass. file
          integer filpos;           -- dest of first byte
          variant character chr(buflng);
          variant byte      byt(buflng);
    end;

    record filedescr;
    begin ref(IObuffer) buf;
          -- ...
    end;

    ref(IObuffer) IOfree;           -- first free buffer
    define nIObuf = 50              -- number of buffers (200K)
    infix(filedescr) fileTable(20)  -- max 20 files (zero if handle not used)
    byte nOpen;                     -- number of open files

    Unsigned Srcf;                  -- Source File Handle
    Unsigned Inpt;                  -- .LIB and .OBJ-Input File Handle
    Unsigned Oupt;                  -- Created Listing File Handle

    --------------- OUTPUT FILE HANDLING ---------------
    Unsigned ExeFile;               -- .EXE-Output File Handle
    Word ExeFilNam;                 -- .EXE-Output File Name
    Unsigned BnkFile;               -- .BNK-Output File Handle
    Word BnkFilNam;                 -- .BNK-Output File Name
    Integer BnkFilLng;              -- Length of BnkFile (in Bytes)
    Ref(DATABLK) FreeBlk;           -- Head of Free Code Buffer Chain
    Ref(DATABLK) CurBlk;            -- Code Buffer during LOADER
    Infix(EXELABEL) ExeLab;         -- .EXE File Label

    --------------- SYMBOL TABLE ---------------
    Unsigned nUNDEF;                -- No.of UNDEFINED PUBLICs
    Ref(RefBlock) PUBREF(MxpSmb);   -- Public info (if PUBLIC Symbol)
    Word sHDSIZE,sLISTING,sINTGOTO,sINTJMPF,sINTCALL,sINTCALF;
    Word sCOMMENT,sLBRK,sRBRK,sCOMA,sEQUAL,sPLUS,sBNK,sEXE,sDEF,sEXT;
    Word sLIB,sEND,sSTACK,sEGOTO,sECALL,sBNKTAB;
%+D Word sLN1TRC,sLN2TRC,sTRACE,sATRACE;
%title ***   D y n a m i c   O b j e c t s    ***
Record BANK;
begin Word           Ident;
      Boolean     Allocated;  -- True: Bank is allocated
--    Boolean        Extern;  -- True: Bank is external
      Dword          Start;   -- Bank's Start Address in Memory
      Integer        Length;  -- Bank's Length (in Bytes)
      Ref(RefVector) PrdBnk;  -- Bank's Predecessors
      Ref(FRAME)     FrmLnk;  -- Bank's FRAMEs (next: Frm.Suc)
      Unsigned       Handle;  -- Bank's OutPut File Handle (.EXE/.BNK)
      Ref(BankDescr) BnkDsc;  -- Bank's Bank Descriptor
      Unsigned       FrmPos;  -- Pos of FrmTab in Bank-Info-Table
      Unsigned       nFrmx;   -- No.of Frame indicies in Bank-Info-Table
end;

--- Record XBANK:BANK;  -- External BANK
--- begin Word FileName;
--- --    ...
--- --    ...
--- --    ...
--- --    ...
--- end;

Record FRAME;
begin Word Ident;        -- Frame's Identification
      Byte cType;        -- Combine Type, 0:STACK,1:DATA,2:CODE,3:LINE
      Dword Start;       -- Frame's Start Address in Memory
      Unsigned Length;   -- Frame's Length          (in Bytes)
      Ref(BANK) Bnk;           -- This FRAME is a member of Bnk
      Ref(FRAME) Suc;          -- Next FRAME belonging to same BANK
      Ref(GROUP) Grp;          -- This FRAME is a member of Grp
      Ref(FRAME) GrpLnk;       -- Next FRAME belonging to same GROUP
      Ref(SEGMENT) first,last; -- List of local segments
      Ref(RELOBLK) RelBlk;     -- List of relocation offset's
end;

Record GROUP;
begin Word Ident;      -- GROUP's Identification
      Dword Start;     -- GROUP's Start Address in Memory
      Ref(FRAME) Frm;  -- First FRAME in this GROUP
end;

Record SEGMENT;
begin Word Modx;        -- 0:NoModule, x:MODMAP.Elt(x)
      Word Ident;       -- Segment Identification
      Byte cType;       -- Combine Type, 0:STACK,1:DATA,2:CODE,3:LINE
      Byte Align;       -- 1:Byte, 2:Word, 3:Para, 4:Page
      Unsigned Length;  -- No.of Bytes in segment
      Unsigned Filled;  -- No.of Bytes filled in segment
      Dword Start;      -- Segment's Start Address in Memory
      Ref(FRAME) Frm;
      Ref(SEGMENT) Suc;
      Ref(DATABLK) first,last;
end;

Record ObjCodeBuffer;
begin Unsigned nxt; -- Next available Byte position
      variant character chr(BufLng);
      variant Byte byt(BufLng);
end;

Record LibBuffer; --- overlays CBUF when reading LIBs
begin variant character chr(BufLng);
      variant Byte byt(BufLng);
end;

Record DATABLK;
begin Ref(DATABLK) Prd,Suc;
      Unsigned Ofst;    -- Relative to CurSeg.Start
      Unsigned Lng;     -- No.of significant Bytes in Image
      variant Byte Image(1024);      -- Load Text Image
      variant character chr(1024);   -- Load Text Image
end;

Record RELOBLK;
begin Ref(RELOBLK) Suc;
      range(0:MaxWord) nRel;
      range(0:MaxWord) Base;        -- Used by BnkTerm
      Word RELTAB(254); -- (0:nRel);
end;

Record PUBLIC;
begin Ref(SEGMENT) Seg;
      Unsigned Ofst;
end;

Record OBJMODULE;
begin Word Ident;      -- File or Element Name
      Word Libx;       -- >0: Element of LIBMAP(Libx)
      Word EltLnk;     -- >0: Next Element is MODMAP(EltLnk)
      Unsigned EltRef;        -- Element FilePos in Paragraphs
      Ref(RefVector) SegTab;  -- Local Segment Table
      Ref(RefVector) LgrTab;  -- Local Group Table
      Ref(WrdVector) ExtTab;  -- Local External Table
end;

Record LIBRARY;
begin Word Ident;      -- Library FileName
      Word FstElt;     -- >0: First Element is MODMAP(FstElt)
      Dword nBlk;      -- Number of Dictionary Blocks
      Dword BlkRef;    -- File Position of First Dictionary Block
end;

Record EXELABEL;
begin Range(0:MaxWord) ChkCode;   --00-- (=23117) EXE-File Check code
      Range(0:MaxWord) Nblp;      --02-- Number of Byte in last page
      Range(0:MaxWord) Lngp;      --04-- File size in 512-Byte pages
      Range(0:MaxWord) nRel;      --06-- No.of relocation entries in table
      Range(0:MaxWord) Lngh;      --08-- Size of header in 16-Byte paragraphs
      Range(0:MaxWord) MinAlloc;  --10-- (=Size of BANK-area)
      Range(0:MaxWord) MaxAlloc;  --12-- (=Size of BANK-area)
      Range(0:MaxWord) SS;        --14-- SS initial value (+reloc)
      Range(0:MaxWord) SP;        --16-- SP initial value
      Range(0:MaxWord) ChkSum;    --18-- Check-Sum
      Range(0:MaxWord) IP;        --20-- IP initial value
      Range(0:MaxWord) CS;        --22-- CS initial value (+reloc)
      Range(0:MaxWord) Relo;      --24-- (=30) Rel. Byte offset of Reloc-Table
      Range(0:MaxWord) Ovln;      --26-- (=0)  Overlay number
      Range(0:MaxWord) Uknw;      --28-- (=1)  Unknown
--??  Dword           RelTab(0);  --30-- Relocation Table, NOTE: NOT Aligned 4
end;
%title ***   B A N K   I N F O   T A B L E   ***

--
-- NOTE: DO NOT CHANGE WITHOUT ALSO CHANGE MODULE  ../env/ecomn  !!!!!
--
-- NOTE: MUST BE INDEPENDENT OF 2/4-BYTE ALIGNMENT               !!!!!
--

Record BankInfo;
begin Byte nBnk;                  --00--
      Byte nNam;                  --01--
      Range(0:MaxWord) NamPos;    --02--
      Range(0:MaxWord) LinBnk;    --04-- Rel.Pos LinBnk's BankDescr or +0
      Range(0:MaxWord) BnkLng;    --06-- Size of Bank-area in paragraphs
      Byte xGOTO;                 --08-- INT-Vector index
      Byte xJMPF;                 --09-- INT-Vector index
      Byte xCALL;                 --10-- INT-Vector index
      Byte xCALF;                 --11-- INT-Vector index
--    Infix(BankDescr) BnkTab;    --12--
end;

Record BankDescr;
begin Range(0:MaxWord) fnam;       --00-- File Name Offset
      Range(0:MaxWord) bnam;       --02-- Bank Name Offset
      Boolean InMem;               --04-- 0:Not in Memory
      Byte nFrm;                   --05-- no.of local Frames
      Range(0:MaxWord) Length;     --06-- Length of Text in Paragraphs
      Integer TxtPos;              --08-- First File-pos (Load Text)
      Integer RelPos;              --12-- First File-pos (Relocations)
      Word MemBase;                --16-- First Paragraph Addr in Memory
      Word FrmBase(0);             --18-- Local Frame Base Addresses
end;

%title ***   I O buffer handling   ***

routine getBuffer; import unsigned handle; export ref(IObuffer) bufr;
--- deliver first buffer on handle ---
begin bufr:=filetable(handle);
      if bufr=none
      then if IOfree=none
           then exhaustAllbut(handle);
                if IOfree=none then exhaust(handle) endif
           endif;
%+C        if IOfree=none then ERROR("IObuffers are gone!!!") endif
           filetable(handle):=bufr:=IOfree;
           bufr.filled:=0; bufr.filpos:=0; bufr.handle:=handle;
      endif
end;

routine exhaustAllbut; import unsigned notThis;
--- return all IObuffers to pool, write if necessary, try to avoid notThis ---
begin Unsigned n,Lng; Integer Loc; ref(IObuffer) bufr,b1;
      handle:=0;
      repeat while handle<>20
      do if handle <> notThis then exhaust(handle) endif;
         handle:=handle+1;
      endrepeat
end;

routine exhaust; import unsigned handle;
begin Unsigned n,Lng; Integer Loc,curpos,filpos; ref(IObuffer) bufr,b1;
      b1:=filetable(handle); curpos:=-1;
      repeat while b1<>none
      do bufr:=b1; b1:=bufr.suc; filpos:=bufr.filpos; Lng:=bufr.filled;
         --- Set File Location ---
         if curpos<>filpos
         then curpos:=filpos; LOCATE(Handle, 0, FilPos, Loc);
             if OsStat <> 0 then MODERR(" writeBlock-1"); OsStat:=0;
             elsif Loc <> FilPos then MODERR(" writeBlock-2") endif;
         endif
         --- Write Buffer to File ---
         if Lng > 0
         then WRITE(Handle, Lng, @bufr.chr, n);
              if OsStat <> 0 then MODERR(" writeBlock-3"); OsStat:=0;
              elsif n <> Lng then MODERR(" writeBlock-4") endif;
         endif;
         curpos:=curpos+lng;
         --- release buffer ---
         bufr.suc:=IOfree; IOfree:=bufr; bufr.filled:=0;
      endrepeat
end;

routine insertBlock;
import ref(IObuffer) bufr; integer filpos; unsigned lng; name(character) chradr;
begin
      if bufr.filled <> 0
      then --- move up contents
      endif
      APX_SMOVEI(lng,@bufr.chr,chradr);
      bufr.filled:=bufr.filled+lng; bufr.filpos:=filpos;
end

routine appendBlock;
import ref(IObuffer) bufr; integer filpos; unsigned lng; name(character) chradr;
begin word pos;
      repeat pos:=bufr.filled; lng1:=buflng-pos while lng1 < lng
      do APX_SMOVEI(lng1,@bufr.chr(pos),chradr); outBuffer(bufr);
         lng:=lng-lng1; chradr:=name(var(chradr)(lng1));
         bufr.filpos:=filpos:=filpos+lng1;
      endrepeat;
      if lng <> 0
      then APX_SMOVEI(lng,@bufr.chr(pos),chradr); bufr.filled:=pos+lng endif;
end

routine writeBlock;
import unsigned handle; integer filpos; unsigned lng; name(character) chradr;
begin Unsigned n; Integer Loc; ref(IObuffer) bufr;
      bufr:=getBuffer(handle);
      if bufr.filled > 0
      then repeat
              if filpos < bufr.filpos
              then insert(bufr,filpos,lng,chradr); goto X1 endif
              if filpos = (bufr.filpos+bufr.filled)
              then append(bufr,filpos,lng,chradr); goto X2 endif
           while bufr.suc <> none do bufr:=bufr.suc endrepeat
           bufr.suc:=newBuffer; bufr:=bufr.suc;
      endif
      insert(bufr,filpos,lng,chradr);
X1: X2:
--    LOCATE(Handle,0,FilPos,Loc);
--    if OsStat <> 0 then MODERR(" writeBlock-1"); OsStat:=0;
--    elsif Loc <> FilPos then MODERR(" writeBlock-2") endif;
--    --- Write Buffer to File ---
--    if Lng > 0
--    then WRITE(Handle,Lng,chradr,n);
--         if OsStat <> 0 then MODERR(" writeBlock-3"); OsStat:=0;
--         elsif n <> Lng then MODERR(" writeBlock-4") endif;
--    endif;
end;

%title ***   O b j e c t    G e n e r a t i o n   ***
Routine NewBANK;
import Size ObjLng; Word Ident; Unsigned nPrd; export ref(BANK) Bnk;
----- Bnk:=NEWOBJ(ObjLng); Bnk.Ident:=Ident;
begin ALLOC(Bnk,  ObjLng); Bnk.Ident:=Ident;
      Bnk.PrdBnk:=NewRefVector(nPrd); nBnk.val:=nBnk.val+1;
      if nBnk.HI >= MxpBnk then CAPERR("Bank-Table Overflow") endif;
      if BNKMAP(nBnk.HI)=none
      then BNKMAP(nBnk.HI):=NEWOBJ(size(RefBlock)) endif;
      BNKMAP(nBnk.HI).Elt(nBnk.LO):=Bnk;
end;

macro NewDATABLK(0); --- Blk implicit parameter
begin if FreeBlk = none then ALLOC(Blk,  Size(DATABLK))
      else Blk:=FreeBlk; FreeBlk:=Blk.Prd endif;
      Blk.Prd:=none; Blk.Suc:=none;
endmacro;
--- Routine NewDATABLK; export ref(DATABLK) Blk;
--- begin if FreeBlk = none then ALLOC(Blk,  Size(DATABLK))
---       else Blk:=FreeBlk; FreeBlk:=Blk.Prd endif;
---       Blk.Prd:=none; Blk.Suc:=none;
--- end;

Routine NewMODULE; import Word Ident; export Word modx;
begin ref(OBJMODULE) Mod; nMod.val:=nMod.val+1;
      if nMod.HI >= MxpMod then CAPERR("Module-Table Overflow") endif;
      if MODMAP(nMod.HI)=none
      then MODMAP(nMod.HI):=NEWOBJ(size(RefBlock)) endif;
----- Mod:=NEWOBJ(Size(OBJMODULE)); Mod.Ident:=Ident;
      ALLOC(Mod,  Size(OBJMODULE)); Mod.Ident:=Ident;
      Mod.Libx.val:=0; Mod.EltLnk.val:=0; Mod.EltRef:=0;
      Mod.LgrTab:=none; Mod.SegTab:=none; Mod.ExtTab:=none;
      MODMAP(nMod.HI).Elt(nMod.LO):=Mod; modx:=nMod;
end;

Routine NewLIBRARY; import Word Ident;
begin ref(LIBRARY) Lib; Unsigned h,n; character Fhdr(16);
%+D   if TrcSw > 0
%+D   then BegTrace("NewLIBRARY: "); EdSymb(TrcBuf,Ident); OutTrace endif
      h:=Open(Ident,".lib",accread); if EndFile then OpenErr(Ident) endif;
      READ(h,16,@Fhdr,n); if OsStat<>0 then ERROR("NewLIBRARY-1")
      elsif n<>16 then EndFile:=true endif; Close(h);
%+D   if TrcSw > 0 then HexDump(0,16,Name(Fhdr)) endif;
      if Fhdr(0) qua Integer <> 240
      then ERROR("Bad Magic -- File is not a Library"); goto E2 endif;
      nLib.val:=nLib.val+1;
      if nLib.HI >= MxpBnk then CAPERR("Library-Table Overflow") endif;
      if LIBMAP(nLib.HI)=none
      then LIBMAP(nLib.HI):=NEWOBJ(size(RefBlock)) endif;
      Lib:=NEWOBJ(Size(LIBRARY)); Lib.Ident:=Ident; Lib.FstElt.val:=0;
      LIBMAP(nLib.HI).Elt(nLib.LO):=Lib;
      Lib.BlkRef.LO   := Fhdr(3) qua Integer;
      Lib.BlkRef.LOHI := Fhdr(4) qua Integer;
      Lib.BlkRef.HILO := Fhdr(5) qua Integer;
      Lib.BlkRef.HI   := Fhdr(6) qua Integer;
      Lib.nBlk.val:=0;
      Lib.nBlk.LO   := Fhdr(7) qua Integer;
      Lib.nBlk.LOHI := Fhdr(8) qua Integer;
--    Lib.nBlk.HILO := Fhdr(9) qua Integer;
--    Lib.nBlk.HI   := Fhdr(10) qua Integer;
%+D   if TrcSw > 0 then EdLib(TrcBuf,Lib) endif;
E2:end;
%title ***  U T I L I T I E S  ***
Routine OpenErr; import word Ident;
begin editSymb(     Ident); Outimage;
      TERMIN(3,"*** Simula linker terminated ***"); end;

Routine MODERR; import infix(string) msg;
begin ERROR(msg);
%+D   Edit(     "    At Byte "); EdInt(EdtBuf,BytPos); Edit(     " in ");
%+D   EdRecType(EdtBuf,RecTyp); Edit(     "(At Byte ");
%+D   EdInt(EdtBuf,RecPos); Edit(     ") in Module ");
%+D   EdModid(EdtBuf,CurMod); OutImage;
end;

Routine FindBank; import Word Ident; export Ref(BANK) Bnk;
begin Word i; i:=nBnk;
      repeat while i.val > 0
      do if BNKMAP(i.HI).Elt(i.LO) qua BANK.Ident=Ident
         then Bnk:=BNKMAP(i.HI).Elt(i.LO); goto E endif;
         i.val:=i.val-1;
      endrepeat;
      Bnk:=none;
E:end;

Routine FindGROUP; import Word Ident; export ref(GROUP) Grp;
begin Word i; i:=nGrp;
      repeat while i.val > 0
      do Grp:=GRPMAP(i.HI).Elt(i.LO); i.val:=i.val-1;
         if Grp.Ident=Ident then goto E1 endif;
      endrepeat;
      nGrp.val:=nGrp.val+1;
      if nGrp.HI >= MxpGrp then CAPERR("Group-Table Overflow") endif;
      if GRPMAP(nGrp.HI)=none
      then GRPMAP(nGrp.HI):=NEWOBJ(size(RefBlock)) endif;
----- Grp:=NEWOBJ(Size(GROUP)); Grp.Ident:=Ident;
      ALLOC(Grp,  Size(GROUP)); Grp.Ident:=Ident;
      Grp.Frm:=none; Grp.Start.val:=0;
      GRPMAP(nGrp.HI).Elt(nGrp.LO):=Grp;
E1:end;

Routine FindFRAME; import Word Ident; export ref(FRAME) Frm;
begin Word i; i:=nFrm;
      repeat while i.val > 0
      do Frm:=FRMMAP(i.HI).Elt(i.LO); i.val:=i.val-1;
         if Frm.Ident=Ident then goto E1 endif;
      endrepeat;
      nFrm.val:=nFrm.val+1;
      if nFrm.HI >= MxpFrm then CAPERR("Frame-Table Overflow") endif;
      if FRMMAP(nFrm.HI)=none
      then FRMMAP(nFrm.HI):=NEWOBJ(size(RefBlock)) endif;
----- Frm:=NEWOBJ(Size(FRAME)); Frm.Ident:=Ident; Frm.Start.val:=0;
      ALLOC(Frm,  Size(FRAME)); Frm.Ident:=Ident; Frm.Start.val:=0;
      FRMMAP(nFrm.HI).Elt(nFrm.LO):=Frm;
E1:end;

Routine FindModule; import Word Ident; export ref(OBJMODULE) Mod;
begin Word modx; modx:=nMod;
      repeat while modx.val > 0
      do Mod:=MODMAP(modx.HI).Elt(modx.LO);
         modx.val:=modx.val-1;
         if Mod.Ident=Ident then goto E1 endif;
      endrepeat;
      modx:=NewMODULE(Ident); if modx.val=0 then Mod:=none
      else Mod:=MODMAP(modx.HI).Elt(modx.LO);
           Inpt:=Open(Mod.Ident,".obj",accread);
           if EndFile then OpenErr(Mod.Ident) endif;
           SCANNER(Mod); Close(Inpt); Inpt:=0;
      endif;
E1:end;


%title ***  Address Convertion ***
Routine Mem2AbsAddr;
import infix(MemAddr) adr; export Dword res;
begin ref(SEGMENT) Seg; ref(GROUP) Grp; ref(PUBLIC) Pub; Word xSmb;
%+C   if CurMod=none then ERROR("Mem2Abs-0"); goto E1 endif;
%+D   if adr.Kind > MaxAddr then ERROR("Mem2Abs-1"); adr.Kind:=MaxAddr endif;
      case 0:MaxAddr (adr.Kind)
      when SegAddr: Seg:=CurMod.SegTab.Elt(adr.Segx.val-1);
           if Seg=none then res.val:=0 else res:=Seg.Start; endif;
      when GrpAddr: Grp:=CurMod.LgrTab.Elt(adr.Grpx.val-1);
%+C        if Grp=none then ERROR("Mem2Abs-2"); goto E2 endif;
%+C        if Grp.Frm=none then ERROR("Mem2Abs-3"); goto E3 endif;
           res:=Grp.Frm.Start; res.Ofst.val:=0;  -- ?????????
      when ExtAddr: xSmb:=CurMod.ExtTab.Elt(adr.Extx.val-1);
           Pub:=PUBREF(xSmb.HI).Elt(xSmb.LO); 
%+C        if Pub=none then ERROR("Mem2Abs-4"); goto E4 endif;
           if Pub.Seg=none then res.val:=0
           else res:=Pub.Seg.Start;
                res.Ofst.val:=res.Ofst.val+Pub.Ofst;
           endif;
      otherwise res.val:=0 endcase;
      res.Ofst.val:=res.Ofst.val+adr.Ofst.val;
%+C E1:E2:E3:E4:
end;

Routine FAddr; --- Form FRAME Address from Frame index
import Byte Frmx; Integer Ea; export Dword a;
begin Integer Eb; a.Segm.LO:=Frmx; a.Segm.HI:=Ea/4096;
      Eb:=a.Segm.val; Eb:=Eb*16;
      if Eb > Ea
      then if a.Segm.HI <> 0 then a.Segm.HI:=a.Segm.HI-1 endif;
           Eb:=a.Segm.val; Eb:=Eb*16;
      endif;
      if Eb > Ea
      then Ed(ErrMsg,"FAddr("); EdWrd(ErrMsg,Frmx); 
           EdChar(ErrMsg,','); EdInt(ErrMsg,Ea); 
           ERROR(") Produces an Illegal Address"); Eb:=Ea;
      endif; a.Ofst.val:=Ea-Eb;
end;

Routine BAddr; --- Form FRAME Address from Base Address
import Word Base; Integer Ea; export Dword a;
begin Integer Eb; a.Segm:=Base; Eb:=Base.val; Eb:=Eb*16;
      if Eb > Ea
      then Ed(ErrMsg,"BAddr("); EdWrd(ErrMsg,Base.val); 
           EdChar(ErrMsg,','); EdInt(ErrMsg,Ea); 
           ERROR(") Produces an Illegal Address"); Eb:=Ea;
      endif; a.Ofst.val:=Ea-Eb;
end;

Routine EAddr; --- Form Effective Address
import Dword a; export Integer Ea;
begin Ea:=a.Segm.val; Ea:=(Ea*16)+a.Ofst.val end;

Routine EBase; --- Form Effective Base
import Dword a; export Integer Eb;
begin Eb:=a.Segm.val; Eb:=Eb*16 end;
%title ***   P r i n t / E d i t   O b j e c t   ***
Routine ShowBnk; import ref(BANK) Bnk;
begin Unsigned i; ref(FRAME) Frm;
      EdSegAddr(Bnk.Start); Edit(     "  BANK  ");
      editSymb(     Bnk.Ident);
      if Bnk.PrdBnk.nElt > 0
      then editChar(     '(');
           i:=0; repeat while i < Bnk.PrdBnk.nElt
           do editSymb(     Bnk.PrdBnk.Elt(i) qua BANK.Ident); i:=i+1;
              if i=Bnk.PrdBnk.nElt then editChar(     ')')
                                   else editChar(     ',') endif;
           endrepeat;
      endif;
      MovePos(EdtBuf,65); Edit(     "LENGTH: ");
      EdHex(EdtBuf,Bnk.Length,5); OutImage;
%+D   if Bnk.BnkDsc <> none
%+D   then SetPos(EdtBuf,24); Ed(EdtBuf,"(File:");
%+D        if    Bnk.Handle=ExeFile then editSymb(     ExeFilNam)
%+D        elsif Bnk.Handle=BnkFile then editSymb(     BnkFilNam)
%+D        else Ed(EdtBuf,"none") endif;
%+D        Ed(EdtBuf,",Txt="); EdInt(EdtBuf,Bnk.BnkDsc.TxtPos);
%+D        Ed(EdtBuf,",Rel="); EdInt(EdtBuf,Bnk.BnkDsc.RelPos);
%+D        editChar(     ')'); OutImage;
%+D   endif;
      Frm:=Bnk.FrmLnk;
      repeat while Frm <> none do ShowFrm(Frm); Frm:=Frm.Suc endrepeat;
      OutImage;
end;

%+D Routine ShowGrp; import ref(GROUP) Grp;
%+D begin Dword Start; ref(FRAME) x; x:=Grp.Frm;
%+D       if x=none then Start.val:=0 else Start:=x.Start endif; 
%+D       EdSegAddr(Start); Ed(EdtBuf,"        ");
%+D       editSymb(     Grp.Ident); OutImage;
%+D       if x=none then Ed(EdtBuf,"Empty"); OutImage
%+D       else repeat while x <> none
%+D            do ShowFrm(x); x:=x.GrpLnk endrepeat;
%+D       endif;
%+D end;

Routine ShowFrm; import ref(FRAME) Frm;
begin ref(GROUP) Grp; ref(SEGMENT) x; x:=Frm.first; Grp:=Frm.Grp;
      EdSegAddr(Frm.Start); Edit(     "        ");
      editSymb(     Frm.Ident);
      if Grp <> none
      then editChar(     '('); editSymb(     Grp.Ident);
           editChar(     ')');
      endif;
      case 0:3 (Frm.cType)
      when cSTACK: Edit(     ":STACK") when cDATA: Edit(     ":DATA")
      when cCODE:  Edit(     ":CODE")  
      when cLINE:  Edit(     if mergeLinbnk then ":LIN_CODE" else ":LINE")
      endcase;
      MovePos(EdtBuf,65);
      Edit(     "LENGTH:  "); EdHexWrd(EdtBuf,Frm.Length,4); OutImage;
      if x=none then Edit(     "Empty"); OutImage
      else repeat while x <> none
           do ShowSeg(x); x:=x.Suc endrepeat;
      endif;
end;

Routine ShowSeg; import ref(SEGMENT) Seg;
begin ref(OBJMODULE) Mod; Word modx;
      modx:=Seg.Modx; Mod:=MODMAP(modx.HI).Elt(modx.LO);
      EdSegAddr(Seg.Start); Edit(     "               ");
      EdModid(EdtBuf,Mod); MovePos(EdtBuf,65);
      Edit(     "LENGTH:  "); EdHexWrd(EdtBuf,Seg.Length,4); OutImage;
end;

%+D Routine ShowBlk; import ref(DATABLK) Blk;
%+D begin if TrcSw < 10 then HexDump(0,Blk.Lng,name(Blk.chr)) endif end;

%+D Routine ShowFileSize; import Unsigned h; infix(String) msg;
%+D begin integer CurLoc,LstLoc;
%+D       LOCATE(h,1,0,CurLoc); -- Get Current Location
%+D       LOCATE(h,2,0,LstLoc); -- Get Last Location
%+D       BegTrace(msg); Ed(TrcBuf," Pos: "); EdInt(TrcBuf,CurLoc);
%+D       Ed(TrcBuf," Size: "); EdInt(TrcBuf,LstLoc); OutTrace;
%+D       LOCATE(h,0,CurLoc,CurLoc); -- Set Current Location
%+D end;

%+D Routine ShowExeLab;
%+D begin Integer nFil;            -- Size of .EXE File (in Bytes)
%+D       Integer BnkLng;          -- Size of .BNK File (in Bytes)
%+D       Integer nMld;            -- Minimum Load Size (in Bytes)
%+D       Integer nTxt;            -- Size of Load Text Image (in Bytes)
%+D       Unsigned nHed;   -- Size of Header (in 16-Byte Paragraphs)
%+D       Unsigned pRel;   -- Start pos of Relocation Table
%+D       Unsigned pTxt;   -- Start pos of Load Text Image
%+D       Dword StckAdr;  -- Stack Address (initial SS:SP)
%+D       Dword StrtAdr;  -- Start Address (initial CS:IP)
%+D       nFil:=ExeLab.Lngp-1; nFil:=(nFil*512)+ExeLab.Nblp;
%+D       pRel:=ExeLab.Relo;
%+D       nHed:=ExeLab.Lngh; pTxt:=nHed; pTxt:=pTxt*16; nTxt:=nFil-pTxt;
%+D       nMld:=ExeLab.MinAlloc; nMld:=(nMld*16)+nTxt; BnkLng:=BnkFilLng;
%+D       StckAdr.Segm.val:=ExeLab.SS;  StrtAdr.Segm.val:=ExeLab.CS;
%+D       StckAdr.Ofst.val:=ExeLab.SP;  StrtAdr.Ofst.val:=ExeLab.IP;
%+D       Edit(     "Size of .EXE File (in Bytes)            ");
%+D       EdInt(EdtBuf,nFil); OutImage;
%+D       Edit(     "Size of .BNK File (in Bytes)            ");
%+D       EdInt(EdtBuf,BnkLng); OutImage;
%+D       Edit(     "Minimum Load Size (in Bytes)            ");
%+D       EdInt(EdtBuf,nMld); OutImage;
%+D       if LstSw > 0
%+D       then Edit(     "Size of Header (in 16-Byte Paragraphs)  ");
%+D            EdWrd(EdtBuf,nHed); OutImage;
%+D            Edit(     "Start Pos of Relocation Table           ");
%+D            EdWrd(EdtBuf,pRel); OutImage;
%+D            Edit(     "Number of Relocation Items              ");
%+D            EdWrd(EdtBuf,ExeLab.nRel); OutImage;
%+D            Edit(     "Start Pos of Load Text Image            ");
%+D            EdWrd(EdtBuf,pTxt); OutImage;
%+D            Edit(     "Size of Load Text Image (in Bytes)      ");
%+D            EdInt(EdtBuf,nTxt); OutImage;
%+D            Edit(     "Minimum Allocation (in Paragraphs)      ");
%+D            EdWrd(EdtBuf,ExeLab.MinAlloc); OutImage;
%+D            Edit(     "Maximum Allocation (in Paragraphs)      ");
%+D            EdWrd(EdtBuf,ExeLab.MaxAlloc); OutImage;
%+D            Edit(     "Stack Address (+Relocation)             ");
%+D            EdAbsAddr(EdtBuf,StckAdr); OutImage;
%+D            Edit(     "Start Address (+Relocation)             ");
%+D            EdAbsAddr(EdtBuf,StrtAdr); OutImage;
%+D       endif;
%+D end;

%+D Routine ShowBankInfo;
%+D begin Unsigned i; ref() x; infix(String) FilNam;
%+D       x:=Name2Ref(@BnkTab.Elt(0)); ShowBnkInf(x); x:=x+size(BankInfo);
%+D       i:=0; repeat i:=i+1 while i <= nBnk.val
%+D       do ShowBnkDsc(x);
%+D          x:=x+size(BankDescr:wOR(x qua BankDescr.nFrm,1));
%+D       endrepeat;
%+D       FilNam:=ASCIIZ2String(x,72); x:=x+size(ASCIIZ:FilNam.nchr+1);
%+D       Ed(TrcBuf,"ExeFilNam:"); Ed(TrcBuf,FilNam); OutTrace;
%+D       if BnkFile <> 0
%+D       then FilNam:=ASCIIZ2String(x,72); x:=x+size(ASCIIZ:FilNam.nchr+1);
%+D            Ed(TrcBuf,"BnkFilNam:"); Ed(TrcBuf,FilNam); OutTrace;
%+D       endif;
%+D       i:=0; repeat i:=i+1 while i <= nBnk.val
%+D       do FilNam:=ASCIIZ2String(x,72); x:=x+size(ASCIIZ:FilNam.nchr+1);
%+D          Ed(TrcBuf,"BankName:"); Ed(TrcBuf,FilNam); OutTrace;
%+D       endrepeat;
%+D end;

%+D Routine ShowBnkInf; import ref(BankInfo) x;
%+D begin Edit(     "***  BANK INFO TABLE  ***"); OutImage;
%+D       Edit(     "nBnk:");       EdWrd(EdtBuf,x.nBnk);
%+D       Edit(     ", nNam:");     EdWrd(EdtBuf,x.nNam);
%+D       Edit(     ", NamPos:");   EdWrd(EdtBuf,x.NamPos);
%+D       Edit(     ", LinBnk:");   EdWrd(EdtBuf,x.LinBnk);
%+D       Edit(     ", BnkLng:");   EdWrd(EdtBuf,x.BnkLng);
%+D       Edit(     ", xGOTO:");    EdWrd(EdtBuf,x.xGOTO);
%+D       Edit(     " xJMPF:");     EdWrd(EdtBuf,x.xJMPF);
%+D       Edit(     " xCALL:");     EdWrd(EdtBuf,x.xCALL);
%+D       Edit(     " xCALF:");     EdWrd(EdtBuf,x.xCALF); OutImage;
%+D end;

%+D Routine ShowBnkDsc; import ref(BankDescr) x;
%+D begin Integer i;
%+D       Edit(     "***  BANK DESCRIPTOR  ***"); OutImage;
%+D       Edit(     "fnam:"); EdWrd(EdtBuf,x.fnam);
%+D       Edit(     ", bnam:"); EdWrd(EdtBuf,x.bnam);
%+D       Edit(     ", InMem:"); if x.InMem
%+D       then Edit(     "True") else Edit(     "False") endif;
%+D       Edit(     ", nFrm:");   EdWrd(EdtBuf,x.nFrm); OutImage;
%+D       Edit(     "MemBase:");  EdHexWrd(EdtBuf,x.MemBase.val,4);
%+D       Edit(     ", TxtPos:"); EdInt(EdtBuf,x.TxtPos);
%+D       Edit(     ", RelPos:"); EdInt(EdtBuf,x.RelPos);
%+D       Edit(     ", Length:"); EdWrd(EdtBuf,x.Length); OutImage;
%+D       Edit(     "FrmBase:");
%+D       i:=0; repeat while i < x.nFrm
%+D       do if EdtBuf.Pos > 50 then OutImage; SetPos(EdtBuf,8) endif;
%+D          editChar(     ' '); EdHexWrd(EdtBuf,x.FrmBase(i).val,4); i:=i+1
%+D       endrepeat; OutImage;
%+D end;
%title ***   E D I T I N G   ***

macro EDFAST(1);
begin EdtBuf.chr(EdtBuf.pos):=%1; EdtBuf.pos:=EdtBuf.pos+1;
endmacro;

macro FASTUP(1);
begin %1 .nchr  :=EdtBuf.pos;
      %1 .chradr:= if EdtBuf.pos=0 then noname else @EdtBuf.chr;
      EdtBuf.pos:=0;
endmacro;

Routine EdSegAddr; import Dword adr;
begin EdHex(EdtBuf,EAddr(adr),5);
      EditChar('('); EdAbsAddr(edtBuf,adr); EditChar(')');
end;

Routine EdAbsAddr; import ref(EdBuff) F; Dword adr;
begin EdHexWrd(F,adr.Segm.val,4); EdChar(F,':');
      EdHexWrd(F,adr.Ofst.val,4);
end;

Routine EdAddr; import ref(EdBuff) F; infix(MemAddr) adr;
begin case 0:MaxAddr (adr.Kind)
 when SegAddr: EdSymb(F,CurMod.SegTab.Elt(adr.Segx.val-1) qua SEGMENT.Ident);
 when GrpAddr: EdSymb(F,CurMod.LgrTab.Elt(adr.Grpx.val-1) qua GROUP.Ident);
 when ExtAddr: EdSymb(F,CurMod.ExtTab.Elt(adr.Extx.val-1));
 when NoAddr:  Ed(F,"NoAddr"); adr.Ofst.val:=0  endcase;
      if adr.Ofst.val<>0 then EdChar(F,'+'); EdWrd(F,adr.Ofst.val) endif
end;

Routine EdModid; import ref(EdBuff) F; ref(OBJMODULE) Mod;
begin Word libx; libx:=Mod.Libx;
      if Libx.val=0 then EdSymb(F,Mod.Ident)
      else EdSymb(F,LIBMAP(libx.HI).Elt(libx.LO) qua LIBRARY.Ident);
           if Mod.Ident.val=0 then EdChar(F,':'); EdHex(F,Mod.EltRef,4)
           else EdChar(F,'!'); EdSymb(F,Mod.Ident) endif;
      endif;
end;

%+D Routine EdLib; import ref(EdBuff) F; ref(LIBRARY) Lib;
%+D begin Ed(F,"LIBRARY: "); EdSymb(F,Lib.Ident); PrintOut(F);
%+D       Ed(F,"DIC Start Address:    "); EdHex(F,Lib.BlkRef.val,8);
%+D       Ed(F," = "); EdInt(F,Lib.BlkRef.val); PrintOut(F);
%+D       Ed(F,"Number of DIC Blocks: "); EdHex(F,Lib.nBlk.val,8);
%+D       Ed(F," = "); EdInt(F,Lib.nBlk.val); PrintOut(F);
%+D end;

%+D Routine EdRecType; import ref(EdBuff) F; Byte t;
%+D begin if t=110 then Ed(F,"RHEADR") elsif t=112 then Ed(F,"REGINT")
%+D    elsif t=114 then Ed(F,"REDATA") elsif t=116 then Ed(F,"RIDATA")
%+D    elsif t=118 then Ed(F,"OVLDEF") elsif t=120 then Ed(F,"ENDREC")
%+D    elsif t=122 then Ed(F,"BLKDEF") elsif t=124 then Ed(F,"BLKEND")
%+D    elsif t=126 then Ed(F,"DEBSYM") elsif t=128 then Ed(F,"THEADR")
%+D    elsif t=130 then Ed(F,"LHEADR") elsif t=132 then Ed(F,"PEDATA")
%+D    elsif t=134 then Ed(F,"PIDATA") elsif t=136 then Ed(F,"COMENT")
%+D    elsif t=138 then Ed(F,"MODEND") elsif t=140 then Ed(F,"EXTDEF")
%+D    elsif t=142 then Ed(F,"TYPDEF") elsif t=144 then Ed(F,"PUBDEF")
%+D    elsif t=146 then Ed(F,"LOCSYM") elsif t=148 then Ed(F,"LINNUM")
%+D    elsif t=150 then Ed(F,"LNAMES") elsif t=152 then Ed(F,"SEGDEF")
%+D    elsif t=154 then Ed(F,"GRPDEF") elsif t=156 then Ed(F,"FIXUPP")
%+D                                    elsif t=160 then Ed(F,"LEDATA")
%+D    elsif t=162 then Ed(F,"LIDATA") elsif t=164 then Ed(F,"LIBHED")
%+D    elsif t=166 then Ed(F,"LIBNAM") elsif t=168 then Ed(F,"LIBLOC")
%+D    elsif t=170 then Ed(F,"LIBDIC") else EdHex(F,t,2); Ed(F,"H=????") endif;
%+D end;

%title ***  A l l o c a t e   B a n k  ***

Routine AllocBnk; import ref(BANK) Bnk;
begin Word Base; Unsigned i,Align,nFrmx; Integer MemPos,mm;
      ref(BANK) Prd; ref(GROUP) Grp; ref(FRAME) Frm; ref(SEGMENT) Seg;
      ref(BankDescr) BnkDsc;
      if Bnk.Allocated then goto E endif;
      Bnk.Allocated:=true; MemPos:=TabLng; i:=Bnk.PrdBnk.nElt;
      BnkDsc:=Bnk.BnkDsc; nFrmx:=0;
%+D   if AtrSw > 0
%+D   then AllocTrace(MemPos,EAddr(Bnk.Start),Bnk.Length,
%+D                  " Begin Allocate Bank ",Bnk.Ident);
%+D        if AtrSw > 1 then ShowBnk(Bnk) endif;
%+D   endif;
      if i=0
      then if Bnk <> RotBnk
           then ERROR("More than one Root Bank") endif;
      endif;
      repeat while i > 0
      do i:=i-1; Prd:=Bnk.PrdBnk.Elt(i); AllocBnk(Prd);
         mm:=EAddr(Prd.Start) + Prd.Length;
         if mm > MemPos then MemPos:=mm endif;
%+D      if AtrSw > 0
%+D      then AllocTrace(MemPos,EAddr(Prd.Start),Prd.Length,
%+D                     "                Pred ",Prd.Ident);
%+D      endif;
      endrepeat;
      if Bnk=RotBnk then MemPos:=((MemPos+1)/2)*2; BnkDsc.MemBase.val:=0;
      else MemPos:=((MemPos+15)/16)*16; BnkDsc.MemBase.val:=MemPos/16 endif;
      Bnk.Start:=FAddr(NextFrmx,MemPos);
--    if Bnk.Extern
--    then
--         -- ... NB: TRACE
--         -- ... NB: TRACE
--         -- ... NB: TRACE
--         NextFrmx:=NextFrmx+Bnk.nFrmx;
--         if NextFrmx > 255 then ERROR("Too Many Frames") endif;
--         -- ... ... ...
--         -- ... ... ...
--         -- ... ... ...
--         -- ... ... ...
--    else Frm:=Bnk.FrmLnk;
           Frm:=Bnk.FrmLnk;
           repeat while Frm <> none
           do Grp:=Frm.Grp;
              if Grp <> none
              then if Grp.Start.val=0 ---- Grp.Start.Kind=NoAddr    ????????
                   then Grp.Start:=FAddr(NextFrmx,MemPos);
                        FrmTab(NextFrmx):=Frm;
                        BnkDsc.FrmBase(nFrmx):=Grp.Start.Segm;
                        NextFrmx:=NextFrmx+1; nFrmx:=nFrmx+1;
                   endif;
                   Base:=Grp.Start.Segm; Frm.Start:=BAddr(Base,MemPos)
              else Frm.Start:=FAddr(NextFrmx,MemPos); FrmTab(NextFrmx):=Frm;
                   NextFrmx:=NextFrmx+1; Base:=Frm.Start.Segm;
                   BnkDsc.FrmBase(nFrmx):=Base; nFrmx:=nFrmx+1;
              endif;
              Frm.Length:=0; Seg:=Frm.first;
%+D           if AtrSw > 0
%+D           then AllocTrace(MemPos,EAddr(Frm.Start),Frm.Length,
%+D                          "       Frame         ",Frm.Ident);
%+D           endif;
              if Seg <> none
              then repeat while Seg <> none
                   do Align:=Seg.Align;
                      if    Align=1 then -- nothing ;
                      elsif Align=2 then MemPos:=((MemPos+1)/2)*2
                      elsif Align=3 then MemPos:=((MemPos+15)/16)*16
                      elsif Align=4 then MemPos:=((MemPos+511)/512)*512
                      else ERROR("Alignment is not supported") endif;
                      Seg.Start:=BAddr(Base,MemPos);
                      MemPos:=MemPos+Seg.Length;
%+D                   if AtrSw > 0
%+D                   then AllocTrace(MemPos,EAddr(Seg.Start),Seg.Length,
%+D                                  "             Segment ",Seg.Ident);
%+D                   endif;
                      Seg:=Seg.Suc;
                   endrepeat;
                   Frm.Start:=Frm.first.Start;
                   Frm.Length:=MemPos-EAddr(Frm.Start);
                   if NextFrmx > 255 then ERROR("Too Many Frames") endif;
%+D                if AtrSw > 0
%+D                then AllocTrace(MemPos,EAddr(Frm.Start),Frm.Length,
%+D                               "   End Frame         ",Frm.Ident);
%+D                endif;
              endif;
              Frm:=Frm.Suc;
           endrepeat;
--    endif;
      Bnk.Length:=MemPos-EAddr(Bnk.Start); MemPos:=((MemPos+15)/16)*16;
      BnkDsc.Length:=(Bnk.Length+15)/16;  --- ?????????
      if MemPos > Total then Total:=MemPos endif;
      if Bnk <> RotBnk
      then BnkDsc.TxtPos:=BnkFilLng;
           BnkFilLng:=BnkFilLng+Bnk.Length;
      endif;
%+D   if AtrSw > 0
%+D   then AllocTrace(MemPos,EAddr(Bnk.Start),Bnk.Length,
%+D                  " End   Allocate Bank ",Bnk.Ident);
%+D        if AtrSw > 1 then ShowBnk(Bnk) endif;
%+D   endif;
E:end;

%+D Routine AllocTrace; 
%+D import Integer MemPos,Start,Lng;
%+D        infix(String) ms; Word id;
%+D begin BegTrace("MemPos="); EdInt(TrcBuf,MemPos); Ed(TrcBuf,ms);
%+D       EdSymb(TrcBuf,id); Ed(TrcBuf,", Start="); EdInt(TrcBuf,Start);
%+D       Ed(TrcBuf,", Lng="); EdInt(TrcBuf,Lng);
%+D       Ed(TrcBuf,", Total="); EdInt(TrcBuf,Total); OutTrace;
%+D end;
%title ***  Insert Segment into Bank  ***
Routine InsertSegment; import ref(SEGMENT) Seg; ref(BANK) Bnk;
begin Unsigned i; ref(FRAME) Frm,x,y; Byte c;
      if Seg.Frm <> none
      then Edit(     "*** WARNING *** "); EdModid(EdtBuf,CurMod);
           editChar(     ':'); editSymb(     Seg.Ident);
           if Seg.Frm.Bnk = none
           then Edit(     " Already Included in this Bank")
           else Edit(     " Already Included in Bank ");
                editSymb(     Seg.Frm.Bnk.Ident);
           endif; OutImage;
      else Frm:=FindFRAME(Seg.Ident);
           -- Include Logical Segment (Seg) into Frame (Frm) --
           if Frm.first <> none then Frm.last.Suc:=Seg; Frm.last:=Seg;
           else Frm.first:=Frm.last:=Seg; Frm.cType:=Seg.cType endif;
           Seg.Suc:=none; Seg.Frm:=Frm;
           if Seg.cType=cSTACK
           then if StackFrm=none then StackFrm:=Frm
                else ERROR("More than one Stack Segment") endif;
           endif;
           -- Check if Frame should be Placed in RotBnk or LinBnk --
           if    Frm.cType = cCODE then -- OK
           elsif Frm.cType = cLINE then Bnk:=LinBnk;
           else Bnk:=RotBnk endif;
           -- Check if Frame is already Placed in another Bank --
           if (Frm.Bnk <> none) and (Frm.Bnk <> Bnk)
           then Edit(     "*** WARNING *** "); editSymb(     Seg.Ident);
                Edit(     " Already Part of Bank ");
                editSymb(     Frm.Bnk.Ident); OutImage;
           endif;
           if Frm.Bnk = none
           then -- Place Frame (Frm) in Bank (Bnk) --
                x:=Bnk.FrmLnk; c:=Frm.cType;
                if x=none then Bnk.FrmLnk:=Frm elsif Frm.Grp=none
                then if c < x.cType then Bnk.FrmLnk:=Frm; Frm.Suc:=x;
                     else L1: y:=x; x:=x.Suc; if x=none then y.Suc:=Frm
                          elsif c < x.cType then Frm.Suc:=x; y.Suc:=Frm
                          else goto L1 endif;
                     endif;
                elsif c <= x.cType then Bnk.FrmLnk:=Frm; Frm.Suc:=x;
                else L2: y:=x; x:=x.Suc; if x=none then y.Suc:=Frm
                     elsif c <= x.cType then Frm.Suc:=x; y.Suc:=Frm
                     else goto L2 endif;
                endif; Frm.Bnk:=Bnk;
           endif;
      endif;
end;
%page

Routine InsertAllSeg; import ref(OBJMODULE) Mod; ref(BANK) Bnk;
begin ref(SEGMENT) Seg; Unsigned segx; segx:=0;
      repeat while segx < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(segx); segx:=segx+1;
         if (Seg.Length>0) and (Seg.Frm=none)
         then InsertSegment(Seg,Bnk) endif;
      endrepeat;
end;

Routine ChkInsert; import ref(OBJMODULE) Mod;
begin Unsigned segx; ref(BANK) Bnk; ref(FRAME) Frm; ref(SEGMENT) Seg;
      segx:=0; repeat while segx < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(segx); segx:=segx+1; Bnk:=none;
         if Seg.Length>0
         then Frm:=Seg.Frm; if Frm <> none then Bnk:=Frm.Bnk endif;
              if Bnk = none
              then Ed(ErrMsg,"Segment "); EdSymb(ErrMsg,Seg.Ident);
                   EdChar(ErrMsg,'('); EdModid(ErrMsg,Mod);
                   ERROR(") Not Included"); InsertSegment(Seg,RotBnk);
              endif;
         endif;
      endrepeat;
end;
%title ***   M A K E   B A N K   I N F O   T A B L E   ***

Routine MakeBankInfoTable;
begin Unsigned i,nNam,nFrmx,ExeNamPos,FilNamPos; Word w;
      ref(BANK) Bnk; ref(GROUP) Grp;
      ref(FRAME) Frm; infix(String) FilNam;
      ref() x; ref(BankInfo) BnkInf; ref(BankDescr) BnkDsc;
      ref(ASCIIZ) Nam;
      Integer Root;

      if mergeLinbnk then merge endif
      DefPUBLIC(sBNKTAB,none,0); -- S@BNKTAB=0000:0000+Reloc
      TabLng:=Size2Int(Size(BankInfo));
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         Frm:=Bnk.FrmLnk; nFrmx:=0;
         repeat while Frm <> none
         do Grp:=Frm.Grp;
            if Grp = none then nFrmx:=nFrmx+1
            elsif Grp.Frm=Frm then nFrmx:=nFrmx+1 endif;
            Frm:=Frm.Suc;
         endrepeat;
         Bnk.FrmPos:=TabLng+Size2Int(Size(BankDescr:wOR(0,1)));
         Bnk.nFrmx:=nFrmx;
         TabLng:=TabLng+Size2Int(Size(BankDescr:wOR(nFrmx,1)));
      endrepeat;

      --- Add Size of all ASCIIZ file/bank names
      nNam:=1; ExeNamPos:=TabLng;
      editSymb(     ExeFilNam); FilNam:=PickupEdt     ;
      TabLng:=TabLng+Size2Int(Size(ASCIIZ:FilNam.nchr+1)); -- .exe File
      if BnkFile <> 0
      then nNam:=nNam+1; FilNamPos:=TabLng;
           editSymb(     BnkFilNam); FilNam:=PickupEdt     ;
           TabLng:=TabLng+Size2Int(Size(ASCIIZ:FilNam.nchr+1)); -- .bnk
      endif;
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; nNam:=nNam+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         FilNam:=DICREF(Bnk.Ident);
         TabLng:=TabLng+Size2Int(Size(ASCIIZ:FilNam.nchr+1)); -- BnkName
      endrepeat;

      BnkTab:=NewWrdVector((TabLng+1)/2); x:=Name2Ref(@BnkTab.Elt(0));

      BnkInf:=x; x:=x+size(BankInfo); --- First
      BnkInf.nBnk:=nBnk.val; BnkInf.nNam:=nNam;
      BnkInf.NamPos:=ExeNamPos; BnkInf.LinBnk:=0;
      BnkInf.xGOTO:=xGOTO; BnkInf.xJMPF:=xJMPF;
      BnkInf.xCALL:=xCALL; BnkInf.xCALF:=xCALF;

      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         Frm:=Bnk.FrmLnk; nFrmx:=0;
         repeat while Frm <> none
         do Grp:=Frm.Grp;
            if Grp = none then nFrmx:=nFrmx+1
            elsif Grp.Frm=Frm then nFrmx:=nFrmx+1 endif;
            Frm:=Frm.Suc;
         endrepeat;
         BnkDsc:=x; Bnk.BnkDsc:=x;
         if Bnk=LinBnk then BnkInf.LinBnk:=Size2Int(BnkDsc-BnkInf) endif
         x:=x+size(BankDescr:wOR(nFrmx,1)); BnkDsc.nFrm:=nFrmx;
         if Bnk=RotBnk then BnkDsc.fnam:=ExeNamPos; BnkDsc.InMem:=True;
         else BnkDsc.fnam:=FilNamPos; BnkDsc.InMem:=False endif;
      endrepeat;

      --- Fill in File Names ---
      editSymb(     ExeFilNam); EDFAST(0 qua Character);
      FilNam:=PickupEdt     ; Nam:=x; x:=x+size(ASCIIZ:FilNam.nchr);
      APX_SMOVEI(FilNam.nchr,Ref2Name(Nam),FilNam.chradr);
      if BnkFile <> 0
      then editSymb(     BnkFilNam); EDFAST(0 qua Character);
           FilNam:=PickupEdt     ; Nam:=x; x:=x+size(ASCIIZ:FilNam.nchr)
           APX_SMOVEI(FilNam.nchr,Ref2Name(Nam),FilNam.chradr);
      endif;

      --- Fill in Bank Names ---
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         editSymb(     Bnk.Ident); EDFAST(0 qua Character);
         FilNam:=PickupEdt     ; Nam:=x; x:=x+size(ASCIIZ:FilNam.nchr);
         APX_SMOVEI(FilNam.nchr,Ref2Name(Nam),FilNam.chradr);
         Bnk.BnkDsc.bnam:=Size2Int(Nam-BnkInf);
      endrepeat;

%+D   if AtrSw > 1 then ShowBankInfo endif;
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; AllocBnk(BNKMAP(w.HI).Elt(w.LO)) endrepeat;
%+D   if AtrSw > 1 then MapListing endif;
      Root:=(((TabLng+1)/2)*2)+RotBnk.Length;
      BnkInf.BnkLng:=((Total+15)/16) - ((Root+15)/16);
      if BnkInf.BnkLng=0 then if mergeLinbnk
      then BnkInf.BnkLng:=1 endif endif -- nonzero to avoid load HI
%+D   if AtrSw > 1 then ShowBankInfo endif;
end;

routine merge;
begin ref(FRAME) Frm,x,y;
      Frm:= LinBnk.FrmLnk;
      --- move frames from LinBnk to RotBnk
      x:=RotBnk.FrmLnk;
      repeat y:=x; x:=x.suc while x<>none do endrepeat;
      y.suc:=Frm;
      --- adjust Frm.Bnk
      repeat while Frm<>none do Frm.Bnk:=RotBnk; Frm:=Frm.suc endrepeat;
      --- adjust root length
      RotBnk.length:= EAddr(LinBnk.Start)+LinBnk.length-EAddr(RotBnk.Start);
      --- remove LinBnk
      BNKMAP(nBnk.HI).Elt(nBnk.LO):=none; nBnk.val:=1; LinBnk:=none;
end;

%title ***  B A S I C    O B J - C O D E    I N P U T  ***

macro InitObjCode(0);
begin InCbuffer; endmacro;

Routine InCbuffer;
begin Unsigned k;
      READ(Inpt,BufLng,%@CBUF.chr%,k);
      if OsStat <> 0 then MODERR("inCbuffer") endif;
      if k < BufLng then CBUF.byt(k):=0 endif;
      CBUF.nxt:=0;
end;

Macro InByte(1);
--- begin if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
begin if CBUF.nxt >= BufLng then InCbuffer endif;
%+D   ChkSum:=ChkSum+CBUF.byt(CBUF.nxt); --- ChkSum:=(ChkSum+ ..) rem 256;
      %1:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
      RecLng:=RecLng-1;
%+D   BytPos:=BytPos+1;
endmacro;

--- Macro SkipByte:
---       if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
--- %+D   ChkSum:=ChkSum+CBUF.byt(CBUF.nxt); --- ChkSum:=(ChkSum+ ..) rem 256;
---       CBUF.nxt:=CBUF.nxt+1;
---       RecLng:=RecLng-1; BytPos:=BytPos+1;
--- endmacro;

%+D macro skiprecord: doSkipRecord(rectyp) endmacro
%-D macro skiprecord: doSkipRecord         endmacro

Routine doSkipRecord;
%+D                 import byte typ; -- type of current record
begin Integer Loc; Byte b;
%+D   if TrcSw > 3
%+D   then if RecLng > 1
%+D        then OutTrace; Ed(TrcBuf,"*** "); EdWrd(TrcBuf,RecLng-1);
%+D             Ed(TrcBuf," Bytes Skipped"); OutTrace;
%+D        endif;
%+D        if TrcSw <> typ then goto nodump endif;
%+D        repeat while RecLng > 0
%+D        do if TrcBuf.Pos > 63 then OutTrace endif;
%+D           EdChar(TrcBuf,' '); InByte(%b%); EdHex(TrcBuf,b,2);
%+D        endrepeat;
%+D        --- InByte(%b%);
%+D        ChkSum:=0;   --- Bypass ChkSum Testing
%+D   else --- Locate Next Record ---
%+D   nodump:
           CBUF.nxt:=CBUF.nxt+RecLng;
           if CBUF.nxt > BufLng
           then LOCATE(Inpt,1,CBUF.nxt-BufLng,Loc); CBUF.nxt:=BufLng
                if OsStat <> 0 then MODERR("SkipRecord"); OsStat:=0 endif;
           endif;
---        if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
           if CBUF.nxt >= BufLng then InCbuffer endif;
%+D        ChkSum:=0; --- Bypass ChkSum Testing
%+D   endif;
end;

Routine ScanData; import Unsigned Lng; export Ref(DATABLK) Blk;
begin Unsigned Rst,j,k; --- Blk:=NewDataBLK;
      NewDATABLK; Blk.Lng:=Lng; Blk.Ofst:=0; j:=0;
      if Lng >= RecLng then MODERR("ScanData-1"); Lng:=RecLng-1 endif;
      RecLng:=RecLng-Lng;
%+D   BytPos:=BytPos+Lng;
      repeat Rst:=BufLng-CBUF.nxt while Lng > 0
      do k:=if Rst < Lng then Rst else Lng;
         APX_SMOVEI(k,@Blk.chr(j),@CBUF.chr(CBUF.nxt));
         CBUF.nxt:=CBUF.nxt+k; j:=j+k; Lng:=Lng-k;
---      if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
         if CBUF.nxt >= BufLng then InCbuffer endif;
      endrepeat;
%+D   if TrcSw > 3 then ShowBlk(Blk) endif;
end;

Macro ScanByte(2);
begin
%-D   --- InByte-call expanded ---
--- %-D   if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
%-D   if CBUF.nxt >= BufLng then InCbuffer endif;
%-D   %1:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   RecLng:=RecLng-1; --- BytPos:=BytPos+1;
%+D   %1:=DoScanByte(%2);
endmacro;
%+D Routine DoScanByte;
%+D import infix(string) id;
%+D export Byte n;
%+D begin InByte(%n%);
%+D       if TrcSw > 2
%+D       then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D            EdChar(TrcBuf,':'); EdHex(TrcBuf,n,2);
%+D       endif;
%+D end;

Macro ScanIndex(2);
begin
%-D   if CBUF.nxt >= BufLng then InCbuffer endif;
%-D   %1 .val :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   if %1 .val>127
%-D   then %1 .HI:=%1 .LO-128;
%-D        if CBUF.nxt >= BufLng then InCbuffer endif;
%-D        %1 .LO :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D        RecLng:=RecLng-2;
%-D   else RecLng:=RecLng-1; endif;
%+D   %1:=DoScanIndex(%2);
endmacro;
%+D Routine DoScanIndex;
%+D import infix(string) id;
%+D export Word w;
%+D begin InByte(%w.val%);
%+D   if w.val>127 then w.HI:=w.LO-128; InByte(%w.LO%) endif;
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdWrd(TrcBuf,w.val);
%+D   endif;
%+D end;

Macro ScanName(2);
begin
%-D  %1:=DoScanName;
%+D  %1:=DoScanName(%2);
endmacro;
Routine DoScanName;
%+D import infix(string) id;
export Word res;
begin Byte n,c; InByte(%n%); if n=0 then res.val:=0; goto E endif;
      repeat while n <> 0
      do n:=n-1; InByte(%c%); EDFAST(c qua character) endrepeat;
      res:=DICDEF(PickupEdt     );
E:
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdSymb(TrcBuf,res);
%+D   endif
end;

Macro ScanWord(2);
begin
%-D   if CBUF.nxt >= BufLng then InCbuffer endif;
%-D   %1 .LO :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   if CBUF.nxt >= BufLng then InCbuffer endif;
%-D   %1 .HI :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   RecLng:=RecLng-2;
%+D  %1:=DoScanWord(%2);
endmacro;
%+D Routine DoScanWord;
%+D import infix(string) id;
%+D export Word w;
%+D begin InByte(%w.LO%); InByte(%w.HI%);
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdWrd(TrcBuf,w.val);
%+D   endif;
%+D end;
%title ***    L o g i c a l    A d d r e s s    ***
Routine ScanLogicalAddr; export infix(MemAddr) Adr;
begin Byte n,TARGT,FRAM,P,T,F; Word UnUsed; infix(MemAddr) FrmAdr; Boolean Fchk;
%+C   Dword a1,a2;
      Fchk:=false;
      if RecLng<2 then MODERR("LogicalAddr-1"); goto E1 endif;
      InByte(%n%);              TARGT:=bAND(n,3);
      P:=bAND(bSHR(n,2),1);     T:=bAND(bSHR(n,3),1);
      FRAM:=bAND(bSHR(n,4),7);  F:=bAND(bSHR(n,7),1);
%+D   if TrcSw > 3
%+D   then OutTrace; SetPos(TrcBuf,10);
%+D        Ed(TrcBuf,"<F:");      EdWrd(TrcBuf,F);
%+D        Ed(TrcBuf," FRAME:");  EdWrd(TrcBuf,FRAM);
%+D        Ed(TrcBuf," T:");      EdWrd(TrcBuf,T);
%+D        Ed(TrcBuf," P:");      EdWrd(TrcBuf,P);
%+D        Ed(TrcBuf," TARGT:");  EdWrd(TrcBuf,TARGT);
%+D   endif;
      if F=1 then FrmAdr:=ImpFrame(FRAM); Fchk:=true;
      elsif FRAM < 4
      then FrmAdr.kind:=FRAM; Fchk:=true; FrmAdr.Ofst.val:=0;
           if RecLng<2 then MODERR("LogicalAddr-2"); goto E2 endif;
           case 0:3 (FRAM)
           when SegAddr: ScanIndex(FrmAdr.Segx,"Segx")
           when GrpAddr: ScanIndex(FrmAdr.Grpx,"Grpx")
           when ExtAddr: ScanIndex(FrmAdr.Extx,"Extx")
           otherwise ERROR("Address with FrameNumber -- Not supported");
                     ScanWord(UnUsed,"FrameNumber");
           endcase;
      endif;
      if T=1 then Adr:=ImpTarget(TARGT);
      else Adr.kind:=TARGT;
           if RecLng<2 then MODERR("LogicalAddr-2"); goto E3 endif;
           case 0:3 (TARGT)
           when SegAddr: ScanIndex(Adr.Segx,"Segx")
           when GrpAddr: ScanIndex(Adr.Grpx,"Grpx")
           when ExtAddr: ScanIndex(Adr.Extx,"Extx")
           otherwise ERROR("Address with FrameNumber -- Not supported");
                     ScanWord(UnUsed,"FrameNumber");
           endcase;
      endif;
      if P=1 then Adr.Ofst.val:=0
      else if RecLng<3 then MODERR("LogicalAddr-4"); goto E4 endif;
           ScanWord(Adr.Ofst,"Disp");
      endif;
E1:E2:E3:E4:
%+D   if TrcSw > 3 then EdChar(TrcBuf,'>'); OutTrace endif;
%+C   if Fchk 
%+C   then a1:=Mem2AbsAddr(FrmAdr); a2:=Mem2AbsAddr(Adr);
%+C        if a1.Segm <> a2.Segm
%+C        then EdAddr(ErrMsg,Adr); EdChar(ErrMsg,'=');
%+C             EdAbsAddr(ErrMsg,a2); Ed(ErrMsg," not in Frame(");
%+C             EdAddr(ErrMsg,FrmAdr); EdChar(ErrMsg,'=');
%+C             EdAbsAddr(ErrMsg,a1); MODERR(") -- Fixup Failed");
%+C        endif;
%+C   endif;
end;
%title ***   THEADR / LNAMES / COMENT / LINNUM   ***

Routine THEADR; import ref(OBJMODULE) Mod;
begin Word s; ScanName(s,"ModuleName");
      if Mod.Libx.val <> 0 then Mod.Ident:=s endif;
end; 

Routine LNAMES;
begin Word nam;
%+D   Byte p; p:=TrcBuf.Pos;
      repeat while RecLng > 1
      do
%+D      if TrcBuf.Pos>50 then OutTrace; SetPos(TrcBuf,p) endif;
         nNam.val:=nNam.val+1;
         if nNam.HI >= MxpNam then CAPERR("Name-Table Overflow") endif;
         if NamTab(nNam.HI)=none
         then NamTab(nNam.HI):=NEWOBJ(size(WrdBlock)) endif;
         ScanName(nam,"Name");
         NamTab(nNam.HI).Elt(nNam.LO):=nam;
      endrepeat;
end;

--- NOTE! under OS/2 COMENT fields with CLS 160 are used for dynamic
---       linking. We don't handle that (new EXE hdr format is NOT
---       implemented. Therefore, COMENTs are ALWAYS skipped !!!!!!

%+D Routine COMENT;
%+D begin Unsigned n,NP,NL,CLS;
%+D       InByte(%n%); -- FORMAT: <NP>1<NL>1<-->6 <CLS>8
%+D       NL:=bAND(bSHR(n,6),1); NP:=bAND(bSHR(n,7),1); InByte(%CLS%);
%+D       if TrcSw > 2
%+D       then Ed(TrcBuf," NP:"); EdWrd(TrcBuf,NP);
%+D            Ed(TrcBuf," NL:"); EdWrd(TrcBuf,NL);
%+D            Ed(TrcBuf," CLASS:"); EdWrd(TrcBuf,CLS);
%+D            Ed(TrcBuf," n:"); EdWrd(TrcBuf,n); OutTrace;
%+D       endif;
%+D end;

Routine LINNUM;
begin
      -- ...   MERE SENERE ... ;
      -- ...   MERE SENERE ... ;
end;
%title ***   P U B D E F / E X T D E F   ***
Routine PUBDEF;
begin Word Grpx,Segx,Type,Ident,Ofst; ref(SEGMENT) Seg;
%+D   Word UnUsed; Byte p; p:=TrcBuf.Pos;
      ScanIndex(Grpx,"Grpx"); ScanIndex(Segx,"Segx");
%+D   if Segx.val=0
%+D   then ScanWord(UnUsed,"FrameNumber");
%+D        MODERR("PUBDEF with FrameNumber - Not Supported");
%+D        goto E;
%+D   endif;
      Seg:=SegTab(Segx.HI).Elt(Segx.LO);
      repeat while RecLng > 2
      do
%+D      if TrcBuf.Pos > 40 then OutTrace; SetPos(TrcBuf,p) endif;
         ScanName(Ident,"Name"); ScanWord(Ofst,"Offset");
         ScanIndex(Type,"Type"); DefPUBLIC(Ident,Seg,Ofst.val);
      endrepeat;
%+D E:
end;

Routine DefPUBLIC;
import Word xSmb; ref(SEGMENT) Seg; Unsigned Ofst
begin ref(PUBLIC) Pub; Word modx;
      if PUBREF(xSmb.HI)=none
      then PUBREF(xSmb.HI):=NEWOBJ(size(RefBlock)) endif;
      Pub:=PUBREF(xSmb.HI).elt(xSmb.LO);
      if Pub=none
----- then Pub:=NEWOBJ(Size(PUBLIC)); PUBREF(xSmb.HI).elt(xSmb.LO):=Pub;
      then ALLOC(Pub,  Size(PUBLIC)); PUBREF(xSmb.HI).elt(xSmb.LO):=Pub;
      elsif Pub.Seg=none then nUNDEF:=nUNDEF-1;
      else Ed(ErrMsg,"Public "); EdSymb(ErrMsg,xSmb);
           Ed(ErrMsg," Already Defined in "); modx:=Pub.Seg.Modx;
           EdModid(ErrMsg,MODMAP(modx.HI).Elt(Modx.LO)); MODERR(" ");
      endif;
      Pub.Seg:=Seg; Pub.Ofst:=Ofst;
end;

Routine EXTDEF;
begin Word xSmb,Type; ref(PUBLIC) Pub;
%+D   Byte p; p:=TrcBuf.Pos;
      repeat while RecLng > 2
      do
%+D      if TrcBuf.Pos>40 then OutTrace; SetPos(TrcBuf,p) endif;
         ScanName(xSmb,"Name"); ScanIndex(Type,"Type");
         if PUBREF(xSmb.HI)=none
         then PUBREF(xSmb.HI):=NEWOBJ(size(RefBlock)) endif;
         Pub:=PUBREF(xSmb.HI).elt(xSmb.LO);
         if Pub=none
-----    then Pub:=NEWOBJ(Size(PUBLIC)); Pub.Seg:=none; Pub.Ofst:=0;
         then ALLOC(Pub,  Size(PUBLIC)); Pub.Seg:=none; Pub.Ofst:=0;
              PUBREF(xSmb.HI).Elt(xSmb.LO):=Pub; nUNDEF:=nUNDEF+1;
         endif;
         nExt.val:=nExt.val+1;
         if nExt.HI >= MxpExt then CAPERR("Extern-Table Overflow") endif;
         if ExtTab(nExt.HI)=none
         then ExtTab(nExt.HI):=NEWOBJ(size(WrdBlock)) endif;
         ExtTab(nExt.HI).Elt(nExt.LO):=xSmb;
      endrepeat;
end;
%title ***   G R P D E F   ***

Routine GRPDEF;
begin Byte n; Word Ident,Grpx,Segx;
      ref(GROUP) Grp; ref(SEGMENT) Seg; ref(FRAME) Frm,x;
%+D   Byte p; p:=TrcBuf.Pos;
      ScanIndex(Grpx,"GrpNamx");
      Ident:=NamTab(Grpx.HI).Elt(Grpx.LO);
      Grp:=FindGROUP(Ident);
%+D   if TrcSw > 2 then ShowGrp(Grp) endif;
      repeat while RecLng > 2
      do
%+D      if TrcBuf.Pos>40 then OutTrace; SetPos(TrcBuf,p) endif;
         InByte(%n%); ScanIndex(Segx,"Segx");
         Seg:=SegTab(Segx.HI).Elt(Segx.LO);
         Frm:=FindFRAME(Seg.Ident);
         if Frm.Grp <> Grp
         then if Frm.Grp <> none
              then MODERR("Frame already part of another Group")
              else Frm.Grp:=Grp; x:=Grp.Frm;
                   if x=none then Grp.Frm:=Frm
                   else repeat while x.GrpLnk <> none 
                        do x:=x.GrpLnk endrepeat;
                        x.GrpLnk:=Frm;
                   endif;
              endif;
         endif;
      endrepeat;
%+D   if TrcSw > 2 then ShowGrp(Grp) endif;
      nLgr.val:=nLgr.val+1;
      if nLgr.HI >= MxpLgr then CAPERR("Local Group-Table Overflow") endif;
      if LgrTab(nLgr.HI)=none
      then LgrTab(nLgr.HI):=NEWOBJ(size(RefBlock)) endif;
      LgrTab(nLgr.HI).Elt(nLgr.LO):=Grp;
end;

%title ***   S E G D E F  ***

Routine SEGDEF;
begin ref(SEGMENT) Seg; Byte n,A,C,B,PP,LTL; infix(String) s;
      Word FrameNumber,Ofst,MaxLng,SegLng,Class,SegNamx,ClassNamx,OvlNamx;
%+D   Byte p; p:=TrcBuf.Pos;
      InByte(%n%); -- FORMAT: <A>3<C>3<B>1<P>1
%+D   PP:=bAND(n,1);          B:=bAND(bSHR(n,1),1); C:=bAND(bSHR(n,2),7);
      A:=bAND(bSHR(n,5),7);
%+D   if TrcSw > 2
%+D   then Ed(TrcBuf," A:"); EdWrd(TrcBuf,A);
%+D        Ed(TrcBuf," C:"); EdWrd(TrcBuf,C);
%+D        Ed(TrcBuf," B:"); EdWrd(TrcBuf,B);
%+D        Ed(TrcBuf," P:"); EdWrd(TrcBuf,PP);
%+D        OutTrace; SetPos(TrcBuf,p);
%+D   endif;
      if (A=0) or (A=5)
      then ScanWord(FrameNumber,"FrameNumber"); ScanByte(n,"Offset");
      elsif A=6
      then ScanByte(LTL,"LTL"); ScanWord(MaxLng,"MaxSegLength");
           ScanWord(Ofst,"GroupOffset");
      endif;
      ScanWord(SegLng,"SegLength");
      if RecLng>1
      then ScanIndex(SegNamx,"SegNamx");
           if RecLng>1 then ScanIndex(ClassNamx,"ClassNamx") endif;
           if RecLng>1 then ScanIndex(OvlNamx,"OvlNamx") endif;
      endif;
      nSeg.val:=nSeg.val+1;
      if nSeg.HI >= MxpSeg then CAPERR("Segment-Table Overflow") endif;
      if SegTab(nSeg.HI)=none
      then SegTab(nSeg.HI):=NEWOBJ(size(RefBlock)) endif;
----- Seg:=NEWOBJ(Size(SEGMENT)); SegTab(nSeg.HI).Elt(nSeg.LO):=Seg;
      ALLOC(Seg,  Size(SEGMENT)); SegTab(nSeg.HI).Elt(nSeg.LO):=Seg;
      Seg.Ident:=NamTab(SegNamx.HI).Elt(SegNamx.LO); Seg.Align:=A;
      Seg.Length:=SegLng.val; Seg.Filled:=0; Seg.Modx:=nMod;
      Seg.Frm:=none; Seg.Suc:=none; Seg.First:=none; Seg.Last:=none; 
      Class:=NamTab(ClassNamx.HI).Elt(ClassNamx.LO);
      if Class=sSTACK then Seg.cType:=cSTACK
      else editSymb(     Class); FASTUP(s);
           if s.nchr < 4 then Seg.cType:=cDATA
           else s.chradr:=name(var(s.chradr)(s.nchr-4)); s.nchr:=4;
                if SEQ(s,"CODE")
                then editSymb(     Seg.Ident); FASTUP(s);
                     if s.nchr < 4 then Seg.cType:=cCODE
                     else s.chradr:=name(var(s.chradr)(s.nchr-4));
                          s.nchr:=4;
                          Seg.cType:=if SEQ(s,"LINE") then cLINE else cCODE;
                     endif;
                else Seg.cType:=cDATA endif;
           endif;
      endif;
end;

%title ***   L I D A T A / L E D A T A  ***
Routine ScanBlock; import Unsigned Rep,Ofst;
begin Unsigned n,p; Word cnt,nBlk; Ref(DATABLK) Blk;
%+D   if TrcSw > 2 then OutTrace; SetPos(TrcBuf,18) endif;
      ScanWord(cnt,"RepCount"); Rep:=Rep*cnt.val; ScanWord(nBlk,"BlkCount");
      if nBlk.val = 0
      then if RecLng < 2 then MODERR("ScanBlock-1"); goto E endif;
           InByte(%n%);
           Blk:=ScanData(n); Blk.Ofst:=Ofst;
           n:=p:=Blk.Lng;
           repeat Rep:=Rep-1 while Rep > 0
           do if (p+n)>1024 then MODERR("Text Block Too Large"); Rep:=0;
              else APX_SMOVEI(n,@Blk.chr(p),@Blk.chr); p:=p+n endif;
           endrepeat;
           Blk.Lng:=p;
%+D        if TrcSw > 3 then ShowBlk(Blk) endif;
           if Blk.Lng+Blk.Ofst > CurSeg.Length
           then MODERR("Text Larger than Segment") endif;
           ChainBlock(Blk);
      else repeat while nBlk.val>0
           do ScanBlock(Rep,Ofst); nBlk.val:=nBlk.val-1 endrepeat;
      endif;
E:end;

Routine LIDATA;
begin Word Segx,Ofst;
      ScanIndex(Segx,"Segx"); ScanWord(Ofst,"Offset");
      CurSeg:=CurMod.SegTab.Elt(Segx.val-1); CurFrm:=CurSeg.Frm;
      repeat while RecLng > 2 do ScanBlock(1,Ofst.val) endrepeat;
end;

Routine LEDATA;
begin Word Segx,Ofst; ref(DATABLK) Blk;
%+D   Byte p; p:=TrcBuf.Pos;
      ScanIndex(Segx,"Segx"); ScanWord(Ofst,"Offset");
%+D   if TrcSw > 2 then OutTrace; SetPos(TrcBuf,p) endif;
      CurSeg:=CurMod.SegTab.Elt(Segx.val-1); CurFrm:=CurSeg.Frm;
      Blk:=ScanData(RecLng-1); Blk.Ofst:=Ofst.val;
      if Blk.Lng+Ofst.val > CurSeg.Length
      then MODERR("Text Larger than Segment") endif;
      ChainBlock(Blk); CurBlk:=Blk;
end;
%title ***   D A T A B L K   ***
Routine OutputBlock; import ref(DATABLK) Blk;
begin Unsigned Handle; Unsigned n; ref(DATABLK) x;
      ref(BANK) Bnk; ref(FRAME) Frm; Integer SegPos,FilPos,Loc,Org;
      Frm:=CurSeg.Frm;
%+C   if Frm = none then MODERR("OutputBlock-1"); goto E1 endif;
      Bnk:=Frm.Bnk;
%+C   if Bnk = none then MODERR("OutputBlock-2"); goto E2 endif;
      Handle:=Bnk.Handle; SegPos:=Bnk.BnkDsc.TxtPos+EAddr(CurSeg.Start);
      if Handle <> ExeFile
      then Org:=Bnk.BnkDsc.MemBase.val;
           Org:=Org*16; SegPos:=SegPos-Org;
      endif;
%+C   if Handle=0 then MODERR("OutputBlock-3"); goto E3 endif;
%+D   if TrcSw > 1
%+D   then BegTrace("OutputBlock: Handle="); EdWrd(TrcBuf,Handle);
%+D        Ed(TrcBuf,", Segment "); EdSymb(TrcBuf,CurSeg.Ident);
%+D        Ed(TrcBuf,", SegmentFilePos="); EdInt(TrcBuf,SegPos);
%+D        Ed(TrcBuf,", Filled="); EdInt(TrcBuf,CurSeg.Filled); OutTrace
%+D        if TrcSw > 4 then ShowBlk(Blk) endif;
%+D   endif;
      x:=Blk; repeat while x.Prd <> none do x:=x.Prd endrepeat;
      repeat writeBlock(handle, segpos+x.ofst, x.Lng, @x.Image);
             CurSeg.Filled:=CurSeg.Filled+x.Lng;
             --- Chain DATABLK to Free List ---
             x.Prd:=FreeBlk; FreeBlk:=x;
      while x <> Blk do x:=x.Suc endrepeat;
      if Blk.Suc <> none then CurSeg.First:=Blk.Suc; Blk.Suc.Prd:=none
      else CurSeg.First:=none; CurSeg.Last:=none endif;
%+C E1:E2:E3:
end;

Routine ChainBlock; import ref(DATABLK) Blk;
begin ref(DATABLK) x,y; Unsigned OfsChk;
      x:=CurSeg.Last;
      if x=none then OfsChk:=0; CurSeg.First:=Blk
      else OfsChk:=x.Ofst+x.Lng; x.Suc:=Blk; Blk.Prd:=x;
           if x.Prd <> none then OutputBlock(x.Prd) endif;
      endif;
      CurSeg.Last:=Blk;
      if Blk.Ofst <> OfsChk
      then MODERR("Text is not Compact Monotone Increasing") endif;
end;
%title ***   F I X U P P  ***
Routine FIXUPP;
begin Byte n,M,S,D,Z,Thx,Fld; infix(MemAddr) adr; Word UnUsed,Pos;
%+D   Unsigned OldTrc;
%+D   OldTrc:=TrcSw; if TrcSw < 4 then TrcSw:=0 endif;
      repeat while RecLng > 1
      do inByte(%n%);
         if n < 128
         then adr.Ofst.val:=0;                             --- THREAD ---;
              -- FORMAT: n=<+0>1<D>1<Z>1<METHOD>3<THRED>2
              Thx:=bAND(n,3);
              adr.Kind:=bAND(bSHR(n,2),7);
              Z:=bAND(bSHR(n,5),1);
              D:=bAND(bSHR(n,6),1);
%+D           if TrcSw > 3
%+D           then OutTrace; SetPos(TrcBuf,10);
%+D                Ed(TrcBuf,"THREAD D:");  EdWrd(TrcBuf,D);
%+D                Ed(TrcBuf," Z:");        EdWrd(TrcBuf,Z);
%+D                Ed(TrcBuf," METHOD:");   EdWrd(TrcBuf,adr.Kind);
%+D                Ed(TrcBuf," THRED:");    EdWrd(TrcBuf,Thx);
%+D           endif;
              if D*adr.Kind < 4
              then if RecLng < 2 then MODERR("THREAD-1"); goto E1 endif;
                   case 0:3 (adr.Kind)
                   when SegAddr: ScanIndex(adr.Segx,"Segx")
                   when GrpAddr: ScanIndex(adr.Grpx,"Grpx")
                   when ExtAddr: ScanIndex(adr.Extx,"Extx")
                   otherwise ERROR("FIXUP with FrameNumber -- Not supported");
                             ScanWord(UnUsed,"FrameNumber");
                   endcase;
              endif;
              if D=1 then ImpFrame(Thx):=adr
                     else ImpTarget(Thx):=adr endif;
         else                                            --- FIXUPP ---;
              if RecLng<2 then MODERR("FIXUPP"); goto E2 endif;
              -- FORMAT: n=<+1>1<M>1<S>1<LOC>3<OFFSET-HI>2 <OFFSET-LO>8
              Pos.HI:=bAND(n,3); InByte(%Pos.LO%);
              Fld:=bAND(bSHR(n,2),7);
              S:=bAND(bSHR(n,5),1);
              M:=bAND(bSHR(n,6),1);
              adr:=ScanLogicalAddr;
%+D           if TrcSw > 3
%+D           then OutTrace; SetPos(TrcBuf,10);
%+D                Ed(TrcBuf,"FIXUPP M:");  EdWrd(TrcBuf,M);
%+D                Ed(TrcBuf," S:");        EdWrd(TrcBuf,S);
%+D                Ed(TrcBuf," Fld:");      EdWrd(TrcBuf,Fld);
%+D                Ed(TrcBuf," OFFSET:");   EdWrd(TrcBuf,Pos.val);
%+D                OutTrace; SetPos(TrcBuf,10);
%+D                if    Fld=fLOBYTE  then Ed(TrcBuf,"LowByte(")
%+D                elsif Fld=fOFFSET  then Ed(TrcBuf,"Offset(")
%+D                elsif Fld=fBASE    then Ed(TrcBuf,"Base(")
%+D                elsif Fld=fPOINTER then Ed(TrcBuf,"Pointer(")
%+D                elsif Fld=fHIBYTE  then Ed(TrcBuf,"HighByte(")
%+D                else  Ed(TrcBuf,"????(") endif;
%+D                EdSymb(TrcBuf,CurSeg.Ident); EdChar(TrcBuf,'+');
%+D                EdWrd(TrcBuf,CurBlk.Ofst+Pos.val); Ed(TrcBuf,")  <= ");
%+D                if M=0 then Ed(TrcBuf,"Self")
%+D                       else Ed(TrcBuf,"Segm") endif;
%+D                Ed(TrcBuf,"Rel <=  "); EdAddr(TrcBuf,adr);
%+D                EdChar(TrcBuf,'='); EdAbsAddr(TrcBuf,Mem2AbsAddr(adr));
%+D           endif;
              if M=0 then SelfReloc(Pos.val,Fld,adr)
                     else SegmReloc(Pos.val,Fld,adr) endif;
         endif;
      endrepeat;
E1:E2:
%+D   TrcSw:=OldTrc;
end;


Routine SelfReloc; import Unsigned Pos; Byte Fld; infix(MemAddr) adx;
begin ref(WORDTYPE) x,ins; Dword adr;
      if Fld <> fOFFSET
      then MODERR("Illegal Self Relocation"); goto E endif;
      adr:=Mem2AbsAddr(adx); x:=Name2Ref(name(CurBlk.Image(Pos)));
%+C   if Pos > 0 then ins:=Name2Ref(name(CurBlk.Image(Pos-1)))
%+C   else ins:=Name2Ref(name(CurBlk.Prd.Image(CurBlk.Prd.Lng-1))) endif
%+C   if ins.AsByte=iJMP then elsif ins.AsByte=iCALL then -- OK
%+C   else MODERR("Illegal Self-Relocation") endif;
      if (adr.val <> 0) and (adr.Segm <> CurFrm.Start.Segm)
      then Ed(ErrMsg,"Near JUMP/CALL "); EdAddr(ErrMsg,adx);
           EdChar(ErrMsg,'='); EdAbsAddr(ErrMsg,adr);
           MODERR(" is out of range");
      endif;
%+D   if TrcSw > 1
%+D   then BegTrace("Offset: "); EdWrd(TrcBuf,x.AsWord); OutTrace endif;
      x.AsWord:=(x.AsWord+adr.Ofst.val)
                         -(CurSeg.Start.Ofst.val+CurBlk.Ofst+Pos+2);
%+D   if TrcSw > 1
%+D   then BegTrace("Disp: "); EdWrd(TrcBuf,x.AsWord); OutTrace endif;
E:end;
%page

Routine SegmReloc; import Unsigned Pos; Byte Fld; infix(MemAddr) adx;
begin ref(DWORDTYPE) x,ins; Word xSmb;
      ref(BANK) Bnk; Dword adr;
      adr:=Mem2AbsAddr(adx); x:=Name2Ref(name(CurBlk.Image(Pos)));
      case 0:4 (Fld)
      when fLOBYTE:  x.AsByte:=x.AsByte+wAND(adr.Ofst.val,255);
      when fHIBYTE:  x.AsByte:=x.AsByte+wAND(wSHR(adr.Ofst.val,8),255);
      when fOFFSET:  x.AsWord.val:=x.AsWord.val+adr.Ofst.val;
%+D        if TrcSw > 1
%+D        then BegTrace("Offset: ");
%+D             EdWrd(TrcBuf,x.AsWord.val); OutTrace;
%+D        endif;
      when fBASE:
           if x.AsWord.val <> 0 then
           WARNING("Constant ignored in External Base Relocation") endif
           x.AsWord:=adr.Segm;
%+D        if TrcSw > 1
%+D        then BegTrace("Base: ");
%+D             EdWrd(TrcBuf,x.AsWord.val); OutTrace;
%+D        endif;
           PutRel(CurSeg.Start.Ofst.val+CurBlk.Ofst+Pos);
      when fPOINTER:
           if x.AsWord(1).val <> 0 then
           WARNING("Constant ignored in External Pointer Relocation")
           endif;
           adr.Ofst.val:=adr.Ofst.val+x.AsWord.val;
%+D        if TrcSw > 1
%+D        then BegTrace("POINTER Relocation: "); EdAbsAddr(TrcBuf,adr);
%+D             EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D             EdChar(TrcBuf,'[');
%+D             EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D             Ed(TrcBuf,"] in "); EdSymb(TrcBuf,CurFrm.Ident);
%+D             EdChar(TrcBuf,'['); EdSymb(TrcBuf,CurFrm.Bnk.Ident);
%+D             if    CurFrm.cType=cSTACK then Ed(TrcBuf,"]:STACK")
%+D             elsif CurFrm.cType=cDATA  then Ed(TrcBuf,"]:DATA")
%+D             elsif CurFrm.cType=cCODE  then Ed(TrcBuf,"]:CODE")
%+D             else Ed(TrcBuf,"]:"); EdWrd(TrcBuf,CurFrm.cType) endif;
%+D             OutTrace;
%+D        endif;
           if mergeLinbnk then goto L0 endif; -- leave instructions - no banking
           if CurFrm.cType <> cCODE then goto L1 endif;
           if Pos > 0 then ins:=Name2Ref(name(CurBlk.Image(Pos-1)))
           else if CurBlk.Prd=none then goto L2 endif;
                ins:=Name2Ref(name(CurBlk.Prd.Image(CurBlk.Prd.Lng-1)));
           endif;
           if    ins.AsByte=iJMPF
           then if adx.Kind <> ExtAddr then xSmb.val:=0
                else xSmb:=CurMod.ExtTab.Elt(adx.Extx.val-1) endif;
                if xSmb=sEGOTO
                then
                -------------------------------------------------------
                -- GOTO Evaluated Label:    BX:AX = Address          --
                -- i-Code:  iJMPF  <ofst>2<segm>2+fPOINTER(E@GOTO)   --
                --   ===>   iINT  xGOTO  iNOP  iNOP  iNOP            --
                -------------------------------------------------------
                     ins.AsByte:=iINT; x.AsByte(0):=xGOTO;
                     x.AsByte(1):=iNOP; x.AsByte(2):=iNOP;
                     x.AsByte(3):=iNOP;
%+D                  if AtrSw > 0
%+D                  then BegTrace("JMPF "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xGOTO,2)
%+D                       Ed(TrcBuf," NOP NOP NOP"); OutTrace;
%+D                  endif;
                else
                -------------------------------------------------------
                -- GOTO Visible Label:                               --
                -- i-Code:  iJMPF  <ofst>2<segm>2+fPOINTER(adr)      --
                --   ===>   iINT  xJMPF  frmx  <offset>2             --
                -------------------------------------------------------
                     Bnk:=FrmTab(adr.Segm.LO).Bnk;
                     if (Bnk=RotBnk) or (Bnk=CurFrm.Bnk)
                     then
%+D                       if TrcSw > 1
%+D                       then BegTrace("JMPF "); EdAbsAddr(TrcBuf,adr);
%+D                            EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                            EdChar(TrcBuf,'[');
%+D                            EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident)
%+D                            Ed(TrcBuf,"] is not changed");
%+D                            OutTrace;
%+D                       endif;
                          goto L3; -- Keep instruction as it is !!!
                     endif;
                     ins.AsByte:=iINT; x.AsByte(0):=xJMPF;
                     x.AsByte(1):=adr.Segm.LO; x.AsWord(1):=adr.Ofst;
%+D                  if AtrSw > 0
%+D                  then BegTrace("JMPF "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xJMPF,2)
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Segm.LO,2);
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Ofst.val,4)
%+D                       OutTrace;
%+D                  endif;
                endif;
                goto E1;
           elsif ins.AsByte=iCALLF
           then if adx.Kind <> ExtAddr then xSmb.val:=0
                else xSmb:=CurMod.ExtTab.Elt(adx.Extx.val-1) endif;
                if xSmb=sECALL
                ------------------------------------------------------
                -- CALL Evaluated Routine:  BX:AX = Address         --
                -- i-Code: iCALLF <ofst>2<segm>2+fPOINTER(E@CALL)   --
                --   ===>  iINT  xCALL  iNOP  iNOP  iNOP            --
                ------------------------------------------------------
                then ins.AsByte:=iINT; x.AsByte(0):=xCALL;
                     x.AsByte(1):=iNOP; x.AsByte(2):=iNOP;
                     x.AsByte(3):=iNOP;
%+D                  if TrcSw > 0
%+D                  then BegTrace("CALL "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xCALL,2)
%+D                       Ed(TrcBuf," NOP NOP NOP"); OutTrace;
%+D                  endif;
                else
                ------------------------------------------------------
                -- CALL Visible Routine:                            --
                -- i-Code:  iCALL  <ofst>2<segm>2+fPOINTER(adr)     --
                --   ===>   iINT  xCALF  frmx  <offset>2            --
                ------------------------------------------------------
                     Bnk:=FrmTab(adr.Segm.LO).Bnk;
                     if (Bnk=RotBnk) or (Bnk=CurFrm.Bnk)
                     then
%+D                       if AtrSw > 0
%+D                       then BegTrace("CALL "); EdAbsAddr(TrcBuf,adr);
%+D                            EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                            EdChar(TrcBuf,'[');
%+D                            EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident)
%+D                            Ed(TrcBuf,"] is not changed");
%+D                            OutTrace;
%+D                       endif;
                          goto L4; -- Keep instruction as it is !!!
                     endif;
                     if EAddr(Bnk.Start)
                     < (EAddr(CurFrm.bnk.Start)+CurFrm.Bnk.Length)
                     then Ed(ErrMsg,"CALL "); EdAbsAddr(ErrMsg,adr);
                          EdChar(ErrMsg,'='); EdAddr(ErrMsg,adx);
                          EdChar(ErrMsg,'[');
                          EdSymb(ErrMsg,FrmTab(adr.Segm.LO).Bnk.Ident);
                          Ed(ErrMsg,"] Will Swap out ");
                          EdSymb(ErrMsg,CurFrm.Bnk.Ident);
                          WARNING(" "); SetPos(ErrMsg,16);
                          Ed(ErrMsg,"Routine Return may FAIL !");
                          PrintOut(ErrMsg);
                     endif;
                     ins.AsByte:=iINT; x.AsByte(0):=xCALF;
                     x.AsByte(1):=adr.Segm.LO; x.AsWord(1):=adr.Ofst;
%+D                  if AtrSw > 0
%+D                  then BegTrace("CALL "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xCALF,2)
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Segm.LO,2);
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Ofst.val,4)
%+D                       OutTrace;
%+D                  endif;
                endif;
                goto E2;
%+C        else Ed(ErrMsg,"Unrecognized Instruction: ");
%+C             EdHex(ErrMsg,ins.AsByte,2); Ed(ErrMsg,"H ");
%+C             EdAbsAddr(ErrMsg,adr); WARNING(" -- Not Treated");
           endif;
L0:L1:L2:L3:L4: x.AsWord:=adr.Ofst; x.AsWord(1):=adr.Segm;
%+D        if TrcSw > 1
%+D        then BegTrace("Base:"); EdWrd(TrcBuf,x.AsWord(1).val);
%+D             Ed(TrcBuf,", Offset:"); EdWrd(TrcBuf,x.AsWord.val); OutTrace
%+D        endif;
           PutRel(CurSeg.Start.Ofst.val+CurBlk.Ofst+Pos+2);
      endcase;
E1:E2:end;



Routine PutRel; import Unsigned Ofst;
begin ref(RELOBLK) Blk,x; Unsigned nRel;
      Blk:=CurFrm.RelBlk;
----- if Blk=none then Blk:=NEWOBJ(Size(RELOBLK)); Blk.nRel:=0 endif;
      if Blk=none then ALLOC(Blk,  Size(RELOBLK)); Blk.nRel:=0 endif;
      nRel:=Blk.nRel;
      if nRel>=254
----- then x:=NEWOBJ(Size(RELOBLK)); x.nRel:=0;
      then ALLOC(x,  Size(RELOBLK)); x.nRel:=0;
           x.Suc:=Blk; Blk:=x; nRel:=0;
      endif
      Blk.RELTAB(nRel).val:=Ofst; Blk.nRel:=nRel+1; CurFrm.RelBlk:=Blk;
%+D   if TrcSw > 1
%+D   then BegTrace("PutRel: "); EdWrd(TrcBuf,Ofst);
%+D        -- ... ... ...
%+D        -- ... ... ...
%+D        -- ... ... ...
%+D        OutTrace;
%+D   endif;

end;

%title ***    S  C  A  N  N  E  R    ***
Routine SCANNER; import ref(OBJMODULE) Mod
begin Word w;
%-D   Byte RecTyp;                    -- Current Record Type
%+D   Integer TRCPOS;
%+D   if (AtrSw+TrcSw) > 1
%+D   then Ed(TrcBuf,"SCAN: "); EdModid(TrcBuf,Mod); OutTrace endif;

%+D   BytPos:=0;            -- Relative Input Byte number
%+D   RecPos:=0;            -- Relative Input Byte number
      RecLng:=0;            -- Length of current record
%+D   ChkSum:=0;            -- Check-sum of current record
      RecTyp:=0;            -- Current Record Code
      nNam.val:=0; nSeg.val:=0; nLgr.val:=0; nExt.val:=0;
%+D   TRCPOS:=if LN1MOD=Mod.Ident then LN1POS else 0;
      InitObjCode;
N01:    N03:N04:    N06:N07:N08:
      if RecLng > 0 then skipRecord endif;
%+D   if ChkSum <> 0 then MODERR("Check-Sum Error") endif; ChkSum:=0;
%+D   if TrcSw > 2 then OutTrace endif;
    N02:        N05:
%+D   InByte(%RecTyp%);
%-D   if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
%-D   RecTyp:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
      if EndFile then goto FIN1 endif;

%+D   if TRCPOS <> 0
%+D   then if BytPos >= TRCPOS
%+D        then if LN1TRC=0 then TrcSw:=0; TRCPOS:=0
%+D             else TrcSw:=LN1TRC; 
%+D                  LN1TRC:=0; TRCPOS:=TRCPOS+LN1CNT;
%+D             endif;
%+D        endif;
%+D   endif;
%+D   RecPos:=BytPos;
%+D   InByte(%w.LO%); InByte(%w.HI%);
%-D   w.LO:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   w.HI:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
      RecLng:=w.val;
%+D   if TrcSw > 2
%+D   then EdInt(TrcBuf,RecPos); Ed(TrcBuf,": ");
%+D        EdRecType(TrcBuf,RecTyp);
%+D        EdChar(TrcBuf,'='); EdHex(TrcBuf,RecTyp,2);
%+D        Ed(TrcBuf,"H Lng:"); EdWrd(TrcBuf,RecLng);
%+D   endif;
      case 0:255 (RecTyp)
      when  156,                          -- FIXUPP treated by LOADER
            160,                          -- LEDATA treated by LOADER
            162,                          -- LIDATA treated by LOADER
            148: skiprecord;  goto N05;   -- LINNUM treated by LOADER
      when  128: THEADR(Mod); goto N01;
      when  136:
%+D              COMENT;
                 skiprecord;  goto N02;
      when  140: EXTDEF;      goto N03;
      when  144: PUBDEF;      goto N04;
      when  150: LNAMES;      goto N06;
      when  152: SEGDEF;      goto N07;
      when  154: GRPDEF;      goto N08;
      when  138: skiprecord;  goto FIN2;  -- MODEND  treated by LOADER
      otherwise MODERR("Unknown record type"); 
                TERMIN(3,"Linker Terminated in Pass 1");
      endcase;

FIN1:FIN2:
      Mod.SegTab:=NewRefVector(nSeg.val); Mod.SegTab.nElt:=nSeg.val;
      repeat while nSeg.val > 0
      do Mod.SegTab.Elt(nSeg.val-1):=SegTab(nSeg.HI).Elt(nSeg.LO);
         nSeg.val:=nSeg.val-1;
      endrepeat
      Mod.LgrTab:=NewRefVector(nLgr.val); Mod.LgrTab.nElt:=nLgr.val;
      repeat while nLgr.val > 0
      do Mod.LgrTab.Elt(nLgr.val-1):=LgrTab(nLgr.HI).Elt(nLgr.LO);
         nLgr.val:=nLgr.val-1;
      endrepeat
      Mod.ExtTab:=NewWrdVector(nExt.val); Mod.ExtTab.nElt:=nExt.val;
      repeat while nExt.val > 0
      do Mod.ExtTab.Elt(nExt.val-1):=ExtTab(nExt.HI).Elt(nExt.LO);
         nExt.val:=nExt.val-1;
      endrepeat
%+D   if (AtrSw+TrcSw) > 0
%+D   then Ed(TrcBuf,"END SCAN: "); EdModid(TrcBuf,Mod);
%+D        Ed(TrcBuf,"  --  Bytes "); EdInt(TrcBuf,BytPos-1); OutTrace;
%+D   endif;
end;
%title ***    L  O  A  D  E  R    ***
Routine LOADER; import ref(OBJMODULE) Mod;
begin Unsigned i,x; Word xSmb,w; infix(string) F;
%-D   Byte RecTyp;                    -- Current Record Type
      ref(SEGMENT) Seg; ref(FRAME) Frm; ref(PUBLIC) Pub;
%+D   Integer TRCPOS;
%+D   if (AtrSw+TrcSw) > 0
%+D   then Ed(TrcBuf,"LOAD: "); EdModid(TrcBuf,Mod); OutTrace endif;
      --- Check Matching of External References ---
      i:=0; repeat while i < Mod.ExtTab.nElt
      do xSmb:=Mod.ExtTab.Elt(i); Pub:=PUBREF(xSmb.HI).Elt(xSmb.LO);
         if Pub.Seg = none then if xSmb <> sBNKTAB
         then Ed(ErrMsg,"Undefined External ");
              EdSymb(ErrMsg,xSmb); Ed(ErrMsg," Referenced from ");
              EdModid(ErrMsg,Mod); ERROR(" ");
         endif; endif;
         i:=i+1;
      endrepeat;
      --- Match Dummy Segments ---
      i:=0; repeat while i < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(i); i:=i+1;
         if Seg.Frm = none
         then Frm:=FindFRAME(Seg.Ident);
              Seg.Frm:=Frm; Seg.Start:=Frm.Start;
         endif;
      endrepeat;

%+D   BytPos:=0;            -- Relative Input Byte number
%+D   RecPos:=0;            -- Relative Input Byte number
      RecLng:=0;            -- Length of current record
%+D   ChkSum:=0;            -- Check-sum of current record
      RecTyp:=0;            -- Current Record Code
%+D   TRCPOS:=if LN2MOD=Mod.Ident then LN2POS else 0;
      CurMod:=Mod; InitObjCode;
N05:N09:N10:N11:
      if RecLng > 0 then skipRecord endif;
%+D   if ChkSum <> 0 then MODERR("Check-Sum Error") endif; ChkSum:=0;
%+D   if TrcSw > 2 then OutTrace endif;
N01:
%+D   InByte(%RecTyp%);
%-D   if CBUF.nxt >= (BufLng-2) then InCbuffer endif;
%-D   RecTyp:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
      if EndFile then goto FIN1 endif;
%+D   if TRCPOS <> 0
%+D   then if BytPos >= TRCPOS
%+D        then if LN2TRC=0 then TrcSw:=0; TRCPOS:=0
%+D             else TrcSw:=LN2TRC; 
%+D                  LN2TRC:=0; TRCPOS:=TRCPOS+LN2CNT;
%+D             endif;
%+D        endif;
%+D   endif;
%+D   RecPos:=BytPos;
%+D   InByte(%w.LO%); InByte(%w.HI%);
%-D   w.LO:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   w.HI:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
      RecLng:=w.val;
%+D   if TrcSw > 2
%+D   then EdInt(TrcBuf,RecPos); Ed(TrcBuf,": ");
%+D        EdRecType(TrcBuf,RecTyp);
%+D        EdChar(TrcBuf,'='); EdHex(TrcBuf,RecTyp,2);
%+D        Ed(TrcBuf,"H Lng:"); EdWrd(TrcBuf,RecLng);
%+D   endif;

      case 0:255 (RecTyp)
      when 128,                        -- THEADR  treated by SCANNER
           136,                        -- COMENT  treated by SCANNER
           140,                        -- EXTDEF  treated by SCANNER
           144,                        -- PUBDEF  treated by SCANNER
           150,                        -- LNAMES  treated by SCANNER
           152,                        -- SEGDEF  treated by SCANNER
           154: skiprecord; goto N01;  -- GRPDEF  treated by SCANNER
      when 148: LINNUM;     goto N05;
      when 156: FIXUPP;     goto N09;
      when 160: LEDATA;     goto N10;
      when 162: LIDATA;     goto N11;
      when 138: MODEND;     goto FIN2;
      otherwise MODERR("Unknown record type"); 
                TERMIN(3,"Linker Terminated in Pass 2");
      endcase;

FIN1:FIN2:
      --- Terminate Output of all Segments ---
      i:=0; repeat while i < Mod.SegTab.nElt
      do CurSeg:=Mod.SegTab.Elt(i); i:=i+1;
         if CurSeg.Last <> none
         then CurFrm:=CurSeg.Frm; OutputBlock(CurSeg.Last) endif;
%+D      if CurSeg.Filled <> CurSeg.Length
%+D      then Ed(ErrMsg,"Segment "); EdSymb(ErrMsg,CurSeg.Ident);
%+D           Ed(ErrMsg,"(Filled="); EdWrd(ErrMsg,CurSeg.Filled);
%+D           Ed(ErrMsg,",Lng="); EdWrd(ErrMsg,CurSeg.Length);
%+D           WARNING(") Contains Uninitalized Data");
%+D      endif;
      endrepeat; 
%+D   if (AtrSw+TrcSw) > 0
%+D   then Ed(TrcBuf,"END LOAD: "); EdModid(TrcBuf,Mod);
%+D        Ed(TrcBuf,"  --  Bytes "); EdInt(TrcBuf,BytPos-1); OutTrace;
%+D   endif;
      CurMod:=none;
end;
%title ***    M  O  D  E  N  D    ***

Routine MODEND;
begin Byte n,Mattr,L;
%+D   Word UnUsed;
      InByte(%n%); -- FORMAT: <Mattr>2<-->5<L>1
      Mattr:=bAND(bSHR(n,6),3); L:=bAND(n,1);
      if (Mattr=1) or (Mattr=3)
      then --- Start Address ---;
           StartMod:=CurMod;
           if L=1 then StartAddr:=ScanLogicalAddr
%+D        else if RecLng<5 then MODERR("MODEND"); goto E endif;
%+D             ScanWord(UnUsed,"FrameNumber"); ScanWord(UnUsed,"Offset");
           endif;
      endif;
%+D   E:if TrcSw > 2
%+D   then Ed(TrcBuf," ModuleType:"); EdWrd(TrcBuf,Mattr);
%+D        Ed(TrcBuf," L:"); EdWrd(TrcBuf,L);
%+D        if StartMod=CurMod then if StartAddr.Kind <> NoAddr
%+D        then OutTrace; SetPos(TrcBuf,18);
%+D             Ed(TrcBuf,"Start Address: "); EdAddr(TrcBuf,StartAddr);
%+D        endif endif;
%+D   endif;
end;
%title ***  L I B R A R Y   S E A R C H I N G  ***
Routine LibrarySearch;
begin Unsigned nModBefore,nBlk,n,lng,p; Word libx,smbx,modx;
      ref(LIBRARY) Lib; Word EltRef; Integer FilPos,Loc; Character c;
      ref(PUBLIC) Pub; ref(OBJMODULE) Mod; infix(String) s;
      ref(LibBuffer) LBuf; unsigned nBuf,lbl;
AGAIN: nModBefore:=nMod.val; libx.val:=0; nBuf:=0;
      repeat while libx.val < nLib.val
      do libx.val:=libx.val+1; Lib:=LIBMAP(libx.HI).Elt(libx.LO);
         nBlk:=Lib.nBlk.val;
%+D      if TrcSw > 0
%+D      then OutTrace; Ed(TrcBuf,"SEARCH LIBRARY: ");
%+D           EdSymb(TrcBuf,Lib.Ident); OutTrace; EdLib(TrcBuf,Lib);
%+D      endif;
         Inpt:=Open(Lib.Ident,".lib",accread);
         if EndFile then OpenErr(Lib.Ident) endif;
         --- Locate First Dictionary Block ---
         LOCATE(Inpt,0,Lib.BlkRef.val,Loc);
         if OsStat <> 0 then ERROR("FileTail-1"); OsStat:=0 endif;
         Repeat while nBlk <> 0
         do --- Read Next Dictionary Block ---
            if nBuf=0
---         then READ(Inpt,512,@CBUF.chr,n);
            then if nBlk >= 8 then nbuf:=8; lbl:=BufLng
                 else nBuf:=nBlk; lbl:=nBuf*512 endif;
                 READ(Inpt,lbl,@CBUF.chr,n);
                 if OsStat<>0 then ERROR("FileTail-2")
                 elsif n<>lbl then EndFile:=true endif;
                 LBuf:=name2ref(@CBUF.chr);
            else LBuf:=name2ref(@LBuf.byt(512)); endif;
            nBuf:=nBuf-1;
            p:=38; repeat p:=wAND(p+1,-2); lng:=LBuf.byt(p); p:=p+1;
            while lng <> 0
            do n:=lng; repeat while n>0
---            do c:=LBuf.chr(p); p:=p+1; EdChar(EdtBuf,c); n:=n-1 endrepeat;
---            s:=PickupEdt     ;
               do c:=LBuf.chr(p); p:=p+1; EDFAST(       c); n:=n-1 endrepeat;
               FASTUP(s);
               if c='!' then smbx.val:=0 else smbx:=LOOKUP(s) endif;
               EltRef.LO:=LBuf.byt(p); p:=p+1; EltRef.HI:=LBuf.byt(p); p:=p+1;
               if smbx.val <> 0
               then if PUBREF(smbx.HI) <> none -- else not PUBLIC
                    then Pub:=PUBREF(smbx.HI).elt(smbx.LO);
                         if Pub=none then   -- Not a PUBLIC Symbol
                         elsif Pub.Seg=none -- I.e. Undefined Symbol --
                         then -- Check if Module is registered --
                              modx:=Lib.FstElt;
                              repeat while modx.val <> 0
                              do Mod:=MODMAP(modx.HI).Elt(modx.LO);
                                 modx:=Mod.EltLnk;
                                 if Mod.EltRef=EltRef.val then goto L1 endif;
                              endrepeat;
                              -- Insert Module in Library's List --
                              modx.val:=0; modx:=NewMODULE(modx);
                              if modx.val <> 0
                              then Mod:=MODMAP(modx.HI).Elt(modx.LO);
                                   Mod.EltRef:=EltRef.val; Mod.Libx:=libx;
                                   Mod.EltLnk:=Lib.FstElt; Lib.FstElt:=modx
                              endif;
                         L1:
                         endif;
                    endif;
               endif;
            endrepeat;
            nBlk:=nBlk-1;
         endrepeat;
         modx:=Lib.FstElt;
         repeat while modx.val <> 0
         do Mod:=MODMAP(modx.HI).Elt(modx.LO); modx:=Mod.EltLnk;
            if Mod.Ident.val <> 0 then modx.val:=0
            else FilPos:=Mod.EltRef; FilPos:=FilPos*16;
                 LOCATE(Inpt,0,FilPos,Loc);
                 if OsStat<>0 then ERROR(" "); OsStat:=0; goto E0 endif;
                 SCANNER(Mod); InsertAllSeg(Mod,RotBnk);
            endif;
         endrepeat;
E0:      Close(Inpt); Inpt:=0;
      endrepeat;
      if (nUNDEF>0) and (nMod.val>nModBefore) then goto AGAIN endif;
end;
%title ***  B N K   F I L E   T E R M I N A T E  ***
Routine BnkTerm;
begin ref(BANK) Bnk; ref(FRAME) Frm; ref(RELOBLK) Blk;
      Integer Loc; Unsigned n,Lng; Word bnkx;

      --- Set .bnk File Position ---
      LOCATE(BnkFile,0,BnkFilLng,Loc);
      if OsStat <> 0  then ERROR("BnkTerm-1"); OsStat:=0;
      elsif Loc <> BnkFilLng then ERROR("BnkTerm-2") endif;

      --- Scan Through all Banks <> RotBnk ---
      bnkx.val:=1; repeat while bnkx.val < nBnk.val
      do bnkx.val:=bnkx.val+1; Bnk:=BNKMAP(bnkx.HI).Elt(bnkx.LO);
         Bnk.BnkDsc.RelPos:=BnkFilLng;
         --- Write Relocation Table ---
%+D      if TrcSw>0
%+D      then BegTrace("*** Relocation Table ***"); OutTrace endif;
         Frm:=Bnk.FrmLnk;
         repeat while Frm <> none
         do Blk:=Frm.RelBlk;
            repeat while Blk <> none
            do Blk.Base:=Frm.Start.Segm.val; Lng:=(Blk.nRel*2)+4;
               if (Blk.Suc=none) and (Frm.Suc=none)
               then Blk.nRel:=Blk.nRel+65280 endif;
               if Lng > 0
               then WRITE(BnkFile,Lng,@Blk.nRel,n);
                    if OsStat <> 0 then ERROR("BnkTerm-3"); OsStat:=0;
                    elsif n <> Lng then ERROR("BnkTerm-4") endif;
               endif;
               BnkFilLng:=BnkFilLng+Lng; Blk:=Blk.Suc;
            endrepeat;
            Frm:=Frm.Suc;
         endrepeat;
      endrepeat;
      Close(BnkFile); --- Close BNK File ---
end;
%title ***  E X E   F I L E   T E R M I N A T E  ***
Routine ExeTerm; import ref(BANK) Bnk;
begin Unsigned i,j,n,Lng,nRel,dHed,nHed; Boolean Lower; ref(BankInfo) BnkInf;
      ref(BANK) Bnx; ref(FRAME) Frm; ref(DATABLK) Blk; ref(RELOBLK) relBlk;
      Integer xx,nTxt,nTxx,Loc,FilPos,p1,p2; Word w; Dword RelItm,adr;

      --- Calculate total number of Relocation Items ---
      Frm:=Bnk.FrmLnk; nRel:=NextFrmx+nBnk.val;
      repeat while Frm <> none
      do relBlk:=Frm.RelBlk; Frm:=Frm.Suc;
         repeat while relBlk <> none
         do nRel:=nRel+relBlk.nRel; relBlk:=relBlk.Suc endrepeat;
      endrepeat;

      --- Set Basic Variables ---
      nTxt:=EAddr(RotBnk.Start)
            + RotBnk.Length;  -- Size of Load Text Image (in Bytes)
      dHed:=HDSIZE;           -- Default size of Header (512-Byte Pages)
      xx:=nRel;
      nHed:=((xx*4)+541)/512; -- Actual size of Header (512-Byte Pages)

      --- Possible Move Text Image ---
      if nHed <> dHed
---   then NewDATABLK; nTxx:=nTxt;
      then             nTxx:=nTxt;
           p1:=dHed; p1:=p1*512; p2:=nHed; p2:=p2*512;
%+D        Ed(ErrMsg,"HDSIZE does not fit. Set HDSIZE ");
%+D        EdWrd(ErrMsg,nHed); WARNING(" to Speed up Linker");
           if nHed < dHed
           then --- Move Text Image to Lower Addresses in .exe file ---
                p1:=p1+nTxt; p2:=p2+nTxt; Lower:=true;
           else Lower:=false endif;
           repeat while nTxx > 0
---        do Lng:=if nTxx>1024 then 1024 else nTxx; nTxx:=nTxx-Lng;
           do Lng:=if nTxx>BufLng then BufLng else nTxx; nTxx:=nTxx-Lng;

              --- Read Buffer from file ---
              FilPos:=if Lower then p1-(nTxx+Lng) else p1+nTxx;
              LOCATE(ExeFile,0,FilPos,Loc);
              if OsStat <> 0 then ERROR("ExeTerm-1"); OsStat:=0;
              elsif Loc <> FilPos then ERROR("ExeTerm-2") endif;
---           READ(ExeFile,Lng,@Blk.chr,n);
              READ(ExeFile,Lng,@CBUF.chr,n);
              if OsStat <> 0 then ERROR("ExeTerm-3"); OsStat:=0;
              elsif n <> Lng then ERROR("ExeTerm-4") endif;

              --- Write Buffer to file ---
              FilPos:=if Lower then p2-(nTxx+Lng) else p2+nTxx;
              LOCATE(ExeFile,0,FilPos,Loc);
              if OsStat <> 0 then ERROR("ExeTerm-5"); OsStat:=0;
              elsif Loc <> FilPos then ERROR("ExeTerm-6") endif;
---           WRITE(ExeFile,Lng,@Blk.chr,n);
              WRITE(ExeFile,Lng,@CBUF.chr,n);
              if OsStat <> 0 then ERROR("ExeTerm-7"); OsStat:=0;
              elsif n <> Lng then ERROR("ExeTerm-8") endif;
           endrepeat;
%+M        if Lower then WRITE(ExeFile,0,@n,n); OsStat:=0 endif; -- Truncate
      endif;

      --- Fill EXE Label ---
      BnkInf:=Name2Ref(@BnkTab.Elt(0));
      ExeLab.MinAlloc:=BnkInf.BnkLng;     -- Size of Bank area
      ExeLab.MaxAlloc:=BnkInf.BnkLng;     -- Size of Bank area
      ExeLab.Nblp:=nTxt rem 512;          -- No-of Bytes in last page
      ExeLab.Lngp:=nHed+((nTxt+511)/512); -- File size in 512-Byte pages
      ExeLab.nRel:=nRel;                  -- No.of relocations in table
      ExeLab.Lngh:=nHed*32;               -- Header size (16-Byte para)

      if StackFrm=none then ERROR("No Stack Segment")
      else ExeLab.SS:=StackFrm.Start.Segm.val;  -- SS initial value (+reloc)
           ExeLab.SP:=StackFrm.Start.Ofst.val
                    + StackFrm.Length;      -- SP initial value
      endif;

      if StartAddr.Kind=NoAddr then ERROR("No Start Address")
      else CurMod:=StartMod; adr:=Mem2AbsAddr(StartAddr);
           ExeLab.IP:=adr.Ofst.val;   -- IP initial value
           ExeLab.CS:=adr.Segm.val;   -- CS initial value (+reloc)
      endif;

      --- Write Bank Info Table ---
      FilPos:=nHed; FilPos:=FilPos*512;
      LOCATE(ExeFile,0,FilPos,Loc);
      if OsStat <> 0 then ERROR("ExeTerm-9"); OsStat:=0;
      elsif Loc <> FilPos then ERROR("ExeTerm-10") endif;
      if TabLng > 0
      then WRITE(ExeFile,TabLng,@BnkTab.Elt,n);
           if OsStat <> 0 then ERROR("ExeTerm-11"); OsStat:=0;
           elsif n <> TabLng then ERROR("ExeTerm-12") endif;
      endif;
      --- Write Relocation Table ---
%+D   if TrcSw>0
%+D   then BegTrace("*** Relocation Table ***"); OutTrace endif;
      LOCATE(ExeFile,0,30,Loc);
      if OsStat <> 0  then ERROR("ExeTerm-13"); OsStat:=0;
      elsif Loc <> 30 then ERROR("ExeTerm-14") endif;
      RotBnk.BnkDsc.RelPos:=30;
      RelItm.Segm.val:=0;
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnx:=BNKMAP(w.HI).Elt(w.LO);
         RelItm.Ofst.val:=Bnx.FrmPos-4; j:=Bnx.nFrmx+1;
         repeat while j > 0
         do
%+D         if TrcSw>0
%+D         then EdChar(TrcBuf,' '); EdAbsAddr(TrcBuf,RelItm) endif;
            WRITE(ExeFile,4,@RelItm,n);
            if OsStat <> 0 then ERROR("ExeTerm-15"); OsStat:=0;
            elsif n <> 4   then ERROR("ExeTerm-16") endif;
            j:=j-1; RelItm.Ofst.val:=RelItm.Ofst.val+2;
         endrepeat;
      endrepeat;
      Frm:=Bnk.FrmLnk;
      repeat while Frm <> none
      do RelItm.Segm:=Frm.Start.Segm; relBlk:=Frm.RelBlk; Frm:=Frm.Suc;
         repeat while relBlk <> none
         do i:=relBlk.nRel;
            repeat while i > 0
            do i:=i-1; RelItm.Ofst:=relBlk.RELTAB(i);
%+D            if TrcSw>0
%+D            then EdChar(TrcBuf,' '); EdAbsAddr(TrcBuf,RelItm) endif;
               WRITE(ExeFile,4,@RelItm,n);
               if OsStat <> 0 then ERROR("ExeTerm-17"); OsStat:=0;
               elsif n <> 4   then ERROR("ExeTerm-18") endif;
            endrepeat
%+D         if TrcSw>0 then OutTrace endif;
            relBlk:=relBlk.Suc;
         endrepeat;
      endrepeat;

      --- Zero-Fill Last Page in Header ---

      --- Write EXE Label ---
--??  ExeLab.ChkSum:=   ?????;   -- Check-Sum
      LOCATE(ExeFile,0,0,Loc);
      if OsStat <> 0 then ERROR("ExeTerm-19"); OsStat:=0;
      elsif Loc <> 0 then ERROR("ExeTerm-20") endif;
      WRITE(ExeFile,30,@ExeLab,n);
      if OsStat <> 0 then ERROR("ExeTerm-21"); OsStat:=0;
      elsif n <> 30  then ERROR("ExeTerm-22") endif;
%+D   if AtrSw > 0 then ShowExeLab endif;
      --- Close EXE File ---
%+D   if TrcSw > 1 then ShowFileSize(ExeFile,"ExeFile") endif;
      Close(ExeFile);
end;
%title ***  M A P   L I S T I N G  ***
Routine PrtArc;
import Integer Scale,Start,Length; Word Ident; Character c;
begin Unsigned n; EdInt(EdtBuf,Start); SetPos(EdtBuf,8);
      EdInt(EdtBuf,Length); SetPos(EdtBuf,16); editSymb(     Ident);
      n:=(Length/Scale); SetPos(EdtBuf,30+(Start/Scale));
%+D   if n > 60 then n:=60 endif;
      repeat editChar(     c) while n>0 do n:=n-1 endrepeat;
      OutImage;
end;

Routine MapListing;
begin Integer Start; Unsigned Base,Ofst,Scale; Word i,xSmb,modx;
      ref(PUBLIC) Pub; Dword adr; ref(BANK) Bnk; ref(FRAME) Frm;
%+D   if LstSw > 0 then ShowBankInfo endif;
      if LstSw > 2
      then OutImage; Edit(     "***   M O D U L E    M A P   ***"); OutImage;
           i.val:=0; repeat while i.val < nMod.val
           do i.val:=i.val+1; Summary(MODMAP(i.HI).Elt(i.LO)) endrepeat;
      endif;
      if LstSw > 0
      then OutImage; Edit(     "***   M E M O R Y    M A P   ***"); OutImage;
           i.val:=0; repeat while i.val < nBnk.val
           do i.val:=i.val+1; ShowBnk(BNKMAP(i.HI).Elt(i.LO)) endrepeat;
           if StartAddr.Kind <> NoAddr
           then CurMod:=StartMod; adr:=Mem2AbsAddr(StartAddr);
                Edit(     "Start Address: "); EdAddr(EdtBuf,StartAddr);
                editChar(     '='); EdSegAddr(adr); OutImage;
           endif;
      endif;
      OutImage; Edit(     "start   length  name          ************");
      Edit(     "   M E M O R Y    M A P   ************"); OutImage;
      Scale:=Total/50; if Scale=0 then Scale:=1 endif;
      i.val:=0; repeat while i.val < nBnk.val
      do i.val:=i.val+1; Bnk:=BNKMAP(i.HI).Elt(i.LO); Frm:=Bnk.FrmLnk;
         PrtArc(Scale,EAddr(Bnk.Start),Bnk.Length,Bnk.Ident,'=');
         if LstSw > 0
         then repeat while Frm <> none
              do PrtArc(Scale,EAddr(Frm.Start),Frm.Length,Frm.Ident,'-')
                 Frm:=Frm.Suc;
              endrepeat;
         endif;
      endrepeat;
      if LstSw > 1
      then OutImage; Edit(     "***   P U B L I C    M A P   ***"); OutImage;
           xSmb.val:=0; repeat while xSmb.val < nSmb.val
           do if PUBREF(xSmb.HI)=none then Pub:=none
              else Pub:=PUBREF(xSmb.HI).elt(xSmb.LO) endif;
              if Pub <> none
              then if Pub.Seg=none
                   then Edit(     "00000(0000:0000)  ");
                        editSymb(     xSmb); MovePos(EdtBuf,40);
                        if xSmb=sBNKTAB
                        then Edit(     "*** DEFINED BY LINKER");
                        else Edit(     "*** UNDEFINED") endif;
                   else adr:=Pub.Seg.Start;
                        adr.Ofst.val:=adr.Ofst.val+Pub.Ofst;
                        EdSegAddr(adr); Edit(     "  ");
                        editSymb(     xSmb);
                        MovePos(EdtBuf,40); modx:=Pub.Seg.Modx;
                        EdModid(EdtBuf,MODMAP(modx.HI).Elt(modx.LO));
                        editChar(     '('); editSymb(     Pub.Seg.Ident);
                        editChar(     '+'); EdWrd(EdtBuf,Pub.Ofst);
                        editChar(     ')');
                   endif;
                   OutImage;
              endif;
              xSmb.val:=xSmb.val+1;
           endrepeat;
      endif; OutImage;
%+D   ShowExeLab;
end;

Routine Summary; import ref(OBJMODULE) Mod;
begin Word xSmb; Unsigned i; ref(PUBLIC) Pub;
      ref(BANK) Bnk; ref(FRAME) Frm; ref(SEGMENT) Seg; Dword adr;
      Edit(     "Module "); EdModid(EdtBuf,Mod); OutImage;
      i:=0; repeat while i < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(i); i:=i+1;
         if Seg.Length > 0
         then EdSegAddr(Seg.Start); Edit(     "  ");
              editSymb(     Seg.Ident); MovePos(EdtBuf,35);
              Edit(     "SEGMENT LENGTH: "); EdHex(EdtBuf,Seg.Length,4);
              Frm:=Seg.Frm; Bnk:=if Frm=none then none else Frm.Bnk;
              if Bnk <> none
              then Edit(     "  Included in ");
                   editSymb(     Bnk.Ident);
              endif;
              OutImage;
         endif;
      endrepeat;
      i:=0; repeat while i < Mod.ExtTab.nElt
      do xSmb:=Mod.ExtTab.Elt(i); i:=i+1;
         Pub:=PUBREF(xSmb.HI).Elt(xSmb.LO); Seg:=Pub.Seg;
         if Seg=none then adr.val:=0
         else adr:=Seg.Start; adr.Ofst.val:=adr.Ofst.val+Pub.Ofst endif;
         EdSegAddr(adr); Edit(     "  "); editSymb(     xSmb);
         MovePos(EdtBuf,35); Edit(     "EXTERN  ");
         if Seg=none then Edit(     "*** Undefined ***")
         else EdModid(EdtBuf,MODMAP(Seg.Modx.HI).Elt(Seg.Modx.LO));
              editChar(     '('); editSymb(     Seg.Ident);
              editChar(     '+'); EdWrd(EdtBuf,Pub.Ofst);
              editChar(     ')');
         endif; OutImage;
      endrepeat; OutImage;
end;
%title ***  M O N I T O R   U T I L I T I E S  ***

Routine InItem; export infix(string) itm;
begin character c;
      repeat while NextChar = ' ' do InChar endrepeat; c:=InChar;
      editChar(     c);
      if (c='(') or (c=')') or (c=',') or (c='=') or (c='+') then goto F endif;
      L: c:=NextChar;
      if (c='(') or (c=')') or (c=',') or (c='=') or (c='+') then -- Nothing
      elsif c <> ' ' then editChar(     InChar); goto L endif;
      F: itm:=PickupEdt     ;
%+D   if TrcSw > 1
%+D   then BegTrace("InItem: !"); Ed(TrcBuf,itm);
%+D        EdChar(TrcBuf,'!'); OutTrace;
%+D   endif;
end;

Routine InSymb; export Word itm;
begin Unsigned n; Byte b;
      repeat itm:=DICDEF(InItem) while itm=sCOMMENT
      do repeat READ(Srcf,1,@b,n);
                if OsStat <> 0 then b:=10; OsStat:=0;
                elsif n <> 1   then b:=10 endif;
                if Verbose then WRITE(kSYSOUT,1,@b,n); OsStat:=0 endif;
         while b <> 10 do endrepeat;
      endrepeat;
end;

Routine InBank; export Word itm;
begin Unsigned n; Byte b; infix(string) s;
      repeat s:=InItem; itm:=DICDEF(s) while itm=sCOMMENT
      do repeat READ(Srcf,1,@b,n);
                if OsStat <> 0 then b:=10; OsStat:=0;
                elsif n <> 1   then b:=10 endif;
                if Verbose then WRITE(kSYSOUT,1,@b,n); OsStat:=0 endif;
         while b <> 10 do endrepeat;
      endrepeat;
      --- strip off possible extension ---
      n:=0; repeat while n<s.nchr
      do if var(s.chradr)(n)='.' then s.nchr:=n; itm:=DICDEF(s) endif;
         n:=n+1 endrepeat;
end;

Routine ChkDir; import Word itm; export Word res
begin L: if itm=sHDSIZE  then HDSIZE:=InWrd
      elsif itm=sINTGOTO then xGOTO:=InWrd
      elsif itm=sINTJMPF then xJMPF:=InWrd
      elsif itm=sINTCALL then xCALL:=InWrd
      elsif itm=sINTCALF then xCALF:=InWrd
%+D   elsif itm=sTRACE   then TrcSw:=InInt
%+D   elsif itm=sATRACE  then AtrSw:=InInt
      elsif itm=sLISTING then LstSw:=InWrd
%+D   elsif itm=sLN1TRC  then LN1MOD:=InSymb; LN1POS:=InInt;
%+D                           LN1CNT:=InWrd;  LN1TRC:=InWrd;
%+D   elsif itm=sLN2TRC  then LN2MOD:=InSymb; LN2POS:=InInt;
%+D                           LN2CNT:=InWrd;  LN2TRC:=InWrd;
      else res:=itm; goto E endif;
      itm:=InSymb; goto L;
E:end;

Routine InChar; export character c;
begin int n; c:=NextChar; L: EndFile:=false; READ(Srcf,1,@NextChar,n);
      if OsStat <> 0 then ERROR("InChar")
      elsif n <> 1   then EndFile:=true endif;
%+D   if TrcSw > 8
%+D   then BegTrace("*** NextChar: ");
%+D        EdWrd(TrcBuf,NextChar qua Integer); OutTrace;
%+D   endif;
      if EndFile then EndFile:=false; goto L; endif;
      if Verbose then WRITE(kSYSOUT,1,@NextChar,n); OsStat:=0 endif;
      if NextChar < ' ' then NextChar:=' ' endif;
end;

%+D Routine UpChar; import character c; export character u;
%+D begin Byte b; b:=c qua Integer;
%+D       u:=(if b>95 then b-32 else b) qua character;
%+D end;

%+D Routine InInt; export Integer i;
%+D begin character c; i:=0;
%+D       repeat while NextChar=' ' do InChar endrepeat;
%+D       repeat c:=NextChar while (c>='0') and (c<='9')
%+D       do i:=(i*10)+(c qua Integer -48); InChar endrepeat;
%+D end;

Routine InWrd; export Unsigned i;
begin character c; i:=0;
      repeat while NextChar=' ' do InChar endrepeat;
      repeat c:=NextChar while (c>='0') and (c<='9')
      do i:=(i*10)+(c qua Integer -48); InChar endrepeat;
end;

%+D Routine InHex; export Unsigned i;
%+D begin Byte d; character c; i:=0;
%+D       repeat while NextChar=' ' do InChar endrepeat;
%+D    L: c:=UpChar(NextChar); d:=c qua Integer;
%+D       if    (c>='0') and (c<='9') then d:=d-48
%+D       elsif (c>='A') and (c<='F') then d:=d-55 else goto E endif;
%+D       i:=(i*16)+d; InChar; goto L;
%+D E:end;
%title ***   I  N  I  T  I  A  T  E  R   ***

Routine INITIATER; export Word itm;
begin infix(String) s; Unsigned i; ref(IObuffer) bufr;
      HDSIZE:=16;         -- Default size of .exe-File Header (in pages)
      xGOTO:=70; xJMPF:=71; xCALL:=72; xCALF:=73; -- INT-Vector indicies
      StartAddr.Kind:=NoAddr;
      onebank:=false;

      --- init IO buffer structure ---
      IOfree:=none; i:=nIObuf; repeat while i<>0
      do bufr:=ALLOC(bufr,Size(IObuffer)); bufr.suc:=IOfree; IOfree:=bufr;
         i:=i-1 endrepeat

-- ?? FreeBlk:=none;      -- Free Code Buffer Chain
-- ?? CurBlk:=none;       -- Code Buffer during LOADER
-- ?? RotBnk:=none;       -- Root Bank (EXE part)
-- ?? LinBnk:=none;       -- LineNumber Bank
-- ?? BnkFilLng:=0;       -- BNK File length (in Bytes)
-- ?? Total:=0;           -- Total size in Bytes
-- ?? NextFrmx:=0;        -- Next available Frame index
-- ?? StartMod:=none;
-- ?? StackFrm:=none;
-- ?? CurMod:=none;         -- Current OBJMODULE
-- ?? CurFrm:=none;         -- Current FRAME
-- ?? CurSeg:=none;         -- Current SEGMENT
-- ?? BytPos:=0;            -- Input Byte number ;
-- ?? RecLng:=0;            -- Length of current record ;
-- ?? %+D   ChkSum:=0;      -- Check-sum of current record ;
-- ?? RecTyp:=0;            -- Current Record Code ;
-- ?? Inpt:=0;              -- OBJ-Input file Handle
-- ?? Oupt:=0;              -- Created Listing File Handle
-- ?? ExeFile:=0;           -- Created .exe File Handle
-- ?? BnkFile:=0;           -- Created .bnk File Handle
-- ?? nUNDEF:=0;            -- No.of UNDEFINED PUBLICs

      --- Initiate EXE Label ---
      ExeLab.ChkCode:=  23117;   -- EXE-File Check code
      ExeLab.Nblp:=     00000;   -- Number of Bytes in last page
      ExeLab.Lngp:=     00000;   -- File size in 512-Byte pages
      ExeLab.nRel:=     00000;   -- No.of relocation entries in table
      ExeLab.Lngh:=     00000;   -- Size of header in 16-Byte paragraphs
      ExeLab.MinAlloc:= 0;
      ExeLab.MaxAlloc:= 1;
      ExeLab.SS:=       00000;   -- SS initial value (+reloc)
      ExeLab.SP:=       00000;   -- SP initial value
      ExeLab.ChkSum:=   00000;   -- Check-Sum
      ExeLab.IP:=       00000;   -- IP initial value
      ExeLab.CS:=       00000;   -- CS initial value (+reloc)
      ExeLab.Relo:=     30;      -- Rel. Byte offset of Relocation Table
      ExeLab.Ovln:=     0;       -- Overlay number
      ExeLab.Uknw:=     1;       -- Unknown

      InChar; -- Initiate Standard Input
      sHDSIZE:=  DICDEF("HDSIZE");   sLISTING:= DICDEF("LISTING");
      sINTGOTO:= DICDEF("INTGOTO");  sINTJMPF:= DICDEF("INTJMPF");
      sINTCALL:= DICDEF("INTCALL");  sINTCALF:= DICDEF("INTCALF");
      sLBRK:=    DICDEF("(");        sRBRK:=    DICDEF(")");
      sCOMA:=    DICDEF(",");        sBNK:=     DICDEF("BNK");
      sEQUAL:=   DICDEF("=");        sPLUS:=    DICDEF("+");
      sEXE:=     DICDEF("EXE");      sLIB:=     DICDEF("LIB");
      sDEF:=     DICDEF("DEF");      sEXT:=     DICDEF("EXT");
      sEND:=     DICDEF("END");      sSTACK:=   DICDEF("STACK");
      sEGOTO:=   DICDEF("E@GOTO");   sECALL:=   DICDEF("E@CALL");
      sBNKTAB:=  DICDEF("S@BNKTAB"); sCOMMENT:= DICDEF("--");
%+D   sLN1TRC:=  DICDEF("LN1TRC");   sLN2TRC:=  DICDEF("LN2TRC");
%+D   sTRACE:=   DICDEF("TRACE");    sATRACE:=  DICDEF("ATRACE");
 end;

%title ***   L  I  N  K  R   ***

Routine LINKR;
begin Unsigned nPrd; Integer FilPos,Loc,n;
      Word i,itm,instr,BnkNam,bnkx,modx;
      ref(LIBRARY) Lib; ref(BANK) Bnk,PrdBnk(100);
      ref(FRAME) Frm; ref(SEGMENT) Seg; ref(OBJMODULE) Mod;

      itm:=InSymb;
      repeat instr:=ChkDir(itm);
--    while (instr=sBNK) or (instr=sEXE) or (instr=sDEF) or (instr=sEXT)
      while (instr=sBNK) or (instr=sEXE)
      do -----------------------------------------------------------
         -- Treat: EXE/DEF BankName                               --
         --   or   BNK/EXT BankName < ( PredBankName , ... ) >?   --
         -----------------------------------------------------------
         nPrd:=0; BnkNam:=InBank;
         if FindBank(BnkNam) <> none
         then Ed(ErrMsg,"Bank "); EdSymb(ErrMsg,BnkNam);
              ERROR(" Already Defined");
         endif;
         itm:=InSymb;
         if itm=sLBRK
         then L1: itm:=InSymb; Bnk:=FindBank(itm);
              if Bnk = none
              then Ed(ErrMsg,"Bank "); EdSymb(ErrMsg,itm);
                   ERROR(" is not Defined");
              elsif nPrd >= 100 then ERROR("Too many preceding banks")
              else PrdBnk(nPrd):=Bnk; nPrd:=nPrd+1 endif;
              itm:=InSymb; if itm=sCOMA then goto L1 endif;
              if itm = sRBRK then itm:=InSymb
              else ERROR("Missing )") endif;
         endif;
--       if instr=sEXT
--       then if RotBnk <> none
--            then if nPrd=0 then nPrd:=1; PrdBnk(0):=RotBnk endif;
--            else ERROR("No ROOT specified") endif;
--            Bnk:=NewBANK(Size(XBANK),BnkNam,nPrd); Bnk.PrdBnk.nElt:=nPrd;
--            repeat while nPrd > 0
--            do nPrd:=nPrd-1; Bnk.PrdBnk.Elt(nPrd):=PrdBnk(nPrd) endrepeat;
--            ---------------------------------------------------------------
--            -- Treat: = FileName                                         --
--            ---------------------------------------------------------------
--            -- ...  ...  ...  ...
--            -- ...  ...  ...  ...
--            -- ...  ...  ...  ...
--            -- ...  ...  ...  ...
--            -- ...  ...  ...  ...
--       else
              if instr=sEXE
              then Bnk:=NewBANK(Size(BANK),BnkNam,0); Bnk.PrdBnk.nElt:=0;
                   if nPrd <> 0 then ERROR("Relation(s) ignored for EXE") endif;
                   if RotBnk=none
                   then RotBnk:=Bnk;
                        LinBnk:=NewBANK(Size(BANK),DICDEF("{LINMAP}"),1);
                        LinBnk.PrdBnk.nElt:=1;
                        LinBnk.PrdBnk.Elt(0):=RotBnk;
                   else ERROR("ROOT is already specified") endif;
--                 BankDefining:=false;
--            elsif instr=sDEF
--            then Bnk:=NewBANK(Size(BANK),BnkNam,0); Bnk.PrdBnk.nElt:=0;
--                 if nPrd <> 0 then ERROR("Relation(s) ignored for DEF") endif;
--                 if RotBnk=none then RotBnk:=Bnk
--                 else ERROR("ROOT is already specified") endif;
--                 BankDefining:=true;
              elsif instr=sBNK
              then if nPrd=0 then nPrd:=1; PrdBnk(0):=RotBnk endif;
                   Bnk:=NewBANK(Size(BANK),BnkNam,nPrd); Bnk.PrdBnk.nElt:=nPrd;
                   repeat while nPrd > 0 do nPrd:=nPrd-1;
                          Bnk.PrdBnk.Elt(nPrd):=PrdBnk(nPrd) endrepeat;
              endif;

              ---------------------------------------------------------------
              -- Treat: = Module<(Seg,... )>? < + Module<( Seg,... )>? >*  --
              ---------------------------------------------------------------
              repeat while (ChkDir(itm)=sEQUAL) or (itm=sPLUS)
              do Mod:=FindModule(InSymb);
                 if Mod = none then itm:=InSymb; goto E1 endif;
                 itm:=InSymb;
                 if itm=sLBRK
                 then L2: itm:=InSymb; i.val:=Mod.SegTab.nElt;
                      repeat while i.val > 0
                      do i.val:=i.val-1; Seg:=Mod.SegTab.Elt(i.val);
                         if itm=Seg.Ident
                         then InsertSegment(Seg,Bnk); goto Ls endif;
                      endrepeat;
                      Ed(ErrMsg,"Segment "); EdSymb(ErrMsg,itm);
                      Ed(ErrMsg," not in "); EdModid(ErrMsg,Mod); MODERR(" ");
                Ls:   itm:=InSymb; if itm=sCOMA then goto L2 endif;
                      if itm=sRBRK then itm:=InSymb
                      else ERROR("Missing )") endif;
                 else InsertAllSeg(Mod,Bnk); endif;
          E1: endrepeat;
--       endif;
%+D      if TrcSw > 1 then ShowBnk(Bnk) endif;
      endrepeat;

      if RotBnk=none then ERROR("No ROOT specified") endif;

      --------------------------------------------------
      -- Treat: LIB LibraryName < + LibraryName >*    --
      --------------------------------------------------
      repeat while (ChkDir(itm)=sLIB) or (itm=sPLUS)
      do NewLIBRARY(InSymb); itm:=InSymb endrepeat;

      if Verbose then SYSPRI(nostring) endif;
      if ChkDir(itm) <> sEND then ERROR("SYNTAX ERROR"); goto T1 endif;

      if nUNDEF > 0 then LibrarySearch endif;

      i.val:=0; repeat while i.val < nMod.val
      do i.val:=i.val+1; ChkInsert(MODMAP(i.HI).Elt(i.LO)) endrepeat;

      if nBnk.val=0 then ERROR("No Bank Defined"); goto T2 endif;
      if nBnk.val>1
      then if nBnk.val=2
           then mergeLinbnk:=true
           else editSymb(     RotBnk.Ident); Edit(     ".bnk");
                BnkFilNam:=DICDEF(PickupEdt     );
                BnkFile:=Open(BnkFilNam,".bnk",accwrite);
%+M             WRITE(BnkFile,0,@n,n); OsStat:=0; -- Truncate File
                bnkx:=nBnk; repeat while bnkx.val > 0
                do Bnk:=BNKMAP(bnkx.HI).Elt(bnkx.LO); bnkx.val:=bnkx.val-1;
                   Bnk.Handle:=BnkFile;
                endrepeat;
           endif
      endif;

      editSymb(     RotBnk.Ident); Edit(     ".exe");
      ExeFilNam:=DICDEF(PickupEdt     );
      ExeFile:=Open(ExeFilNam,".exe",accrw); RotBnk.Handle:=ExeFile;
%+M   WRITE(ExeFile,0,@n,n); OsStat:=0; -- Truncate Existing File

      MakeBankInfoTable;
      RotBnk.BnkDsc.TxtPos:=HDSIZE;
      RotBnk.BnkDsc.TxtPos:=RotBnk.BnkDsc.TxtPos*512;

      i.val:=0; repeat while i.val < nMod.val
      do i.val:=i.val+1; Mod:=MODMAP(i.HI).Elt(i.LO);
         if Mod.Libx.val=0
         then Inpt:=Open(Mod.Ident,".obj",accread);
              if EndFile then OpenErr(Mod.Ident) endif;
              LOADER(Mod); Close(Inpt); Inpt:=0;
         endif;
      endrepeat;

      i.val:=0; repeat while i.val < nLib.val
      do i.val:=i.val+1 Lib:=LIBMAP(i.HI).Elt(i.LO);
         Inpt:=Open(Lib.Ident,".lib",accread);
         if EndFile then OpenErr(Lib.Ident) endif;
         modx:=Lib.FstElt;
         repeat while modx.val <> 0
         do Mod:=MODMAP(modx.HI).Elt(modx.LO); modx:=Mod.EltLnk;
            FilPos:=Mod.EltRef; FilPos:=FilPos*16;
            LOCATE(Inpt,0,FilPos,Loc);
            if OsStat<>0 then ERROR("Load-LOCATE"); OsStat:=0; goto LE2 endif;
            LOADER(Mod);
         endrepeat;
  LE2:   Close(Inpt); Inpt:=0;
      endrepeat;
 
      if BnkFile <> 0 then BnkTerm endif;
      if ExeFile <> 0 then ExeTerm(BNKMAP.Elt(1)) endif;

      if Verbose then MapListing endif;

T1:T2:if Verbose
      then Edit(     "End SIMULA Multi-Linker,  Errors: ");
           EdWrd(EdtBuf,ErrCnt); OutImage;
      endif;
end;
%title ***   M  O  N  I  T  O  R   ***

Routine GetInt; import infix(String) itm; export Unsigned val;
begin character c; Unsigned i; i:=0; val:=0;
      repeat c:=if i<itm.nchr then var(itm.chradr)(i) else 'x'
      while c=' ' do i:=i+1 endrepeat;
      repeat c:=if i<itm.nchr then var(itm.chradr)(i) else 'x'
      while (c>='0') and (c<='9')
      do val:=(val*10)+(c qua integer -48); i:=i+1 endrepeat;
end;

Visible Routine MONITOR; import infix(String) verid;
begin Unsigned i; infix(String) par,val; Character opt;
      boolean noP2,giveVersion;
      Word InFileName;

      INITIATE; InFileName.val:=0; Verbose:=false; noP2:=true;
      giveVersion:=false; mergeLinbnk:=true;
      i:=1; repeat par:=GetPar(i); i:=i+1 while par.nchr <> 0
      do
-- ???   Ed(EdtBuf,"Parameter: "); Ed(EdtBuf,par); OutImage; 
         if    SEQ(par,"/P2") then
%+D                                TrcSw:=0;
                    noP2:=false;
         elsif SEQ(par,"/p2") then
%+D                                TrcSw:=0;
                    noP2:=false;
         elsif (par.nchr > 1) and (var(par.chradr) = '-')
         then opt:=var(par.chradr)(1);   
-- ???        Ed(EdtBuf,"Option: "); editChar(     opt); OutImage;
              if    opt='V' then giveVersion:=true;
              elsif opt='v' then Verbose:=true; giveVersion:=true;
              elsif opt='B' then mergeLinbnk:=false
              elsif noP2
              then if (par.nchr > 2)
                   then val.chradr:=name(var(par.chradr)(2));
                        val.nchr:=par.nchr-2;
                   else i:=i+1; val:=GetPar(i) endif;
-- ???             Ed(EdtBuf,"  Value: "); Ed(EdtBuf,val); OutImage; 
%+D                if opt='t' then TrcSw:=GetInt(val)
%+D                else
                        Edit(     "Lnk: Illegal option: -");
                        editChar(     opt); Edit(     val); OutImage; 
%+D                endif;
              endif;
         elsif noP2
         then if InFileName.val=0 then InFileName:=DICDEF(par)
              else Edit(     "Lnk: Illegal parameter: ");
                   Edit(     par); OutImage;
              endif;
         endif;
      endrepeat;

      if giveVersion
      then Edit(     "SIMULA (R) Linker  Version "); Edit(     verid); OutImage;
           Edit(     "Copyright (C) Simula a.s. 1989,91."); OutImage;
      endif;

      if noP2
      then if InFileName.val=0
           then Prt("Lnk: insufficient arguments");
                Prt("Usage: lnk {opt}.. file");
                Prt(" -V: version etc.  -v: verbose  -B: banking");
%+D             Prt(" -t<number>: Trace level");
                Prt(" - file assumed to be AUTOLINK.PAR");
                InFileName:=DICDEF("autolink")
           endif
      else InFileName:=DICDEF("autolink") endif;
      OsStat:=0; Endfile:=false;
      Srcf:=Open(InFileName,".par",accread);
      if EndFile then OpenErr(InFileName) endif;
      INITIATER; LINKR;

      if Verbose then Edit(     "End Linker"); OutImage endif;
end;

end;
