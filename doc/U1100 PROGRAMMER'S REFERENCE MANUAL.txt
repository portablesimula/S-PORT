 ^pg;







         Norwegian Computing Center
         Postbox 335 Blindern
         N-Oslo 3, Norway















                           SIMULA 67

                       Univac 1100 series


                  PROGRAMMER'S REFERENCE MANUAL

               Peter Jensen and \ystein Myhre, NCC






















         Copyright 1982 by Norwegian Computing Center.
         SIMULA is a registered trademark of the NCC.








                                 1
 ^pg;
























       PLEASE NOTE THAT THIS SYSTEM IS NO LONGER MAINTAINED
       ====================================================


       thus the information in app. E is of minor interest!




































                                 2
 ^pg;



 INTRODUCTION

 NOTE: This system is no longer maintained.


 The purpose of this manual is twofold. On one hand it provides
 the programmer with the necessary knowledge of the interface
 between the Simula system (compiler or run time system) and the
 EXEC operating system. This information is contained in chapters
 1-3. On the other hand the manual is intended to provide a more
 detailed knowledge of the run time system and the generated code
 to those users who for instance wants to prepare Simula programs
 which contain elements programmed in other languages.

 Throughout the manual we will refer to the Simula language
 processor by the name "S*I.M".  The reader should however check
 this name with his/her particular Univac installation since the
 naming conventions may vary. In the examples we employ the
 standard hardware representation language for Simula programs as
 defined in (4). On control images we will use capital letters for
 all information which in an actual run must appear as written and
 reserve lower case for information which has to be supplied by
 the user.

 In order to make a clear distinction between Simula keywords and
 the surrounding text the keywords are printed in upper case only.
 But we emphasize that it is of no concern to the compiler whether
 upper case or lower case letters (or a mixture) are used in
 spelling a keyword.

 In programming the lower case alphabet should be used whenever
 possible since the legibility of the program is improved
 considerably.

 This manual replaces an earlier version (NCC 1972) together with
 the User's Guide; both are outdated and will no longer be
 available.  We acknowledge the work of Sigurd Kubosch and Ron
 Kerr, who authored the original manuals.


                              NCC, April 1982
                        Peter Jensen and \ystein Myhre




















                                 3
 ^pg;



 References.



 1. Common Base Language.
    O.-J. Dahl et al.
    Norwegian Computing Center
    Oslo 1970 (revised edition scheduled for late 1982)


 2. Revised Report of the Algol Language
    P. Naur (ed.)
    Comm. ACM, January 1963


 3. EXEC Programmer's Reference Manual
    Univac UP4144 (level 36 or higher)


 4. SIMULA Hardware Representation Language
    in: Minutes from the annual meetings
        of SSG and SDG, NCC report 625, 1978.


 5. The Minutes from the annual SSG meetings.
    - available from NCC.
    (The changes to the language definition
     will be incorporated in the new CB (ref. 1)


































                                 4
 ^pg;



 1   THE SIMULA COMPILER


 The Univac Simula System consists of two fundamental parts: the
 compiler and the run time system.

 The compiler is a standard system processor. It will translate
 Simula source programs into relocatable elements of standard
 format i.e. they are acceptable as input to the MAP collector.
 Optionally the compilation may result in the production of an
 absolute element which (if required) may be loaded and executed
 automatically.

 The compiler use standard system interfaces such as the SIR
 processor etc.  This means that both user interface (at the
 processor call level) and system interface is fully compatible
 with other Univac processors.

 Internally the Simula compiler is organised into 9 dynamic
 instruction banks and one static data bank. The core storage
 requirements are at no time greater than about 30K but may be
 less in case of syntactically and semantically correct programs.
 Dynamic banking may at some installations be rather expensive to
 utilise - in that case the use of compiler option O is
 recommended. Each bank will then be forced static when entered.

 During compilation the compiler will allocate a temporary work
 file <project-id>*S$$$ of 300 tracks type F mass storage. If the
 link and execute options are given a temporary file called
 SIMULA$MAP of 50 tracks will be assigned.

 The system requirements for a compilation are thus:

     - about 30K words of core storage

     - up to 350 tracks type F mass storage.

 The Run Time System consists of a set of relocatable support
 routines.  The minimum set of these routines necessary to execute
 the program is collected with the ROR element produced during
 collection. The most important of these routines is the storage
 allocation system. When the object program begins execution a
 storage pool is requested (by MCORE$) from Univac. The size of
 this pool is specified through run time options and may range
 from 1 to 63K words. Note however that the generated object
 program does not employ banking - and that text constants are
 allocated in the data area. Thus the actual area usable for data
 structures allocated by the program may be considerably less than
 63K.

 The system requirements for the execution of a Simula program are

     - sufficient core storage to contain the object program and
       the run time routines

     - run time data storage pool.


 The compiler is activated through a normal EXEC processor call
 statement of the form


                                 5
 ^pg;
                      1. The Simula Compiler


       @S*I.M,options si,ro,so,parameter

 The valid option letters are listed in section 1.1.

 The si-, ro- and so-fields have their normal EXEC meaning as
 source input, relocatable output and source output element names
 respectively. Empty fields are interpreted in the standard
 manner.

 The parameter field is described in section 1.2.



 1.1   _Compiler options at a glance_.


 This section contains the complete list of valid options. Some
 options are only mentioned briefly here, they are more fully
 described in the referenced section later. The standard SIR
 options A, G, H, I, J, P, Q and X are described in ref. 3.

 A  Standard SIR option.
 C  Compiler maintenance option (see appendix E).
 D  The object program may be used as a processor (see 1.7).
 G  Standard SIR option.
 H  Standard SIR option.
 I  Standard SIR option.
 J  Standard SIR option.
 L  Enable assembly listing (see 1.5).
 M  Documentation listing option (see 1.4).
 N  Do not print "notes" (see 3).
 O  The compiler will use static banking (dynamic is default).
 P  Standard SIR option.
 Q  Standard SIR option.
 R  Collect with R-option (see 1.6).
 S  The source program is listed (see 1.4).
 U  Standard SIR option.
 V  "Load and go"-option (see 1.6).
 W  Standard SIR option.
 X  Standard SIR option.
 Y  Expand declarations table. This option allows for the
    translation of programs of great complexity in the
    inspection-structure, at the expense of a greater storage
    demand during compilation.
 Z  Do not include line numbers in the generated code.  In the
    absence of this option code is generated to keep register R14
    updated with the current source program line number during
    execution.



 1.2   _Compiler parameters_.



 The only parameter possible is the block level indicator:

 <parameter>  ::=  BL/<unsigned integer>

 This parameter sets the block level at which a separatedly


                                 6
 ^pg;
                      1. The Simula Compiler


 compiled class is to be used. The parameter is necessary due to
 the register allocation used in the code generation.  The default
 value is 0 (zero) i.e. the class may be used only as a prefix at
 the outermost level. See section 1.8.



 1.3   _Compiler directives_.


 Through utilisation of the compiler directives it is possible to
 gain some control over for instance the format of the source
 program listing, the use of Univac-specific non-standard Simula
 features such as e.g. complex type, the setting of run time
 system options etc. The reader is warned that - apart from the
 %-convention - compiler directives are not standardised.
 Inclusion of such directives will thus almost certainly imply
 that the program is non-portable.


    <directive line> ::=  %<directive><directive tail> ;
                           <rest of line ignored>
                      !   %<space> <rest of line ignored>

    <directive>      ::=  CHECKS       (1.3.1)
                      !   CODE         (1.3.2, 1.5)
                      !   COMPLEX      (1.3.3)
                      !   INDENT       (1.3.4, 1.4)
                      !   LINENUMBERS  (1.3.5)
                      !   LIST         (1.3.6, 1.4)
                      !   MAXERRORS    (1.3.7, 3)
                      !   NATIONAL     (1.3.8)
                      !   NOCODE       (1.3.9)
                      !   NOLIST       (1.3.10)
                      !   NOSOURCE     (1.3.11)
                      !   OCTAL        (1.3.12, 4.5)
                      !   PAGE         (1.3.13, 1.4)
                      !   PASS         (1.3.14)
                      !   RTSOPTIONS   (1.3.15, 1.7)
                      !   SOURCE       (1.3.16)
                      !   TITLE        (1.3.17)
                      !   XQTOPTIONS   (1.3.18)


 The <directive tail> will be described in the following sections,
 the syntax vary from directive to directive.

 The %-character must be in the first position of the image and
 the directive (starting in pos. 1) must be completely contained
 in one image. The compiler will not scan beyond the semicolon
 delimiting the directive - comments may thus be placed on the
 remainder of the line. Note that if % is followed by a space, the
 line will be completely ignored and no message given.

 A directive can be placed anywhere in the source program as long
 as the restrictions above are observed. Directives may thus occur
 before the start of the program proper, anywhere between the
 program lines (including between text strings to be concatenated)
 or after the final  END. It takes effect immediatedly and will
 affect only the succeeding lines of the source text.


                                 7
 ^pg;
                      1. The Simula Compiler


 1.3.1.   %CHECKS.


    <directive tail> ::=  ON  !  OFF

 Run time checking of array indices against the defined bounds are
 normally performed at execution of the object program. Checks on
 reference variable are also performed at run time (qualification
 checks, checks for NONE).  These checks may be turned on/off by
 means of this directive. The programmer is advised to use this
 feature with extreme caution.


 1.3.2.   %CODE.


    <directive tail> ::=  ON  !  OFF

 If the L-option is used the generated code will be listed for
 program parts enclosed in  %CODE ON - %CODE OFF  pairs see
 section 1.5.


 1.3.3.   %COMPLEX.


    <directive tail> ::=  ON  !  OFF

 The directive controls the use of the type COMPLEX, see COMPLEX.
 Note that this is a non-Simula feature.


 1.3.4.   %INDENT.


    <directive tail> ::=  ON  !  OFF  !  = <indentation>

 The listing of the source program may be indented a number of
 positions whenever BEGIN is recognised, thus making the structure
 of the program more apparent, see section 1.4.


 1.3.5.   %LINENUMBERS.


    <directive tail> ::=  ON  !  OFF

 During normal listing of the source program each line will be
 identified by it's sequential number. Printing of line numbers
 may be suppressed by means of this directive.


 1.3.6.   %LIST.


    <directive tail> ::=  ON  !  OFF

 This directive may be used to list only selected parts of the
 program, see section 1.4.



                                 8
 ^pg;
                      1. The Simula Compiler


 1.3.7.   %MAXERRORS.


    <directive tail> ::=  ON  !  OFF  !  = <limit>

 After <limit> errors the compiler aborts the compilation. The
 default value of <limit> is 50, set at entry to compiler or
 through %MAXERRORS ON. The <limit> may be set to any value or may
 be turned completely OFF.


 1.3.8.   %NATIONAL.


    <directive tail> ::=  ON  !  OFF

 The so-called national positions of the ASCII alphabet (4) are
 normally treated as graphic characters, that is they may be used
 in strings and character constants only (besides comments). After
 recognising %NATIONAL ON;  the compiler will treat them as
 letters instead.


 1.3.9.   %NOCODE.


    <directive tail> ::=  <empty>

 Equivalent to %CODE OFF.


 1.3.10.  %NOLIST.


    <directive tail> ::=  <empty>

 This directive is equivalent to  %LIST OFF;  and is included to
 provide compatibility with other Simula implementations.


 1.3.11.  %NOSOURCE.


    <directive tail> ::=  <empty>

 Equivalent to %LIST OFF.


 1.3.12.  %OCTAL.


    <directive tail> ::=  ON  !  OFF

 The directive controls the use of octal notation for numbers, see
 section 5.3.3.







                                 9
 ^pg;
                      1. The Simula Compiler


 1.3.13.  %PAGE.


    <directive tail> ::=  <empty>

 Causes a form feed during listing, see section 1.4.


 1.3.14.  %PASS.


 For compiler maintenance use, see appendix E.


 1.3.15.  %RTSOPTIONS.


    <directive tail> ::=  = "<options>"

 When the compiler V option is set the <options> will be copied
 onto the generated @XQT control statement, see section 1.6.6.
 When compiler option D is set (or both D and V) the <options>
 will be permanently built into the run time system, see section
 1.7. In this case the <options> will not be copied onto the @XQT
 statement (if any).  A maximum of 18 options may be set in this
 manner. Note that only the lexically last directive of this type
 takes effect.  The directive may be abbreviated to %RTSOPS.


 1.3.16.  %SOURCE.


    <directive tail> ::=  <empty>

 Equivalent to %LIST ON.


 1.3.17.  %TITLE.


    <directive tail>  ::=  <heading control>
                       !   <margin control>
    <heading control> ::=  ,<options>  <heading text>
    <margin control>  ::=  ,M  <length>,<top>,<bottom>

 The directive controls the heading printed on top of each page of
 the listing as well as the margin setting on the printer. The
 directive is ignored if no listing option is given.

 The first form is equivalent to the EXEC control statement
  @HDG,H<options> <heading text> .  The second form performs a
 margin setting on the printer.  Both will force a form feed on
 the printer.









                                10
 ^pg;
                      1. The Simula Compiler


 1.3.18.  %XQTOPTIONS.


    <directive tail> ::=  = "<options>"

 This option is meaningful only when used under both D and V
 compiler options - it will otherwise be ignored. Only the last
 directive occuring in the source text takes effect.  The options
 are copied onto the generated @XQT-statement.  The directive may
 be abbreviated to %XQTOPS.



 1.4   _Source listing_ (S- and M-option).


 Listing of the updated source element may be obtained by means of
 compiler options S or M.  The print is generated during pass 1
 (syntactic analysis). This means that error messages from pass 1
 will be interspersed with the source lines thus giving a good
 indication of where the error was discovered. Error messages from
 later passes will be printed after the last line of the program
 listing generated.


 1.4.1.   S-option.


 The readability of the printed program may be improved by means
 of the compiler directives %TITLE, %PAGE and %INDENT.

 %TITLE    controls the number of lines printed on each page and
           the heading printed as the first line on every page.
           (see 1.3.17)

 %PAGE     will cause the printer to skip to the top of the next
           page.

 %INDENT = <unsigned integer>.  Each program line is printed
           preceded by a  number of spaces (zero or more), the
           current line indentation; initially this value is zero.
           Whenever BEGIN is recognised as a basic symbol the
           current line indentation will be increased by the
           indentation increment i.e. the following lines will be
           moved to the right.  After END has been  recognised as
           a Simula basic symbol the current line indentation will
           be decreased by the indentation increment i.e. the
           following lines will be moved to the left.
           The indentation increment is initially zero, but may be
           set to a positive value by means of this directive.

 %INDENT ON is equivalent to %INDENT = 4.

 %INDENT OFF will set the current line indentation as well as the
           indentation increment to zero i.e. restore the initial
           situation of exact copying of the source input to
           print. Note that this is not the same as just zeroing
           the indentation increment (which leaves the current
           line indentation unchanged).



                                11
 ^pg;
                      1. The Simula Compiler


 1.4.2.   M-option.


 The M-option has almost the same effect as S-option with the
 following exceptions:

 - If END is the first symbol on the line it will be moved one
   indentation step to the left. The effect is to place END under
   the corresponding BEGIN.

 - If a line starts with a label definition (label: ...) the line
   is moved one indentation step to the left so as to make labels
   stand out from the surrounding text.

 - Compiler directives (% in pos. 1) are not printed (but the line
   number is increased).

 - The initial setting of the indentation increment is 4 (see
   section 1.4.1).

 The M-option is intended for documentation purposes and may be
 extended in future releases following suggestions received from
 user programmers.



 1.5   _Object program listing_ (L option).


 The generated object program may be listed in (pseudo) assembler
 format during the code generating pass by means of the compiler
 directive %CODE. Option L enables this feature.  It will also
 cause the generated collector program to be listed (see section
 1.6.1).

 The listing is controlled by means of the compiler directive
 %CODE. Note that the initial setting of the %CODE switch is OFF
 i.e. no object program listing will be generated unless
 explicitly called for by the directive line %CODE ON; .  Use of
 this facility enables the programmer to inspect (parts of) the
 generated code and in this way for instance evaluate the relative
 efficiency of alternate algorithms.

 In order to make it possible to relate the assembler program to
 the source program listing comments are inserted which identify
 the corresponding source lines.



 1.6   _Link and go_ (V and R options).


 In many cases compilation is to be followed immediately by
 execution of the translated program. The "load-and-go" feature
 has been included in order to releive the programmer of the
 tedious task to prepare the EXEC control statements required to
 produce and execute an absolute version of the program.

 Automatic link and execute after compilation is controlled by the
 compiler option V while the compiler option R enables the


                                12
 ^pg;
                      1. The Simula Compiler


 programmer to generate a relocatable module in which all external
 references to the programmers file have been resolved. If any of
 these options are used the compiler will assign a temporary file
 named "<project-id>*SIMULA$MAP".

 The contents of this file will depend upon the combination of
 options used as given in the following subsections, for a deeper
 understanding we refer the reader to (ref. 3).

 In the listings below <external-element-i> and <ro-element> refer
 to the complete element names (eg. <project-id>*TPF$.TEMP) while
 <ro-element-name> is the element specific part of the name only
 (eg. TEMP).

 If compiler option L is used the option "N" on the collector call
 statement will be replaced by "S". Likewise, if compiler option A
 is used the collector option "X" will be replaced by "A". If
 V-option is used and both program and data are read from the run
 stream the program must be terminated by the @EOF control
 statement.

 The library file S*I contains the Run Time System and must be
 included in the collection, except if the compiler is a system
 processor.  The actual name of the file from which the compiler
 was called is inserted instead of "S*I". Observe that the
 implication is that the compiler and the run time system should
 reside in the same file.

 External declarations lead to the generation of IN-directives as
 shown. The listings overleaf does not however show all generated
 LIB-statements. If an externally declared procedure or class
 resides in a file not previously LIB-ed a LIB directive for this
 file will be generated prior to the IN-directive. Up to 18 files
 may be automatically included in the collection in this manner.

 The generated ENT-directive may lead to a warning from the
 collector since the name NAME$ is predefined by the system. This
 warning will occur when no element-name is given on the processor
 call statement  since NAME$ is then used to identify the
 generated element. This warning may be ignored.






















                                13
 ^pg;
                      1. The Simula Compiler


 1.6.1.   Contents of SIMULA$MAP.


 V-option:

    @PREP user-file
    @MAP,INXT  ,<ro-element>
      LIB S*I.                      may be absent.
      ENT '<ro-element-name>'
      IN  <ro-element>
      IN  <external-element-1>      see section 1.6.4
      IN  <external-element-2>
      IN  ...
      LIB user-file-1               see section 1.6.4
      LIB user-file-2
      ...
      LIB S*I.                      may be absent.
      END
    @XQT,rts-options <ro-element>   see section 1.6.6

 R-option:

    @PREP user-file
    @MAP,INXTR ,<ro-element>
      LIB user-file
      NOT S*I.                      may be absent.
      DEF '<ro-element-name>'
      IN  <ro-element>
      IN  <external-element-1>
      IN  ...
      LIB user-file-1               see section 1.6.4
      LIB user-file-2
      ...
      END

 Both V- and R-option:

    @PREP user-file
    @MAP,INXT  ,<ro-element>
      LIB S*I.                      may be absent.
      ENT '<ro-element-name>'
      IN  <ro-element>
      IN  <external-element-1>
      IN  ...
      LIB user-file-1               see section 1.6.4
      LIB user-file-2
      ...
      LIB S*I.                      may be absent.
      END













                                14
 ^pg;
                      1. The Simula Compiler



 Both V- and D-option:

    @PREP user-file
    @MAP,INXT  ,<ro-element>
      LIB S*I.                      may be absent.
      ENT '<ro-element-name>'
      IN  <ro-element>
      IN  <external-element-1>
      IN  ...
      LIB user-file-1               see section 1.6.4
      LIB user-file-2
      ...
      LIB S*I.                      may be absent.
      END
    @XQT,xqt-options <ro-element> . - see section 1.6.6


 1.6.2.   Adding SIMULA$MAP.


 If the compilation is successful (no errors above level 2
 encountered) the file generated is inserted into the runstream
 via the control statement
    @ADD,P <project-id>*SIMULA$MAP .


 1.6.3.   Entry points in object modules.


 The entry point in an object module will always be defined as the
 name of the relocatable element generated. It is important to
 note two things:

 - when preparing an R-option compilation this is the only
   external name DEFined

 - this name is used by the run time system i.e. a manual
   collection prepared by the user must include the ENT (DEF)
   directive.


 The above can be summarised as follows. Use of compiler option V
 will generate an absolute element with the same name as that
 assigned as output element for the object program. If the
 compiler option R is not set this element will be executed. If
 the compiler option R is used without V option a relocatable
 object module will be generated overwriting the object module
 generated by the compiler. In the latter case neither S*I nor
 SYS$*RLIB$ will be searched for unresolved references.


 1.6.4.   RB-element inclusion.


 The inclusion of external-i and the corresponding LIB-statement
 will take place if the program contains an external declaration
 of a separately compiled program module (see also section 1.8).




                                15
 ^pg;
                      1. The Simula Compiler


 1.6.5.   Repeated executions.


 If more than one execution of the program is desired the
 programmer must provide additional control statements of the form
 "@XQT,<options> <ro-element-name>".

 This may lead to an error if the compilation was in error.  Note
 that in this case the options must be explicitly provided in the
 statement.


 1.6.6.   Options for the compiled program.


 If the user wishes to use the options given in the @XQT-statement
 for control of the program the compiler option D should be used
 so that the options will not be interpreted by the run time
 system.  In this case the run time system options must be set by
 means of of the directive %RTSOPTIONS (see section 1.3.15) and
 the user options is set by means of the directive %XQTOPTIONS,
 see section 1.3.18.

 If compiler option D is not used the options on the generated XQT
 statement are copied from the parameter string to %RTSOPTIONS and
 interpreted by the run time system, see chapter 2.  In this case
 the user has no possibility to employ options in order to direct
 his/her program control flow.



 1.7   _Processors in Simula_ (D-option).


 Under EXEC it is possible to employ a program as a processor by
 writing control statements of the form

               @abs-elem,options field-1,field-2,...

 In this situation the options field on the control statement is
 to be interpreted by the program and not by the Simula run time
 system.  The program may for example be a Simula compiler and the
 option V should in that case mean "load-and-go" and not "allocate
 16K words to the storage pool".

 A program compiled with compiler option D may be used as a
 processor or it may be executed through the @XQT control
 statement. In both cases the options specified on the calling
 statement are available to the program but has no significance to
 the Simula run time system.  The run time system options can in
 the case of D compiler option only be set through the compiler
 directive %RTSOPTIONS. They will then be built into the generated
 absolute element permanently and will be affected neither by the
 options given on the calling statement nor by the standard
 functions RTON and RTOFF.

 If both V and D compiler options are used the run time options
 (if any) are thus not inserted into the generated @XQT statement.
 It is possible to specify options to the executing program by
 means of the %XQTOPTIONS directive. The string of options will be


                                16
 ^pg;
                      1. The Simula Compiler


 copied from the (lexically last) directive to the generated @XQT
 statement.



 1.8   _Separate compilation_.


 The Simula language supports separate compilation of program
 modules as described by the syntax below (the abbreviations used
 are hopefully self-explaining):

    <Simula module> ::=  <module>
                     !   <ext decls> ; <module>
    <module>        ::=  <program>
                     !   <procedure>
                     !   <class>
    <ext decls>     ::=  <ext decl>
                     !   <ext decls> ; <ext decl>
    <ext decl>      ::=  <ext proc decl>
                     !   <ext class decl>
    <ext proc decl> ::=  EXTERNAL <func> <ext list>
                     !   EXTERNAL <proc> <ext list>
                     !   EXTERNAL LIBRARY <proc decl>
    <func>          ::=  <kind> <type> PROCEDURE
    <proc>          ::=  <kind> PROCEDURE
    <proc decl>     ::=  <procedure declaration>
    <kind>          ::=  ASSEMBLY
                     !   FORTRAN
                     !   <empty>
    <ext class decl>::=  EXTERNAL CLASS <ext list>
    <ext list>      ::=  <ext item>
                     !   <ext list> , <ext item>
    <ext item>      ::=  <identifier>
                     !   <identifier> = "<element name>"


 1.8.1.   The external declaration.


 An external declaration (<ext decl>) represents the complete
 declaration of a separately compiled procedure or class.  <kind>
 indicates the source language of the procedure, if empty the
 language is understood to be Simula. See sections 5.5 and 5.6.

 An external item (<ext item>) may be specified in two ways as can
 be seen. If no explicit EXEC element name (<elem name>) is given
 the identifier is taken as the element name.  NOTE: Since this
 identifier is used as an entry point name in the generated
 relocatable element, the length should be at most 12 characters.

 In case no file name is given, the (implicitly or explicitly)
 specified element is searched in the following files in the given
 order:

 1) SIM$PF (a USE-name attached by the user)

 2) The RO file

 3) the SI file


                                17
 ^pg;
                      1. The Simula Compiler


 4) The SO file.

 5) TPF$.

 6) RLIB$.

 The search is terminated when the element is found or when the
 list is exhausted.

 The EXEC element name must conform to the following format:

       <internal file name>.<element>/<version>

 Both the file name and the version name (incl. /) may be omitted.
 If given, the file must be assigned to the run.


 1.8.2.   Separate compilation of classes.


 If the outermost user block is a class the module is compiled as
 an external class. The result of the compilation will be 3
 elements:

 - the source output element SO,

 - the relocatable output element RO,

 - the attribute element.

 The attribute element is an omnibus type element containing the
 description of the class, it's local subclasses and variables.
 The external declaration (defined above) will cause the compiler
 to use this element as a definition of the <external item>.

 The language definition specifies that a class cannot be used as
 a prefix except at the block level on which it was declared. For
 this reason the block level must be specified when a class is
 precompiled.  This is done in the block level parameter (fourth
 field) on the compiler call statement, e.g. "@S*I.M,options
 si,ro,so,BL/4" for a class to be used on block level four. If the
 block level field is absent the block level is taken to be zero
 i.e. the class is intended to be used as a program prefix.

 All classes declared external in any module must have been
 compiled previously, otherwise the compilation will be terminated
 when the search (for the external element) fails.

 The use of separately compiled classes is checked by the compiler
 to ensure that the attribute structure is consistent, i.e.
 unchanged. The attribute structure is defined to be inconsistent
 in the following cases:

 - an attribute is removed,

 - a new attribute is introduced,

 - the name of an attribute is changed,

 - the type of an attribute is changed,


                                18
 ^pg;
                      1. The Simula Compiler


 - the order of the attributes is changed,

 - the class is compiled with I option, or

 - the maximum nesting depth of FOR-statements is changed.

 Inconsistencies can occur only if a separately compiled class
 utilises another separately compiled class via an external
 declaration and this latter class is re-compiled. Note however
 that if no changes are made to the attribute structure, it will
 still be consistent with no consequences for dependent classes.
 Changes may thus freely be done for instances in the statements
 of any separately compiled class.


 1.8.3.   Restrictions on labels.


 Labels occuring in the class body are normally attributes of the
 class.  The Univac Simula implementation does not implement this
 rule for separately compiled classes. Thus any label occuring in
 a separately compiled class is invisible after the compilation.
 See also 1.8.5.

 This restriction may be circumvented by the use of procedures.


 1.8.4.   Separately compiled procedures.


 Simula procedures may be compiled separately in the same manner
 as classes. In this case the specification of a block level, at
 which the procedure is to be used, is left as an option to the
 programmer.

 Note that only one procedure at a time may be compiled and that
 each procedure will be compiled into three separate elements just
 as described for classes above.

 The body of a separately compiled procedure must be either a
 block or a compound statement, i.e. the first symbol of the body
 will always BEGIN.


 1.8.5.   Notes on separate compilation.


 The separately compiled classes and procedures offer the
 programmer the possibility to program in a truly top-down manner.
 The algorithmic outline of the solution may be scetched by means
 of procedure and class "stubs" i.e.  procedures where only the
 procedure head is fully specified and the body - given to the
 stub as an empty statement developed at a later point  in time.
 The classes can be defined with a class body in a similar way,
 i.e only the class name, parameters and externally visible
 attributes need be given.

 Note that labels (which are class attributes with program point
 value) may change value when the class is re-compiled thus making
 the compilation inconsistent with earlier compilations.


                                19
 ^pg;
                      1. The Simula Compiler


 Furthermore the use of jumps to labels defined in the prefix is a
 bad practice since the flow of control cannot easily be followed
 through the program text. Univac Simula does therefore not treat
 labels in separately compiled classes strictly according to the
 language definition, such labels are not included as attributes
 and therefore never visible.

 External procedures which call each other in a recursive ring (A
 calls B calls A) can be realised by means of the stub mechanism.
 Without this feature it would not have been possible due to the
 fact that any external item declared in the module must be
 present in the EXEC file system.



 1.9   _Messages from the compiler_.


 At the initiation of the compilation the compiler will print an
 identification line in the following format:

 Simula <Clevel> <Slevel> <date> <time> <elt-cycle>

 where Clevel is the compiler identification (eg. 3R4) and Slevel
 is the level of the Univac System Library incorporated in the
 compiler.  This line is given in the standard EXEC format.  After
 termination of the compilation a line is printed giving
 information about the number of errors encountered and the number
 of errors above level 1 found:

 END SIMULA <Clevel>. <nl> LINES, <ne> ERROR(S).



 1.10  _Hardware Representation_.


 The Univac Simula hardware representation conforms to the
 standard for hardware representation of Simula programs. The main
 differences between the publication language as used in Common
 Base and the hardware representation language can be summarised
 as follows:

   Keywords are written without underline ie. as identifiers. This
   means that the keywords cannot be used as identifiers.

   The alphabet is the ISO standard code (Ascii). This is
   significant inside text and character constants.

   Basic Simula symbols must be contained in one line.

 The following sections give a more detailed overview of the
 hardware representation.


 1.10.1.  Identifiers and Keywords.


 The first character in an identifier must be a letter. The
 following characters may be letters, digits or underline. The


                                20
 ^pg;
                      1. The Simula Compiler


 compiler does not distinguish between upper and lower case
 letters in identifiers. Underline is significant but it is
 replaced internally by a minus since the underline character may
 cause trouble when printed (it may on some equipment be confused
 with the delete character and act as printer control). This has
 no significance for the programmer except that the names printed
 during a trace are taken from the internal representation.

 The following identifiers are reserved as keywords and cannot be
 used as names by the programmer. Only one spelling is given but
 the table includes all mixtures of upper and lower case (eg. do,
 Do, dO, DO are all reserved).


     ACTIVATE       EQV            LABEL          REACTIVATE
     AFTER          EXTERNAL       LE             REAL
     AND            FALSE          LONG           REF
     ARRAY          FOR            LT             SHORT
     AT             GE             NAME           STEP
     BEFORE         GO             NE             SWITCH
     BEGIN          GOTO           NEW            TEXT
     BOOLEAN        GT             NONE           THEN
     CHARACTER      HIDDEN         NOT            THIS
     CLASS          IF             NOTEXT         TO
     COMMENT        IMP            OR             TRUE
     DELAY          IN             OTHERWISE      UNTIL
     DO             INNER          PRIOR          VALUE
     ELSE           INSPECT        PROCEDURE      VIRTUAL
     END            INTEGER        PROTECTED      WHEN
     EQ             IS             QUA            WHILE
                                                  XOR (*)

 (*) XOR - exclusive OR - is not a standard Simula keyword but a
 special Univac Simula feature. Use of this keyword makes the
 program non-portable.

 Note that the <kind> of external declarations (which may be
 FORTRAN, ASSEMBLY or LIBRARY) is not included in the list above.
 These identifiers take on their special significance in
 connection with EXTERNAL declarations only and may be freely used
 elsewhere in the program text as ordinary identifiers. The use of
 COMPLEX is controlled by a compiler switch - see %COMPLEX
 directive.


 1.10.2.  Text and character constants.


 Since symbols cannot extend over more than one line the syntax of
 <string> has been changed. The change allows the inclusion in
 text and character constants of all ASCII codes. The syntax below
 is the standard Simula syntax.










                                21
 ^pg;
                      1. The Simula Compiler


    <string>        ::=  <simple string>
                     !   <string><separators><simple string>
    <simple string> ::=  " <char sequence> "
    <char sequence> ::=  <empty>
                     !   <char sequence><ASCII code>
                     !   <char sequence><not quote>
                     !   <char sequence><text quote>
    <ASCII code>    ::=  !<unsigned integer>!
                    Note that ! is not a meta-symbol here.
    <not quote>     ::=  <any printing char except ">
    <text quote>    ::=  ""
    <separators>    ::=  <space>  !  <end-of-line>
                     !   <separators><space>
                     !   <separators><end-of-line>
    <character designation> ::= <ASCII code>
                             !  <any printing character>

 A simple string must be contained on one line but long text
 constants may be included by concatenation of simple strings.

 The unsigned integer given as ASCII code must be less than 256.
 In case it is less than 128 it represents the corresponding ASCII
 character.  It cannot consist of more than three digits. If these
 conditions are not satisfied the construction is interpreted as a
 normal <char sequence>.  The special ASCII code quote is
 exclamation mark (!).


 1.10.3.  Numeric constants.


 In REAL constants the "basis of ten" symbol is represented by the
 ampersand character (&). In LONG REAL constants it is represented
 by &&, eg.

 3&+2    is equivalent to    300.0 (REAL)

 3&&+2   is equivalent to    300.0 (LONG REAL).
























                                22
 ^pg;
                      1. The Simula Compiler


 1.10.4.  Special symbols.


       Hardware    Explanation
         repr.

         AND
         EQV      equivalence operator
         IMP      implication operator
         NOT
         OR
       * XOR      exclusive or
         =
         >=       greater than or equal
         >
         <=       less than or equal
         <
         <>       not equal
         COMMENT
         !        alternative for COMMENT
         //       integer divide
         **       exponentiation operator
         *
         &        REAL basis-of-ten
         &&       LONG REAL basis-of-ten
       * #        octal constant mark


       *  marks non-standard operators

































                                23
 ^pg;
                      1. The Simula Compiler


 1.10.5.  Predefined Identifiers.


 Below is a table of all predefined identifiers in the Univac
 Simula system. All identifiers below may be freely redefined by
 the programmer.


    ABS         * FILE          LOCATE        PUTINT
    ACCUM         FIRST         LOCATION      PUTLREAL
    ARCCOS        FOLLOW        LOG           PUTREAL
    ARCSIN                      LOWTEN
    ARCTAN        GETCHAR                     RANDINT
    ARCTAN2       GETFRAC       MAIN          RANK
    ATTACH        GETINT      * MAX           RE
                  GETREAL     * MIN           RESUME
    BLANKS                      MOD         * RTOFF
                  HEAD          MORE        * RTON
    CALL          HISTD                     * RTOPT
    CANCEL        HISTO         NEGEXP
    CARDINAL      HOLD          NEXTEV        SETPOS
    CARDFILE                    NORMAL        SIGN
    CBRT          ID                          SIMSET
    CHAR          IDLE          OPEN          SIMULATION
    CLEAR         IM            OUT           SIN
  * CLOCK         IMAGE         OUTCHAR       SINH
    CLOSE         INCHAR        OUTFILE       SPACING
  * COM           INFILE        OUTFIX        SQRT
    COPY          INFRAC        OUTFRAC       STRIP
    COS           INIMAGE       OUTIMAGE      SUB
    COSH          ININT         OUTINT        SUC
  * CSF           INREAL      * OUTLREAL      SYSIN
    CURRENT       INTEXT        OUTREAL       SYSOUT
                  INTO          OUTTEXT
  * DATE          INTOCORE                    TAN
    DETACH        ISOCHAR       PASSIVATE     TANH
    DIGIT         ISORANK       POISSON       TERMINATED
    DIRECTFILE                  POS           TIME
    DISCRETE      LAST          PRECEDE     * TIMEUSED
    DRAW          LASTITEM      PRED
                  LENGTH        PREV          UNIFORM
    EJECT         LETTER        PRINTFILE
    EMPTY         LINE        * PRLINE        WAIT
    ENDFILE       LINEAR        PROCESS
    ENTIER        LINESPERPAGE* PUNCHFILE
    ERLANG        LINK          PUTCHAR
    EVTIME        LINKAGE       PUTFIX
    EXP           LN            PUTFRAC


  *  marks non-standard identifier











                                24
 ^pg;
                      1. The Simula Compiler


 1.10.6.  Comment conventions.


 Comments may be included in the source text in several ways. They
 may be explicitly included by means of the construction

     COMMENT <any character sequence not containing ;> ;
     (COMMENT may be replaced by exclamation mark '!')

 This construction is equivalent to a space i.e. the compiler will
 replace such a sequence with a space before the actual analysis
 of the source text is performed. That means that comments (of
 this kind) may occur anywhere that a space may. But of course you
 should note that inside text constants no keywords are
 recognised, the text will be taken litterally.

 Another useful way of including (short) comments is by means of
 the "END-comment" facility, thus

     END <seq. without END,ELSE,WHEN,UNTIL,OTHERWISE or ;>

 will be replaced by END before the analysis.

 It is furthermore possible to annotate the program by utilising
 the "percent blank" convention, since a line with the character
 '%' in position 1 immediately followed by a blank will be
 completely ignored by the compiler. If compilation speed is of
 importance, this way of including comments is recommended since
 only the first two characters of the line are scanned.

































                                25
 ^pg;



 2   THE RUN TIME SYSTEM.


 The run time system (RTS) is a library of relocatable support
 routines which may be activated during the excution of a Simula
 program.  Only those elements which are actually required by a
 program are present during its execution. The effective size of
 the run time system thus varies from program to program depending
 upon the features employed.  The functions provided by the run
 time system include:

       Program initiation and termination

       Dynamic storage management

       Procedure calling and class generation

       Parameter transmission

       Text and file handling

       Quasi parallel sequencing

       Administration of SIMSET and SIMULATION

       Standard procedures

       Run time error handling

       Tracing of program execution

       Administration of concurrent programs.



 2.1   _Collection of Simula programs_.


 Normally, the file S*I contains the RTS library, and it is linked
 to the program when the executable program is collected. It is
 necessary to specify the program entry point explicitly to the
 collector by an ENT directive. The symbol given as entry point
 must be the name of the relocatable element containing the
 program.

 A minimal run stream for the compilation of a Simula program
 consists of the following, assuming no EXTERNAL declarations
 apart from LIBRARY procedures (app. A contains more examples):














                                26
 ^pg;
                      2. The Run Time System


       @S*I.M,IQ   ,MAIN
          begin
          ...
          ...     (program text)
          ...
          end
       @MAP,IN    ,ABS
          LIB  S*I.
          IN   MAIN
          ENT  MAIN
          END
       @XQT,<rts-options>  ABS
       ...
       ...  (data)
       ...
       @FIN


 If separately compiled modules have been referenced from the
 program they should be included in the collector program with IN
 directives.  If modules thus included reference other separately
 compiled programs these latter program elements must also be
 included, either through additional IN directives or through LIB
 directives.



 2.2   _Execution of the object program_.


 The object program may be executed either as a processor or by
 means of an XQT statement (which in the case of compiler V-option
 is generated and added by the compiler):
    @XQT,<options>  <program name>

 The program name must be the name of an absolute element. The
 interpretation of the options field is described in the following
 section.



 2.3   _Options_.


 It is very important to make a clear distinction between the
 options interpreted by the run time system (RTS-options) and the
 options that the programmer may use to direct the course of
 execution of his/her program (XQT-options). In case the
 programmer wish to employ the latter possibility it is
 recommended that the program be compiled with compiler option D
 (see section 1.7) and the RTS-options built into the generated
 object program by means of the %RTSOPTIONS directive.

 In that case the programmer is free to use all letters as
 XQT-options - these may be read by the program through a call to
 the standard LIBRARY procedures PROP and PROPS (see chapter 9).
 Otherwise (no D-option compilation) the option set which the
 program may use is very limited as described in the following
 section.



                                27
 ^pg;
                      2. The Run Time System


 The course of execution of the RTS part of the Simula program may
 be partly directed by options, the so called RTS-options. The
 complete list of valid options follows:

  B   begin block tracing
  C   disregard 5 percent storage limitation
  D   diagnostic dumps
  E   walk back trace should produce dumps
  F+  interrupt big dump
  G   print garbage collector information
  H+  SNAPSHOT implies big dump
  I   initial dump
  J+  pre-garbage-collection big dump
  K   abort all activities in case of error
  L   snapshot before and after garbage collection
  N   suppress warning messages
  P+  post-garbage-collection big dump
  Q   quasi-parallel tracing
  R*  initiate with continuos SYSOUT print
  S*  send SYSOUT to alternate printfile
  T*  enable tracing system
  U*  request 32K for data storage pool
  V*  request 16K for data storage pool
  W*  request  8K for data storage pool
  X*  request  4K for data storage pool
  Y*  request  2K for data storage pool
  Z*  request  1K for data storage pool

   *  - marks static options, see below.
   +  - generates a complete dump of the data storage!

 If the program is compiled without compiler option D only option
 letters A,M and O may be used freely by the program.

 Run time options may be set as follows:

 1)    by the <options> field of an XQT statement. The options may
       be given in any order without intervening blanks.
       Repetition of options will be interpreted as a single
       occurence of the option.  This method cannot be used if the
       program was compiled with the D-option.
 2)    by an %RTSOPTIONS directive to the compiler. This method
       should be used in conjunction with the compiler option D,
       see section 1.7.
 3)    by calling the standard procedures RTON and RTOFF during
       execution.  This may be done for a subset of the options
       only.

 The run time system options fall into two categories. The first
 contains options which initialise conditions that have to remain
 invariant during execution. Options in this category can only be
 set by methods 1 and 2 above, they cannot be switched on or off
 dynamically. Options in this category are marked with an asterisk
 in the list above.

 The second category controls facilities which can be switched on
 or off during execution. These options may be set by any of the
 methods mentioned above, they are unmarked in the list above.




                                28
 ^pg;
                      2. The Run Time System


 2.4   _Separate SYSOUT files_ (option S).


 In the absence of RTS-option S the standard system file PRINT$
 will be employed as SYSOUT printfile. The run time system will
 however always use PRINT$ as the system message file. Messages
 from the run time system (initiation and termination of
 execution, tracing etc.) will then be interspersed with the
 user's output.

 It may be important that the program output is not disturbed by
 system messages. The S-option is provided for this purpose and
 its use results in the RTS sending SYSOUT to an alternate
 printfile. For user convenience the RTS does not require user
 specification of the file to be used.  The run time system will
 construct a file name by concatenating the word "SYSOUT" with the
 name of the relocatable program element. If, for example this
 name is NAME$ the file name generated will be SYSOUTNAME$.

 If a file with this generated name is assigned to the run it will
 be used as the SYSOUT file.  If no such file is assigned the run
 time system will check whether the generated name already belongs
 to a catalogued (unassigned) file.  If that is the case the
 generated name will be altered systematically (by substituting
 the first letter of the name with A-Z successively) until a
 unique name has been found. This name is then used to identify
 the alternate SYSOUT print file.



 2.5   _Program tracing_.


 The tracing system provides, on request, a trace of the execution
 of the program or parts of it. When the facility is switched on
 (see below) tracing messages are printed at the occurence of

       block entry and exit
       procedure entry and exit
       class generation and termination
       GOTO non-local label

 Each tracing message contains a source text line number followed
 by a description of the message's origin. Messages involving
 classes and procedures contain the first 12 characters of the
 class/procedure identifier. In case of traced GOTO-statements the
 line number of the label definition is printed.

 If the program has been compiled with compiler Z-option, the line
 number information is not available, and zeroes will be given.

 Since the tracing feature is controlled exclusively by run time
 system options, it may be used without necessarily recompiling
 the program.

 If tracing is required T-option must be set when the program
 execution commences. This will force program execution in trace
 mode but the printing of messages does not occur unless further
 options are set.  Execution in trace mode is necessarily somewhat
 slower than in normal mode, therefore the T-option should not be


                                29
 ^pg;
                      2. The Run Time System


 used in normal production runs.

 If T-option is set, message printing begins when B-option is
 switched on and continues until B-option is switched off.
 Selective tracing is obtained in this manner, utilising the
 standard procedures RTON and RTOFF. The setting of the B-option
 is never tested by the run time system unless T-option is set.



 2.6   _Storage allocation_.


 On entry to a Simula program, RTS will request an area of storage
 which is used subsequently as the run time data storage pool. The
 size of this pool is determined by the setting of the RTS-options
 U-Z. Each of these represent a multiple of 1024 words as follows:

       U: 32K                X: 4K
       V: 16K                Y: 2K
       W:  8K                Z: 1K

 The effect of combining these options is the addition of the
 corresponding storage sizes thus allowing the allocation of
 storage pools up to 63K words. Repetition of option letters will
 be interpreted as a single occurrence of the letter. In case the
 user provides no such options, the options WY are set i.e. 10K
 will be available.

 It should however be noted that the actual size of the storage
 pool may be less than that required through the RTS-option
 setting. During program execution a certain amount of descriptive
 information must be available to the run time system. In the
 interest of economy, several such items are frequently packed
 into one word. For this reason there are physical limits imposed
 upon the size of such items. The address of the last word of the
 storage pool must for instance never exceed 0240000(octal) - this
 seldom creates problems.

 The pool is allocated in the D-bank (first address
 040000(octal)). Thus the maximum 63K can be allocated in normal
 cases without exceeding the pool address limit. However, one of
 two cases may cause this limit to be violated. If the user
 program is so large that I-bank addressing exceed 040000(octal)
 attempts to allocate large data pools will fail. Secondly the
 litterals occuring in the program will be allocated in the D-bank
 thus reducing the available space for dynamic allocation. Of
 especial interest in this context are text constants.

 The run time system will detect the cases mentioned above and
 reduce the user storage request to the maximum pool that fits the
 above mentioned restrictions.

 During execution, storage is allocated dynamically from the pool
 as and when required. Storage allocation may take place in many
 different contexts most of which can be classified under the
 following headings:

       block entry
       procedure entry


                                30
 ^pg;
                      2. The Run Time System


       object generation (NEW)
       array declaration
       text object generation
       event scheduling.

 Due to the block structure orientation of the Simula language it
 is possible at certain points (block and procedure exits among
 others) to de-allocate some or all of the acquired storage
 blocks. It is however not practical to release the storage areas
 immediately. The occupied part of the storage pool is allowed to
 increase steadily until a storage request cannot be satisfied. At
 this point the storage regeneration process ("garbage
 collection") is invoked, releasing all unused objects in the
 pool, thereby increasing the size of the available pool storage.

 The storage regeneration may be a rather time-consuming process
 (depending upon the program structure etc) and it is therefore
 desirable to minimise its occurences. The frequency of
 activations is inversely related to the amount of storage
 released. It is thus possible to get into a situation in which
 most of the execution time will be spent in garbage collection.
 In order to avoid such situations the run time system will
 terminate the program with an error message if less than 5
 percent of the pool is released during storage regeneration. The
 storage request should be increased in future runs. This check
 may be overridden by the use of RTS-option C, execution will then
 terminate only when the pool is completely exhausted (or the
 program terminates normally of course).

 The execution time spent doing storage regeneration is indicated
 to the user by a standard message appearing after program
 termination.  It is important to note that although the garbage
 collector may have been invoked several times during program
 execution, the time spent may not necessarily be related to that
 count.

 By setting RTS-option G the user may request a message each time
 garbage collection occurs. The message indicates where in the
 source text the garbage collection occurred and the storage
 available on entry and exit. The garbage collection type is also
 printed, indicating the context which initiated the storage
 request.




















                                31
 ^pg;



 3   ERROR MESSAGES AND DIAGNOSTICS.




 3.1   _Messages from the compiler_.


 The compiler will perform a complete syntactic and semantic check
 of the source code in order to ensure that it is in accordance
 with Common Base Simula as extended under OS1100.

 Each message is associated with an error level between 0 and 5.
 The level corresponds to the severity of the error and reflect
 the compiler's ability to recover as explained in appendix B.

 In many cases the compiler is able to detect situations which,
 although in strict accordance with the language definition, never
 the less are sufficiently unusual to be worth bringing to the
 programmer's attention. Examples are boolean expressions which
 always evaluates to a constant value, repeated evaluation of
 expressions, dead code etc.  In such cases the compiler will
 issue a message called a "note".  The note takes the form of an
 error message but there are no effects upon the validity of the
 generated code. The generation of notes is suppressed, if the
 compiler option N is set. All notes are included in appendix B.



 3.2   _Messages from the Run Time System_.


 While the compiler treats each abnormal situation in a manner
 that depends on the specific error as explained in app. B, the
 Run Time System treats all errors as fatal i.e. execution of the
 offending program is terminated.

 Execution of a Simula program may be terminated for a number of
 reasons.  Whenever this occurs, a message is given explaining the
 reason of the abnormal termination. The text of these messages
 are given in appendix C.

 Most of these messages are self explaining. We draw the attention
 especially to message number 25: SOURCE LANGUAGE ERROR. This
 message will occur whenever a program is executed in spite of
 error messages from the compiler, if the erroneous construction
 is executed.















                                32
 ^pg;



 4   DEVIATIONS FROM THE SIMULA STANDARD


 The standard language (Common Base Simula) has been augmented in
 the Univac implementation by a few useful constructions and
 standard procedures. The details of the procedures are given in
 chapter 9.  In some cases language restrictions have been
 relaxed, these cases are mentioned in the relevant sections in
 this manual. The compiler will issue "notes" (see chapter 3) to
 warn the user that such a construction makes the program
 non-transferable to other Simula systems.



 4.1   _The DO-UNTIL statement_.


    <DO-UNTIL-stat>  ::=  <DO-loop> <exit-condition>
    <DO-loop>        ::=  DO <statement>
    <exit-condition> ::=  UNTIL <boolean expression>
                      !   <empty>

 The DO-UNTIL statement is very similar to the WHILE statement.
 The <statement> of the loop will be executed repeatedly until the
 <boolean expression> becomes TRUE, i.e. the statement is always
 executed at least once. If the <exit-condition> is empty the
 repetition will go on forever or until some effect of the
 <statement> (e.g. a GOTO) leads to a termination.

 There are no restrictions on labels occuring on or within the
 <statement>.



 4.2   _Additional types_.


 Univac Simula extend the basic set of value types of Common Base
 Simula with the arithmetic type COMPLEX. In addition INTEGER may
 be prefixed with one of the keywords LONG or SHORT, this has no
 effect however and is implemented solely to offer compatibility
 with other Simula implementations.

 COMPLEX quantities are structured with two attributes, RE and IM,
 representing the real and imaginary part of a complex number
 respectively.  The attributes are implemented as REAL quantities.
 COMPLEX constants are written as a pair of REAL constants
 separated by a comma and surrounded by the brackets < and >.

 For further details, see chapter 5.



 4.3   _Octal notation_.


 Numeric constants may be given in octal notation. In this manner
 the full machine resolution on real (and double real) numbers may
 be utilised, and integer bit patterns can be specified. An octal
 constant is written as an unsigned integer preceded by the


                                33
 ^pg;
              4. Deviations from the Simula standard.


 character #.



 4.4   _Class PUNCHFILE_.


 This predefined class is used to represent a file which is
 oriented towards punched card output. The class use the PNCHA$
 feature of EXEC.

 Interms of the output operations available to the user, class
 PUNCHFILE functions in the same way as class OUTFILE. However, at
 the time of a call on OUTIMAGE, IMAGE must reference a main text.

 The physical file considerations concerning file assignment and
 queueing for punching parallel exactly those of class PRINTFILE.



 4.5   _Class FILE_.


 This class is visible to the user in the Univac implementation.



 4.6   _Attribute protection_.


 This recommended extension to Common Base Simula is not
 implemented.  Use of the keywords HIDDEN and PROTECTED will be
 checked for syntactic correctness, and then the constructions
 will be deleted.



 4.7   _Virtuality of standard procedures_.


 The standard procedure attributes of the file classes (e.g.
 OUTIMAGE) are not implemented as virtual procedures, see chapter
 6.



 4.8   _Expression evaluation_.


 Boolean expressions are not evaluated strictly in accordance with
 the language definition. For efficiency reasons and for reasons
 of programming convenience, such expressions are evaluated from
 left to right until the evaluation result is certain; the
 remainder of the expression constituents will not be evaluated.
 This is a significant deviation in case boolean procedures with
 side effects occur in the unevaluated part.






                                34
 ^pg;
              4. Deviations from the Simula standard.


 4.9   _FOR statement_.


 The evaluation of STEP-UNTIL elements deviate slightly from
 standard Simula, since all control arithmetic is executed in the
 type of the controlled variable. This may e.g. be significant in
 cases where the until-expression is of type (long) real and the
 controlled variable is integer, since the rounding of the
 expression value may result in one extra iteration of the loop:
     FOR int := 1 STEP 1 UNTIL 0.7 DO <statement> - the statement
 will be executed once since 0.7 is rounded to 1 before the test
 is performed.

 The programmer is thus advised to avoid type-mixing in the for
 list elements; the compiler will generate warning 180 when such
 potentially dangerous situations are detected.














































                                35
 ^pg;



 5   IMPLEMENTATION DEPENDENT FEATURES




 5.1   _Physical limitations_.




 5.1.1.   Precision of numeric items.


 The ranges of arithmetic quantities are given in the table below
 expressed by the maximum positive number that may be represented,
 the ranges are symmetric around zero:


                 decimal max.      binary max.

    INTEGER      34359738367       2**36 - 1
    REAL         1.7014118&+38     (1-2**(-27)) * 2**127
    LONG REAL    approx 10**306    (1-2**(-60)) * 2**1023
    COMPLEX         - as REAL for each attribute -


 INTEGER arithmetic is performed exactly in one-complement binary
 arithmetic. The precision is 35 binary digits (plus sign), i.e.
 approximately 11 decimal digits.

 REAL and LONG REAL arithmetic is performed in single and double
 length floating point respectively. Floating point truncation
 errors, overflow and underflow can occur. All operand are
 expected to be normalised. REAL and LONG REAL quantities have
 precisions of 27 and 60 binary digits in the mantissae, and 8 and
 11 binary digits in the exponents, respectively, i.e.
 approximately 8 and 18 significant decimal digits at most.


 5.1.2.   Zero.


 Due to the one-complement arithmetic of the 1100-series hardware,
 zero may be represented both as +0 and -0 (binary zeroes and
 binary ones resp.). The Simula run time system does not
 distinguish between these two, ie. both are considered the same.


 5.1.3.   Arithmetic relations.


 Most relations are evaluated by subtracting one operand from the
 other and inspecting the result. Overflow may occur during the
 subtraction, therefore if the operands are of opposite sign, the
 sum of their absolute values must not exceed the maximum possible
 number for the type.






                                36
 ^pg;
               5. Implementation Dependent Features


 5.1.4.   Program, array and text objects.


 The number of words occupied by these objects may be computed
 from the information given in chapter 10. A program object must
 not exceed 4095 words. An array may have at most 9 subscripts.
 The length of a text value cannot exceed 87370 characters.



 5.2   _Types and type conversion_.


 The following types are defined in OS1100 Simula:

       INTEGER               BOOLEAN
       REAL                  CHARACTER
       LONG REAL             TEXT
     * COMPLEX               REF

     *)  COMPLEX is not a standard Simula type

 In addition INTEGER may be prefixed with LONG or SHORT, this has
 no significance for the generated object program, but is provided
 solely to offer compatibility with other Simula implementations.

 The arithmetic operations are defined for all the numeric types.
 Mixed type expressions and assignments are supported, provided
 that the quantities involved have compatible types, see below.

 An arithemtic expression is evaluated following the rules in
 Common Base Simula. Please observe that these rules not
 necessarily specify a strict left-to-right evaluation order, and
 accordingly the compiler may do some re-ordering of the
 expression in order to optimise register usage. If the evaluation
 order is essential (e.g. because of side effects) the programmer
 must explicitly specify this order by braking up the expression
 using temporary variables.

 The criteria which determines the type associated with the result
 of the evaluation of an arithmetic expression are listed below in
 precedence order (1 is highest):

 1  INTEGER    if the final step is // (integer divide)
 2  COMPLEX    if at least one operand is COMPLEX
 3  LONG REAL  if at least one operand is LONG REAL
 4  LONG REAL  if an INTEGER is raised to an INTEGER power
 5  REAL       if at least one operand is REAL
 6  REAL       if there is a division (/)
 7  INTEGER    otherwise

 Type conversions may be invoked during operations on numeric
 operands.  Nonnumeric types are only compatible with themselves
 and no type conversions are defined for them. Observe that type
 compatibility is non-commutative, E.G. a REAL may be assigned to
 a COMPLEX but not vice versa.






                                37
 ^pg;
               5. Implementation Dependent Features


                        Type Conversion Table.


             to:  INTEGER     REAL   LONG REAL   COMPLEX
    from:
                 --------------------------------------
    INTEGER     !    -    !    CT   !    C    !    CT  !
                !---------+---------+---------+--------!
    REAL        !   CRE   !    -    !    C    !    C   !
                !---------+---------+---------+--------!
    LONG REAL   !   CRE   !   CTE   !    -    !   CTE  !
                !---------+---------+---------+--------!
    COMPLEX     !  undef. !  undef. !  undef. !    -   !
                 --------------------------------------

                    C:  type conversion defined
                    T:  truncation may take place
                    R:  rounding may take place
                    E:  error if result is out of range


 Type conversion of variables is performed at run time,
 accordingly considerable improvements in execution speed may be
 achieved by avoiding unnecessary type mixing in expressions. Type
 conversion of constants is performed at compile time.



 5.3   _Constants and constant expressions_.


 In addition to the normal specification of a constant, numeric
 constants may be specified directly in octal notation.
 Furthermore OS1100 Simula adds LONG REAL and COMPLEX constants to
 the language.

 During the compilation, each constant is represented internally
 as a quantity of the relevant type. This internal constant may be
 truncated when it is read from the source program, either because
 too many decimal places was provided or because the constant
 cannot be represented exactly in binary notation. This internal
 representation may subsequently undergo type conversion if it
 occurs in a mixed-type context.


 5.3.1.   LONG REAL constants.


 The syntax of a LONG REAL constant follows that of REAL constants
 except that double ampersand (&&) is used as "low-ten" symbol,
 e.g.

       3.7&+10     is a REAL constant
       3.7&&+10    is a LONG REAL constant

 The REAL constant A&B will be taken as a LONG REAL constant if
       - the mantissa A contains more than 8 significant digits
       - the absolute value is larger than 1.7014118&+38




                                38
 ^pg;
               5. Implementation Dependent Features


 5.3.2.   COMPLEX constants.


 COMPLEX constants are written as pairs of constants surrounded by
 the brackets < and >:

    <complex number> ::= <  <RE part> , <IM part>  >
    <RE part>        :=  <signed number>
    <IM part>        :=  <signed number>

 The <signed number> will be converted to a REAL constant by the
 compiler.


 5.3.3.   Octal notation.


 The exact internal binary representation of a numeric constant
 may be specified using octal notation:

    <octal number>  ::=  #<sequence of octal digits>
                     !   #<sequence of octal digits>R

 If the R is included the constant is of REAL or LONG REAL type,
 otherwise it is INTEGER. It will be LONG REAL if there are more
 than 12 digits given. The sequence of octal digits will be
 right-justified and padded with zeroes if necessary.  This is a
 non-standard facility.



 5.4   _Initialisation of variables_.


 When, at run time, execution passes the declaration of a variable
 it will be initialised according to it's type as follows:

       INTEGER               0
       REAL                  0.0
       LONG REAL             0.0
       COMPLEX               <0.0,0.0>  (i.e. 0.0 + 0.0i)
       TEXT                  NOTEXT
       REF                   NONE
       CHARACTER             null  (ie. '!0!')
       BOOLEAN               FALSE

 - these initialisations corresponds to the fact that available
 storage is zero-filled before allocation.



 5.5   _Linkage to Fortran_.


 It is possible - by means of the appropriate EXTERNAL
 declaration, see section 1.8 - to call procedures written in
 other languages than Simula from a Simula source module. In this
 section linkage to Fortran subprograms are treated, section 5.6
 addresses assembly language procedures.



                                39
 ^pg;
               5. Implementation Dependent Features


 Important note: without a very thorough knowledge of the SIMULA
 system it can be very dangerous to use expressions or procedure
 names as actual parameters to such procedures. We therefore
 strongly recommend the usage of simple variables or constants
 only.

 The compiler will generate the following call sequence to a
 Fortran subroutine or function FORSUB:

           LMJ   X11,H$FTN$.     entry in Simula RTS
           +     <line number>,<number of parameters>.
  FRETURN  LMJ   X11,FORSUB.
           +     0,<address of first parameter>.
           +     0,<address of second parameter>.
           ...
           +     0,<address of last parameter>.
           +     <line number of call>,0 .
  ARETURN  ...

 The run time system routine H$FTN$ will return to either FRETURN
 in case Fortran V linkage is established (i.e. Fortranmode(0) was
 called), or to ARETURN in case Ascii Fortran linkage is in
 effect. A more complete description is given below.


 5.5.1.   Fortran V (FOR) procedures.


 In case the fortran mode switch is set to zero, the RTS routine
 H$FTN$ will return immediately (i.e. to FRETURN), thus Fortran V
 subprograms are called with a minimum of overhead.

 Parameters of the following types are accepted:

       INTEGER       COMPLEX     CHARACTER
       REAL          BOOLEAN     TEXT
       LONG REAL     LABEL       <type> ARRAY

 Extreme care should be taken when using TEXT parameters. Only
 references to main texts should be transmitted, and the
 programmer is strongly advised against returning new or modified
 text values.  CHARACTER parameters may be manipulated as integers
 within the Fortran program.

 When an ARRAY parameter is transmitted, the address points to the
 first array element, regardless of the subscript bounds.

 Non-local LABELs are not permitted as parameters.

 Fortran V functions of the following types are permitted:

       INTEGER     COMPLEX     CHARACTER
       REAL        BOOLEAN     TEXT
       LONG REAL

 Run time errors detected by programmed tests in Fortran
 subroutines are handled by the Fortran error handling routine.
 The "walk-back" feature functions normally, and the last message
 will give the line number in the Simula program from which the
 subroutine was called (in octal).


                                40
 ^pg;
               5. Implementation Dependent Features


 Errors detected by hardware (eg. divide check) are handled
 exclusively by the Simula error handling routine. The line number
 given refers to the line of call.


 5.5.2.   Ascii Fortran (FTN) procedures.


 Linkage to Ascii Fortran (FTN) subroutines or functions is
 generated if a call on the
    EXTERNAL LIBRARY PROCEDURE Fortranmode(switch);
    INTEGER switch;
    ;
 is done with the value 1 (one) as parameter. Return to Fortran V
 mode is effected by a value of 0 (zero); this is the default
 setting. Note that the linkage is generated dynamically during
 program execution.  Fortranmode(1) will initialise the FTN run
 time system by a call on FINT2$.

 Entry to the Ascii Fortran subroutine is done by H$FTN$ in the
 following manner:

       LN,U  A1,1.
       L     A0, (<npar>,PTAB).   or zero if no parameters
       LMJ   X11,FORSUB.
       ...
       J     ARETURN.
  PTAB  +     <address of first parameter>.
        +     <address of second parameter>.
        . . .
        +     <address of last parameter>.
        + 0 . type word for first parameter
        ...
        + 0 . type word for last parameter

 Multibanking of Ascii Fortran routines is not supported.

 All errors detected by the FTN run time system or by hardware are
 handled by the Fortran contingency interrupt handler.

 Because the Simula compiler place all literal parameters in the
 instruction bank, and because the FTN run time support system is
 resident partly in a separate instruction bank, all literal
 parameters are moved to the Simula data bank before the FTN
 subprogram is activated.

 Since the external declaration of the FTN subprogram does not
 contain type information, all parameters are transferred as
 NOTYPE (i.e. the parameter check of FTN is suppressed). For the
 same reason, use of FTN character parameters is strongly
 discouraged, and a FTN function which return character value,
 will simply not work. TEXT and CHARACTER parameters may be
 transferred, but use caution!

 The recommended function and parameter types are thus:

        INTEGER, COMPLEX, REAL, LONG REAL, and BOOLEAN

 The (considerable!) overhead necessary is performed by H$FTN$ and
 consist of the following tasks:


                                41
 ^pg;
               5. Implementation Dependent Features


       - save SIMULA registers
       - zero type words
       - copy the parameter addresses to PTAB
       - move literals
       - build the FTN call packet
       - load the FTN register set
       - set Q-mode and clear arithm. interrupt (LPD)
       - call the FTN subprogram
       - clear Q-mode and set arithm. interrupt (LPD)
       - save FTN registers
       - re-activate SIMULA interrupt routine
       - restore SIMULA registers



 5.6   _Assembly language procedures_.


 The Simula compiler may generate two different linkages to
 procedures programmed in assembly language, depending upon the
 external declaration of the procedure.  Apart from the parameter
 transmission mechanism and the return point the same rules govern
 the programming and inclusion of both LIBRARY and ASSEMBLY
 assembly procedures.

 Important note: without a very thorough knowledge of the SIMULA
 system it can be very dangerous to use expressions or procedure
 names as actual parameters to such procedures. We therefore
 strongly recommend the usage of simple variables or constants
 only.

 The following restrictions should be kept in mind when an
 assembly language procedure is programmed:

 - The name of the entry point to the assembly procedure must be
   identical to the procedure name given in the external
   declaration.

 - All registers, apart from A0-A5,X11,R1-R3, must have precisely
   the same contents on exit as on entry.

 - If the procedure should be used as a function, the result must
   be transmitted in register A0 (and A1 if necessary).

 - MCORE$ and LCORE$ must never be used in an assembly procedure.

 - Pointers transmitted as parameters should never be stored and
   used later (in another call), since the garbage collector may
   have moved the objects around between calls, and it is unable
   to find locally stored pointers - thus they will not be updated
   to the correct value.  TEXT, REF, LABEL, ARRAY, PROCEDURE and
   SWITCH parameters are pointers in this context.

 When an assembly procedure is entered register X1 will point to
 the object containing the call (see chapter 10 for details on
 object formats).






                                42
 ^pg;
               5. Implementation Dependent Features


 5.6.1.   EXT. LIBRARY <type> PROCEDURE.


 The code sequence generated for call upon a LIBRARY procedure is

       <load parameters (if any) into registers>
       LMJ   X11,<procedure name>.
       ...   <return to  0,X11>

 The external declaration of a LIBRARY procedure includes normal
 parameter specification and a dummy procedure body.

 Parameters are transmitted to the procedure in registers A0-A5,
 the first parameter in A0, the next in A1 etc. LONG REAL, COMPLEX
 and TEXT parameters not called by name occupy two registers each.
 Thus the number of possible parameters is limited to (at most) 6.
 Each parameter to an actual call is checked by the compiler to
 ensure compatibility with the formal specification given in the
 external declaration.

 The programmer is advised against using by-name or by-reference
 transmission of LABEL, SWITCH or PROCEDURE parameters since
 correct use requires an intimate knowledge of the run time system
 outside the scope of this manual.


 5.6.1.1.   Parameters called by value.


 The value is transmitted in the register(s). If the parameter is
 of type TEXT, a copy of the text value is generated and the
 registers contain the text descriptor of this text object.
 Likewise, an ARRAY parameter will enforce the creation of a new
 array object containing a copy of the parameter value, but in
 this case the register will contain the FPA-address of the object
 (see chapter 10).


 5.6.1.2.   Parameters called by reference.


 The resulting reference is loaded into the register(s). TEXT and
 ARRAY parameters are transmitted as by-value except that the
 descriptors point to the parameter object (no copy generated).


 5.6.1.3.   Parameters called by name.


 The mechanism employed is not the normal by-name transmission. If
 the parameter is a simple variable the address of the variable is
 loaded.  Thus a result may be returned via this variable. TEXT
 parameters are transmitted as the address of the text descriptor
 (not the text object).  For LABEL, SWITCH, PROCEDURE and ARRAY
 parameters by-name is identical to by-reference. For REF
 parameters the rules are as for a by-reference transmission to a
 Simula procedure.





                                43
 ^pg;
               5. Implementation Dependent Features


 5.6.2.   EXT. ASSEMBLY <type> PROCEDURE.


 The code sequence generated by the compiler at the call of an
 ASSEMBLY procedure is as follows:

       LMJ   X11,<procedure name>.
       F5    -,-,-,-,N.
       F1    T,K,X,REL.  Parameter descriptor (1st par.)
       F1    T,K,X,REL.  Parameter descriptor (2nd par.)
       ...               - at most 63 parameters.

 where

  F5 =  FORM  12,6,6,6,6     (only S6 significant).
  F1 =  FORM   6,6,6,18.
  N  =  number of parameters to call.
  T  =  parameter type code.
  K  =  parameter kind code.
  X  =  index register, see REL below.
  REL   is the address of the parameter relative to index register
        X.

 The assembler routine should return to  N+1,X11 .


 5.6.2.1.   Parameter transmission.


 Actual parameters which might cause storage allocation to take
 place should never be used. This precludes parameters involving
 class generation, Simula procedures, COPY, BLANKS and INTEXT.

 Avoid usage of formal parameters as actual parameters as well as
 LABEL, SWITCH or PROCEDURE type parameters.

 The parameters are transmitted via descriptors, given in sequence
 after the generated call. When the assembly routine is entered,
 the value of the i'th parameter may be loaded e.g. into A0 by
 indirect access through the i'th parameter descriptor as follows:
          L        A0,*i,X11.

 The index register 'X' given in the parameter descriptor points
 to the first word of the object, which contains the parameter.

 Each parameter is further specified by type (T) and kind (K)
 codes; these codes are given in the following tables. No
 explanation of the meaning and interpretation of the kind codes
 is given here. Some indications are given in chapter 10, but the
 correct interpretation depends on a intimate knowledge of the
 compiled program as well as of the system objects to an extent
 outside of the scope of this manual.










                                44
 ^pg;
               5. Implementation Dependent Features


             Parameter type codes.

         0  unspecified
         1  INTEGER            6  TEXT
         2  REAL               7  REF
         3  not used           8  CHARACTER
         4  LONG REAL          9  BOOLEAN
         5  COMPLEX           10  LABEL


                Parameter kind codes.

  0  unspecified
  1  simple                       13  default simple
  2  array                        14  default array
  3  parameter procedure          15  default param. proc.
  4  noparameter procedure        16  name simple
  5  parameter class              17  name array
  6  noparameter class            18  name param. proc.
  7  external Simula procedure    19  value simple
  8  external library procedure   20  value array
  9  external assembly procedure  21  constant
 10  address                      22  virtual simple
 11  expression                   23  virtual array
 12  standard procedure           24  virtual param. proc.





































                                45
 ^pg;



 6   THE SYSTEM CLASSES



 The system classes consist of

              SIMSET
              SIMULATION
              BASICIO

 plus all the classes defined local to these three. The user
 cannot refer directly to BASICIO, only to the file classes local
 to it.

 The individual properties of the system classes are described in
 sections 6.1 and 6.2 below. However, several characteristics are
 common to all. System classes may be used as prefixes at any
 block level of a program. The use of a system class as a prefix
 will result in the implicit redeclaration of that class
 (including possible prefixes) in the nearest textually enclosing
 block. The one restriction on the use of the file classes is,
 that the procedures defined in Common Base as being virtual
 (OUTIMAGE etc.) are not implemented as virtual procedures, that
 is the binding cannot be changed.



 6.1   _SIMSET and SIMULATION_.


 In accordance with the recommended extensions of Common Base, the
 properties of class LINKAGE are augmented with

              REF(linkage) PROCEDURE prev.

 The classes may be used for prefixing at any block level; note
 that the occurence of SIMULATION as a prefix results in the
 implicit declaration (or redeclaration) of both SIMULATION and
 SIMSET in the nearest textually enclosing block.

 It is strongly recommended not to use the standard procedures
 RESUME, DETACH and CALL within a class or block that contains
 SIMULATION in its prefix chain.

 The attribute TIME of class SIMULATION is represented by a single
 length REAL.

 NOTE: If you want to run a simulation model, you have to use
 SIMULATION as a block prefix so that the quasi-parallel system
 will have this block as its main program (otherwise BASICIO will
 be the main program of the QPS which is probably not intended -
 and you may get some strange simulation results!).



 6.2   _File handling_.


 A Simula data file is a sequence of external images residing on
 some physical storage medium. Each external image can be regarded


                                46
 ^pg;
                       6. The system classes


 as a record which may be structured, in any way, into fields of
 information. The external image is a logical entity and, in terms
 of physical realisation, several such external images may be
 blocked together for optimum use of the storage medium.

 Communication between the program and the physical file is via an
 object of a file class, which possesses properties that enable
 the programmer to read, write, or perform administrative
 functions on the file. Data is transmitted between the program
 and the file via an internal image. This is a text object
 nominated by the programmer and may be referenced at any time via
 the attribute IMAGE of the file class. The contents of an input
 file, for example, can be accessed by transferring an external
 image to the internal image. The individual data items can then
 be retrieved by either the de-editing facilities of the file
 class or those of the text IMAGE itself. For output files, the
 converse is true: records are assembled into the internal image
 which is then written as a whole (as an external image).

 IMAGE may be switched to point at any text object at any time.
 Thus, in many cases, data movement can be minimised by operating
 on the data in situ.



 6.3   _Class BASICIO_.


 File handling is performed by the system class BASICIO. It
 contains a group of classes each of which is associated with a
 particular type of file.  While the programmer may not refer
 directly to BASICIO itself, he can employ freely the file classes
 defined within it.

 All of the file types handled by BASICIO are files in which the
 information is recorded in character form. Thus, writing on a
 mass storage file is conceptually no different from sending
 output to the printer.

 The file class hierarchy defined within BASICIO is


                              FILE
                               !
                    -----------+------------
                   !           !            !
                INFILE      OUTFILE      DIRECTFILE
                               !
                               !
               PRINTFILE --------------- PUNCHFILE




 6.4   _The file handling system_.


 In addition to fulfilling the requirements of Common Base the
 Univac Simula file handling system was designed with three major
 aims in mind:


                                47
 ^pg;
                       6. The system classes


 1) The various file types manipulated by the file classes should
    have as high a level of compatibility with one another as Exec
    permits.

 2) The system should be capable of manipulating files generated
    by, or acceptable as input to, other system processors. For
    example, infiles read files generated by a DATA statement,
    while outfiles are acceptable as source input to a Fortran
    compiler.

 3) The system should be as convenient as possible for the
    programmer. It should not be necessary to duplicate in the
    program information already given in control statements to
    Univac. Indeed, in simple cases when scratch files are
    employed, the file handling system should be capable of
    submitting dynamically the appropriate Univac file assignment
    statements, without additional action by the user.

 The first two of these aims have been achieved by implementing
 the file handling system around SDF (System Data File) format
 files. SDF files may reside on magnetic tape or FASTRAND. They
 may also exist as FASTRANDsimulated drum files. Source input to
 most Univac processors (assembler, Simula, FORTRAN, ELT
 processor, etc.) is in SDF format. All printfiles (written by
 PRINT$, PRNTA$, etc.,) are in SDF format. Standard formatted
 output from FORTRAN programs is in SDF format. The use of SDF
 files results in a high level of compatibility across the various
 file types. As an example, printfiles can be read as infiles.

 The third design criterion has been realised by using, as the
 name of a file object, the internal name of the physical file
 with which the object is associated. See the Univac PRM for an
 account of the file name conventions.  If the physical file has
 been assigned to the run by the user then this file is used.
 However, if the user wishes to employ only a scratch file, he
 need not assign the file himself but can leave this chore to the
 file handling system which assigns the file dynamically.



 6.5   _General File Characteristics_.


 In addition to the properties listed in "Common Base Language",
 each Univac Simula file class possesses an extra procedural
 attribute:

           TEXT PROCEDURE id;
           id:- copy('filename');

 The procedure returns a reference to a 12-character text value
 containing the file name.

 All input/output operations employ background buffering. This is
 administered automatically by the RTS and the programmer has
 neither control over nor access to the background buffers. It is
 strongly recommended that, at any one time, only one file object
 represents a particular physical file. If this is not so, the
 effects cannot be predicted.



                                48
 ^pg;
                       6. The system classes


 When a file class object is generated, only one parameter is
 required. This is a text containing the internal name of the
 physical file which this object represents. A runtime error
 occurs if the file name is NOTEXT or is longer than 12
 characters. In general, if the file name does not denote a
 physical file which is already assigned to the run, the RTS
 assigns a temporary file of this name. This action is not taken
 if the file is an INFILE. It is however recommended to assign all
 files explicitly.

 Before they can be used, all files, except SYSIN and SYSOUT, must
 be opened explicitly by a call on the procedure "OPEN". A runtime
 error occurs if an attempt is made to open a file which is
 already open. The OPEN procedure requires only one parameter
 which is of type TEXT. This parameter nominates a text object
 which will be employed as the internal image, unless the
 programmer later specifies something to the contrary. If the
 parameter to OPEN is NOTEXT, the programmer must, of necessity,
 make IMAGE reference a non-trivial text object before he begins
 to operate with the file. The text parameter to OPEN is also
 significant in that it determines whether or not the file can
 later be used as DIRECTFILE. This point is discussed under the
 individual file types.

 Before program termination, each file which has been opened
 explicitly must be closed again by the programmer. A runtime
 error occurs at program termination if this has not been done.
 The accompanying message indicates how many files remain open.
 That this message is given at program termination does not mean
 that it can be ignored. Unclosed output files may be incomplete
 and subsequent attempts to read them may be unsuccessful.
 Unclosed tape files will almost certainly be badly positioned for
 further operations. The programmer should observe that unclosed
 files may be due to premature termination in some other runtime
 error.

 The procedure "CLOSE" may be called with either no parameters or
 one text parameter. This parameter has significance only if the
 file is on magnetic tape. It is used to specify a rewind action
 and is described fully under the various file types. An attempt
 to close a file which is already closed results in a runtime
 error.

 At the time of input/output, IMAGE must not reference a text
 object whose length exceeds 12282 characters. With the exception
 of PRINTFILEs and PUNCHFILEs there are no other restrictions
 attached to the IMAGE text.  PRINTFILEs and PUNCHFILEs require
 that, at the time of output, IMAGE be a main text. For all other
 files, IMAGE may be defined/redefined as any text (main or sub).
 However, in the interests of runtime efficiency, the user is
 encouraged to use main texts whose lengths are multiples of 4.

 Except for DIRECTFILEs, the file classes may operate with
 physical files on FASTRAND or magnetic tape. DIRECTFILEs may not
 reside on tape. In general, the usage of the file classes is
 independent of the storage device on which the file resides.
 However, for tape files, the question of tape position arises
 when several files are stored on the same reel. This point is
 discussed in "Magnetic Tape Files".



                                49
 ^pg;
                       6. The system classes


 6.6   _Class OUTFILE_.


 This subsection does not apply to PRINTFILE or PUNCHFILE
 subclasses of class OUTFILE.

 An object of class OUTFILE is used to represent a sequentially
 organised output file. The physical file is constructed as an SDF
 file in such a way that it can be read by class INFILE or used as
 source input to most Univac standard processors.


 6.6.1.   File Generation (OUTFILE).


 Class OUTFILE requires one text parameter. This contains the
 internal name of a physical file which the OUTFILE is to
 represent. If this name is that of a physical file which is
 already assigned to the run, that file is used as the output
 medium. If a file of the given name is not already assigned, the
 RTS assigns a temporary file by issuing dynamically the
 assignment command:

           @ASG,T   <file name>,F///3000


 6.6.2.   OPEN (OUTFILE).


 The procedure OPEN requires one parameter of type TEXT. This text
 is nominated as the initial internal image.


 6.6.3.   OUTIMAGE (OUTFILE).


 The procedure OUTIMAGE transfers the contents of the internal
 image to the physical file as an external image. The procedure
 may be called explicitly by the programmer, or implicitly by the
 RTS if an editing operation found insufficient room in the image
 text. After its contents have been transferred, the image text is
 space-filled and its position indicator reset to one.

 IMAGE may reference any text or subtext whose length does not
 exceed 12282 characters. However, runtime efficiency is optimal
 if the text is a main text whose length is a multiple of 4
 characters.


 6.6.4.   CLOSE (OUTFILE).


 Each OUTFILE opened by the programmer must be closed before
 program termination. Failure to do this will result in a file
 which is incorrectly terminated. Subsequent attempts to read the
 file may not succeed.

 If, at the time of closure, the position indicator of IMAGE is
 not one, the close routine assumes that this internal image has
 not yet been written and outputs it. The files is then closed.


                                50
 ^pg;
                       6. The system classes


 The CLOSE procedure may have one text parameter.  If the file is
 not on magnetic tape, the parameter is ignored and may be
 omitted. In the case of a tape file, the legal parameter values
 are as follows:

 "REWIND"  Two hardware EOF marks are written and the tape is
           rewound.

 "FREE"    Two hardware EOF marks are written, the tape is rewound
           and the file is FREE-ed.

 "WAIT"    Two hardware EOF marks are written, the tape is
           backspaced one EOF mark and remains positioned there.
           Additional files may now be written on the same tape.

 If no parameter is given when closing a tape file, "REWIND" is
 used as default.



 6.7   _Class INFILE_.


 An object of class INFILE is used to represent a sequentially
 organised input file. In general, the physical file must be in
 SDF format. A special case is the file read via SYSIN. For the
 most part, SYSIN functions according to the general INFILE
 definitions. There are, however, a few effects which are a
 consequence of the fact that SYSIN reads card images from the
 control stream.  The special characteristics of SYSIN are
 described in a separate subsection "SYSIN".

 Class INFILE may represent any SDF file which is not in element
 format. (See also procedure LOCELT, section 9.2.2.) It can thus
 read files written by the Simula classes OUTFILE, PRINTFILE,
 PUNCHFILE, or DIRECTFILE plus SDF files written by other
 programming systems, e.g. FORTRAN formatted output or the DATA
 command.

 Since INFILE is designed for reading sequential files, there is
 one reservation attached to its ability to read physical files
 previously written by class DIRECTFILE. If a call on INIMAGE
 attempts to read a non-existent image of the file, the effect is
 as if an end of file mark where encountered.

 Physical files read by an object of class INFILE may contain
 fixed or variable length records. The effect of encountering an
 external image whose length is different from that of the
 internal image is described later in this subsection under
 "INIMAGE".


 6.7.1.   File Generation (INFILE).


 Class INFILE requires one text parameter. This must contain the
 name of the physical file which the infile is to represent. If a
 file of this name is not already assigned to the run, a runtime
 error occurs. The file must, therefore, be either one which the
 user assigned explicitly or one which was assigned automatically


                                51
 ^pg;
                       6. The system classes


 by the runtime system when an OUTFILE or DIRECTFILE wasused
 earlier. If the programmer is using automatically assigned
 scratch files to first write out information and then read it
 back, he should ensure that the output file is generated first.

 e.g.   REF(OUTFILE)OUTPUT;
        REF(INFILE)INPUT;
        OUTPUT:-NEW OUTFILE("TEMP");
        INPUT:- NEW INFILE("TEMP");

 The above order of file generation is satisfactory. On creating
 the OUTFILE, the RTS automatically assigns a temporary file
 called "TEMP". Thus the file is already assigned when the INFILE
 is created. This would not be true if the INFILE were generated
 first and a runtime error would result.


 6.7.2.   OPEN (INFILE).


 The procedure OPEN requires a parameter of type TEXT. If the
 parameter is not NOTEXT, this text is nominated as the initial
 internal image. If the parameter is NOTEXT, the programmer must
 later nominate a suitable image text before input is attempted.


 6.7.3.   INIMAGE (INFILE).


 The procedure INIMAGE transfers the contents of the next external
 image. The position indicator of the image text is reset to one.
 The procedure may be called explicitly by the programmer or
 implicitly by the RTS.

 If the external image is longer than the internal image, a
 runtime error results. If the external image is shorter than the
 internal image, the external image is left-justified in the
 internal image and the remaining character positions are
 space-filled.

 If an end of file is encountered, ENDFILE is given the value
 "TRUE" and the character sequence "@EOF" is transferred to the
 internal image. If the physical file was originally constructed
 by a DIRECTFILE , some of the external images may be missing. An
 attempt to read a non-existent external image has the same effect
 as encountering an end of file. No further processing of the file
 is possible.

 IMAGE may reference any text or subtext whose length does not
 exceed 12282 characters. However, runtime efficiency is optimal
 if the text is a main text whose length is a multiple of 4
 characters.


 6.7.4.   CLOSE (INFILE).


 Each INFILE opened explicitly by the programmer must be closed by
 him before program termination. Failure to do this results in a
 runtime error. The error message indicates how many files have


                                52
 ^pg;
                       6. The system classes


 not been closed. In the case of unclosed tape files, there may be
 loss of tape position which could prevent or endanger further
 operations on that tape.

 The CLOSE procedure may have one text parameter.  If the file is
 not on magnetic tape, the parameter is ignored and may be
 omitted. In the case of a tape file, the legal parameter values
 are:

 "REWIND"  The tape is rewound.

 "FREE"    The tape is rewound and the file is FREE-ed.

 "WAIT"    If the file is being closed before the end  of file is
           reached, the tape is moved forward until the end of
           file is passed.  The tape is now positioned at the end
           of the file being closed.  If this is not the last file
           on the tape, the tape is thus positioned for reading
           the next file.

             e.g.  INSPECT NEW INFILE("input") DO
                   BEGIN open(blanks(300));
                         read the first file;
                         close("wait");
                         open(blanks(300));
                         read the second file;
                         close("free");
                   END;

           In this example, the first CLOSE statement positions
           the tape in readiness for reading the next file. The
           INFILE object is then re-opened and the second file is
           read.  The second CLOSE statement causes the tape to be
           rewound and FREE-ed.

 If no parameter is given when closing a tape file, "REWIND" is
 used as default.



 6.8   _Class DIRECTFILE_.


 An object of class DIRECTFILE is used to represent a file whose
 external images can be located directly by ordinal numbers
 associated with them.  From the user's viewpoint, the file need
 not be sequentally organised and reading and writing may involve
 the external images in any order. At any time, the physical file
 can be regarded as a set of numerically indexed records of which
 several may be missing.

 The external images of an Univac Simula DIRECTFILE are of a fixed
 length determined when the physical file is opened for the very
 first time. The file is constructed in SDF format and can later
 be read, if required, as a sequential file by class INFILE. If
 all the external images are present, the entire file can be read
 by INFILE. If there are gaps, sequential reading by INFILE can be
 performed only until the first missing image is detected.

 Only Simula programs can create DIRECTFILEs, i.e. files generated


                                53
 ^pg;
                       6. The system classes


 by other Univac system processors may not be accessed as
 DIRECTFILEs.


 6.8.1.   File Generation (DIRECTFILE).


 Class DIRECTFILE requires one text parameter which contains the
 internal name of a physical file which the DIRECTFILE is to
 represent. If this name is that of a file which is already
 assigned to the run, that file is used, provided it is not a
 magnetic tape file. An attempt to generate a DIRECTFILE which
 accesses a tape file results in a runtime error. If a file of the
 given name is not already assigned, the RTS assigns a temporary
 file by issuing, dynamically, the assignment:

           @ASG,T   <file name>,F///3000


 6.8.2.   OPEN (DIRECTFILE).



 The procedure OPEN requires one text parameter. If the parameter
 is not NOTEXT, this text is nominated as the initial internal
 image. If the parameter is NOTEXT, the programmer must later
 nominate a suitable image text before input/output is attempted.

 If the file which is being opened has never been written upon
 before, the length of the parameter text to OPEN is taken as the
 length of the external fixed length images. In this case, a
 runtime error occurs if the parameter text is NOTEXT.

 If the file is one which has been written previously, the
 external image length is retrieved from the file itself.

 The OPEN procedure automatically issues the call "LOCATE(1)",
 positioning the file at external image number 1.


 6.8.3.   LOCATE and LOCATION.


 While a DIRECTFILE is open, an internal variable "LOC" contains
 the index of the external image at which the file is positioned,
 i.e. if LOC=5, external image number 5 is the next to be written
 or read. The procedure LOCATE is used to alter the value of LOC
 and thus position the file at any desired point. If the file is
 not open, a call on LOCATE results in a runtime error.  The
 programmer may use the integer procedure LOCATION to establish at
 which image the file is currently positioned.


 6.8.4.   ENDFILE.


 The procedure ENDFILE returns the value TRUE if the file is
 currently positioned at a non-existent external image.




                                54
 ^pg;
                       6. The system classes


 6.8.5.   INIMAGE (DIRECTFILE).


 Unless the file is currently positioned at a non-existent image,
 the procedure INIMAGE transfers, to the internal image, the
 contents of the external image at which the file is currently
 positioned. The image whose index is one greater than the image
 just transferred is then located. In all other respects, INIMAGE
 functions as for class INFILE, error termination or
 space-extension taking place if the external image is longer or
 shorter, respectively, than the internal image.

 If the file is positioned at a non-existent external image, the
 character sequence transferred by INIMAGE is "@EOF".


 6.8.6.   OUTIMAGE (DIRECTFILE).


 The procedure OUTIMAGE transfers the contents of the image text
 to the external image at which the file is currently positioned.
 The file is then positioned at the external image whose index is
 one higher than that of the image just written. In all other
 respects, OUTIMAGE functions as for class OUTFILE, truncation or
 space-extension taking place if the external image is shorter or
 longer, respectively, than the internal image.


 6.8.7.   CLOSE (DIRECTFILE).


 Each DIRECTFILE opened explicitly by the programmer must be
 closed by him before program termination. Failure to do this
 results in a runtime error and the file control information
 containing the file size, among other things, is not updated.
 This could result in the file's being wholly or partially
 inaccessible on a later occasion.

 There is no purpose in specifying a parameter to CLOSE. A text
 parameter is, in fact, accepted but ignored.

 Example.

 A company keeps records of each of its employes in a DIRECTFILE
 called "STAFF". Each employee is identified by an integer which
 is used to index his entry in the file. The following program
 reads from cards a sequence of employee numbers and prints the
 STAFF entry for each.

           BEGIN REF(directfile)empl;
                 empl:-NEW directfile("staff");
                 empl.open(sysout.image);
                 WHILE NOT lastitem DO
                 BEGIN empl.locate(inint);
                       empl.inimage;
                       outimage;
                 END;
                 close;
           END;



                                55
 ^pg;
                       6. The system classes


 6.9   _Class PRINTFILE_.


 An object of class PRINTFILE is used to represent a
 printer-oriented output file in which each external image
 represents one print line. As a subclass of OUTFILE, class
 PRINTFILE can create physical files which have the same degree of
 compatibility with the other file types as files written by class
 OUTFILE.

 Note: This paragraph may not apply to all releases of Exec.  If
 the user has not assigned a physical file, the RTS automatically
 attempts to assign a catalogued file for the PRINTFILE output.
 When the file is closed, it is queued for printing and deleted
 from the directory afterwards.  If the file is userassigned, it
 is not put into the print queue on closure and the user must make
 his own arrangements for printing it.

 Class PRINTFILE uses the PRNTA$ facility to generate alternate
 printfiles, except for SYSOUT which uses PRINT$ if runtime
 S-option is not specified. The user may find that, at his
 installation, there is a limit on the number of alternate
 printfiles which may be active in one run.


 6.9.1.   File Generation (PRINTFILE).


 Class PRINTFILE requires one text parameter which contains the
 name of a physical file to which the output will be sent. If the
 user has assigned to the run a file of this name, that file will
 be used as the output file and will not be automatically queued
 for printing when it is closed.

 If the given file name does not belong to a file which is
 assigned to the run, a catalogued file with this name is created,
 provided that one does not exist already. If a catalogued file of
 this name does exist, the file name specified at PRINTFILE
 generation is systematically changed until a name results which
 does not match any in the catalogued file directory. This
 systematic alteration is done by replacing the first character of
 the name by the letters "A" through "Z" in turn. The type name
 conflict which this process resolves can arise in two ways. There
 may exist in the file directory a genuine user-generated entry
 which clashes with the given name.  Alternatively, a program
 which employs automatic file assignment may be executed several
 times in succession such that a printfile created during one
 execution still awaits printing at the time of a subsequent
 execution.

 The default value of LINESPERPAGE is 63, this value may however
 be changed at system generation.


 6.9.2.   OPEN (PRINTFILE).


 The procedure OPEN opens a new part of the printfile and ejects
 the printfile to the first line of a new page. Apart from this,
 it conforms to the same pattern as for class OUTFILE.


                                56
 ^pg;
                       6. The system classes


 6.9.3.   OUTIMAGE (PRINTFILE).


 OUTIMAGE conforms generally to the same pattern as in class
 OUTFILE. In addition, it operates in conjunction with
 LINESPERPAGE and SPACING to position the lines on the print page
 according to the programmer's specifications. The line indicator
 "LINE" is incremented by SPACING immediately after the line is
 output. If SPACING has the value zero, the next line will
 overprint the one just output unless an eject is performed.

 At the time of a call on OUTIMAGE, IMAGE must point to a main
 text.


 6.9.4.   LINESPERPAGE.


 In Univac Simula, LINESPERPAGE has been implemented with a view
 to accommodating the logical page within a physical page of 72
 lines. Note however that this is installation dependent, see also
 1.3.17.

 On generation and closure of a PRINTFILE, LINESPERPAGE is set to
 63. On a print page of 72 lines, this gives top bottom margins of
 6 and 3 lines respectively.

 The effect of the procedure call "LINESPERPAGE(N)" is as follows:

   N<0     The effect is identical to LINESPERPAGE(72), i.e. for a
           72-line page "full page" printing is performed.

   N=0     The effect is identical to LINESPERPAGE(63), i.e. the
           number of lines per page reverts to the Univac Simula
           standard value of 63.

   0<N<66  The number of lines per page is set to N, with a top
           margin of 6.

   N>66    The number of lines per page is set to N, with no top
           margin.


 6.9.5.   SPACING.


 The procedure SPACING is used to alter the number of lines the
 PRINTFILE is "spaced" forward after each call on OUTIMAGE. A
 runtime error occurs if the parameter to SPACING is less than
 zero, greater than LINESPERPAGE or greater than 63. A zero
 parameter results in the overprinting of successive lines.


 6.9.6.   CLOSE (PRINTFILE).


 Each PRINTFILE opened explicitly by the programmer must be closed
 by him before program termination. Failure to do this results in
 a runtime error and the physical file is neither correctly
 terminated nor queued for printing.


                                57
 ^pg;
                       6. The system classes


 The current part of the printfile is BRKPT-ed and, if it was
 assigned automatically by the Simula RTS, is queued for printing.
 If the file is a user-assigned catalogued file, it may be printed
 later by a @SYM control statement.

 A single text parameter may be specified to CLOSE. The
 interpretation of this is as in class OUTFILE.

 When a PRINTFILE is closed, LINESPERPAGE is reset to the standard
 value and SPACING to 1.



 6.10   _Class PUNCHFILE_.


 Class PUNCHFILE is an additional feature of Univac Simula. An
 object of class PUNCHFILE is used to represent a file which is
 oriented towards punched card output. The class uses the PNCHA$
 feature of Univac.

 In terms of the output operations available to the user, class
 PUNCHFILE functions in the same way as class OUTFILE. However, at
 the time of a call on OUTIMAGE, IMAGE must reference a main text.

 The physical file considerations concerning file assignment and
 queueing for punching parallel exactly those of class PRINTFILE.



 6.11  _Magnetic Tape Files_.


 For the most part, the rules governing the manipulation of
 magnetic tape files are as given in the preceding subsections.
 However, for multi-file reels, the question of tape position
 arises.

 In Univac, the file name for tape files is associated with the
 tape reel itself and not with any individual file on it. This
 means that, as far as the Univac Simula file classes are
 concerned, all files on a multi-file reel must be identified by
 the same name, the internal name of the tape reel. The correct
 file must then be located by positioning the tape before I/0
 operations can commence. One way is to use control statements
 (MOVE) to position the tape prior to the program execution.

 At file closure, the programmer may use the rewind action "WAIT"
 to position the tape immediately after the end of the current
 file. In this way, sequential access with multi-file reels is
 possible. There are no operations provided specifically for
 positioning a tape from one file to another during the same
 execution. However, if the file number is known, this operation
 can also be accomplished via the rewind actions. In the following
 example, a procedure is defined for skipping forward over N input
 files. The example illustrates the use of this procedure to
 access the 5th, 8th and 3rd files of a multi-file reel "TFIL".





                                58
 ^pg;
                       6. The system classes


   BEGIN PROCEDURE skip (f,n); REF(infile) f; INTEGER n;
       FOR n:= n STEP -1 UNTIL 1 DO
       BEGIN  f.open(NOTEXT);
              f.close("wait");
       END;
       REF(infile) tf;
       tf:- NEW infile("TFIL");
       skip(tf,4);
       tf.open( ... );     ! 5'th file opened;
          ...
       tf.close("WAIT");
       skip(tf,2);
       tf.open( ... );
          ...
       tf.close("REWIND");
       skip(tf,2);
       tf.open( ... );
          ...
       tf.close; END;



 6.12  _SYSIN_.


 SYSIN references an INFILE object which is generated and opened
 automatically at program initiation by the RTS and closed again
 at program termination. The name given to the physical file
 referenced by SYSIN is "READ$", i.e.

           SYSIN.ID = "READ$        ".

 SYSIN reads card images from the control stream and is the only
 INFILE with this property. For the most part, SYSIN functions
 according to the general specifications of class INFILE. However,
 there are a few effects which are a consequence of the fact that
 the external images of SYSIN come from the control stream. Only
 those aspects in which SYSIN differs from a normal INFILE are
 described in this subsection.

 In the Univac implementation, SYSIN (and SYSOUT) are implemented
 as reference variables; this is not in strict accordance with the
 language definition. Due to the implementation technique used for
 these system classes, the use of the procedures detach, call and
 resume may lead to disastrous results and is therefore strongly
 discouraged in this context.


 6.12.1.   SYSIN.OPEN.


 SYSIN is opened automatically at program initiation. It may be
 closed and re-opened according to the normal rules but must be
 open at program termination. If SYSIN is re-opened, it continues
 to function optimally only if the image text is the original one
 allocated to it by the RTS, e.g. in the following example, SYSIN
 is closed and opened again without any degradation in its
 performance.




                                59
 ^pg;
                       6. The system classes


   BEGIN TEXT sysinimage;
       sysinimage :- sysin.image;
          ...
       sysin.close;
          ...
       sysin.open(sysinimage);
          ...  END;

 If, however, a different image text is given when SYSIN is
 re-opened, the input operations take more time.


 6.12.2.   SYSIN.INIMAGE.


 For the most part, INIMAGE operates according to the general
 rules of class INFILE.

 The card images read by SYSIN.IMAGE need not to bee 80 characters
 in length.  SYSIN is designed to exploit Univac's ability to ADD
 any SDF file into the control stream. However, a runtime error
 occurs if a call on INIMAGE detects an external image which is
 longer than 132 characters.

 If INIMAGE detects an end-of-file card (@EOF), ENDFILE is given
 the value "TRUE". The first six characters of the EOF card are
 passed, left justified, to the image which is then space-filled.
 This means that the sixth character of an EOF card can be used as
 a sentinel character which is transmitted to the internal image
 and can be inspected afterwards, if necessary. On detection of an
 EOF image, no further card images can be read unless SYSIN is
 first closed then re-opened.

 This means that if the input stream is a sequence of files
 separated by EOF cards, at the end of each card file SYSIN must
 be closed and re-opened before the next file can be read.

 If INIMAGE detects a card image which contains a masterspace in
 xolumn 1 but is not an EOF card, the following actions take
 place. ENDFILE is given the value "TRUE" and the character
 sequence "@EOF" is edited, left justified, into the image text
 which is then space-filled. No sentinel character is transmitted,
 i.e. position six contains a space character. Any further attempt
 to read using SYSIN results in a runtime error. Only EOF cards
 may be used to separate card input files if continuation is
 required.

 After the detection of any card containing masterspace in column
 1, the image text contains "@EOF" as its first four characters.


 6.12.3.   SYSIN.CLOSE.


 When using SYSIN, the procedure CLOSE is only of interest if
 several files, separated by EOF cards, are being read. If SYSIN
 is closed by the programmer, it must be opened again by him
 before program termination otherwise a runtime error occurs.

 When SYSIN is closed, the unread data cards, if any, in the


                                60
 ^pg;
                       6. The system classes


 current card file are skipped. This means that when SYSIN is
 opened again, it will be able to recommence reading at the first
 image of the next file. However, reading of subsequent files is
 only possible if the files are separated by EOF cards and not
 other control cards. In many ways, the operation of CLOSE in
 conjunction with SYSIN is analogous to closing a magnetic tape
 file with the parameter "WAIT".

 There is no purpose in supplying a parameter when closing SYSIN.
 However, one text parameter is accepted but ignored.



 6.13  _SYSOUT_.


 SYSOUT references a PRINTFILE object which is generated and
 opened automatically by the RTS at program initiation and closed
 again at program termination. When this PRINTFILE is first
 opened, it has an image text of 132 characters (i.e. LINELENGTH
 of class BASICIO equals 132) and LINESPERPAGE is initially 64. In
 the absence of runtime S-option, the name given to the physical
 file referenced by SYSOUT is "PRINT$", i.e. SYSOUT.ID = "PRINT$".
 If S-option is used, the name of the SYSOUT file is as described
 in section 2.4.

 If the runtime S-option is not used, SYSOUT outputs to the
 standard PRINT$ file which is automatically printed at the end of
 the run. However, the Simula system messages (warnings, errors,
 etc.) are also output via PRINT$.  If the user does not wish the
 layout of the SYSOUT printing to be disturbed by system messages,
 he may use runtime S-option which causes an alternate printfile
 to be used for SYSOUT. S-option is described in greater detail
 elsewhere.

 SYSOUT is closed automatically by the RTS at program termination.
 If SYSOUT is not open at program termination, a runtime error
 occurs.

 In the Univac implementation, SYSOUT (and SYSIN) are implemented
 as reference variables; this is not in strict accordance with the
 language definition. Due to the implementation technique used for
 these system classes, the use of the procedures detach, call and
 resume may lead to disastrous results and is therefore strongly
 discouraged in this context.



 6.14  _Prefixing with the File Classes_.


 In Univac Simula, the file classes may be used to prefix
 user-defined classes or prefixed blocks at any block level. In
 this way, the user can supplement the standard operations of the
 file classes by additional features of his own.

 The occurrence of a file class as a prefix results in an implicit
 redeclaration of that class plus all the classes in its prefix
 chain in the nearest textually enclosing block, e.g.



                                61
 ^pg;
                       6. The system classes


         BEGIN REF(printfile) pr;         <--------------
             ...                                         !
             BEGIN printfile CLASS prfile;   <---        !
                 BEGIN                           !       !
                     ...                         !       !
                 END;                           (2)     (1)
                 ...                             !       !
                 pr :- NEW prfile(...);          !       !
                 ...                             !       !
             END;                            <---        !
             ...                                         !
         END;                             <--------------

 In this example, PRINTFILE is used to prefix a class at block
 level 2.  The effect of this is as if classes PRINTFILE, OUTFILE
 and FILE were all re-declared at block level 2. The statement
 "pr:-NEW prfile(...)" is therefore illegal since pr is qualified
 by the class PRINTFILE which is declared in a fictitious block
 enclosing the complete program, while PRFILE is a subclass of a
 new PRINTFILE declared at block level 2. This situation is, of
 course, in absolute accordance with the general rules governing
 the declaration of classes and their use as qualifiers.

 The only restriction on the use of file classes as prefixes is
 that the virtuality of the procedures OPEN, CLOSE, INIMAGE,
 OUTIMAGE, ENDFILE and LOCATE does not extend into the
 user-defined subclass or prefixed block. This means that, if the
 user chooses to re-define any of these procedures, the
 replacement procedure is used only if called explicitly at the
 user prefix level. If the named procedure is called implicitly
 through the use of one of the system-defined procedures which has
 not been re-defined, then the matching procedure at the system
 prefix level is used. This point is clarified in the following
 example in which a subclass of PRINTFILE is described. Within the
 subclass, the procedure OUTIMAGE is re-defined such that the
 first six character positions of the printline will contain a
 serial line number

   1    BEGIN printfile CLASS prfile;
   2         BEGIN PROCEDURE outimage;
   3               BEGIN image.sub(1,6).putint(line);
   4                     THIS printfile.OUTIMAGE;     ! NB ;
   5               END;
   6               open(blanks(132));
   7               INNER;
   8               close
   9         END;
  10       prfile(   ) BEGIN
  11             ...
  12             ...
  13             outimage;
  14             ...
  15    AGAIN:   outint(   );
  16             ...
  17             ...
  18             GO TO AGAIN;
  19             ...
  20       END
  21    END;



                                62
 ^pg;
                       6. The system classes


 The example shows a subclass of PRINTFILE which opens itself on
 generation and closes itself on termination. Line 4 illustrates
 the departure of the file classes from the normal class rules of
 "Common Base Language" (which, incidentally, does permit
 restrictions of any form in the use of file classes as prefixes).
 "THIS printfile.OUTIMAGE" represents a call on the systemdefined
 OUTIMAGE of class PRINTFILE. Had the file classes possessed full
 virtuality, the call would have been recursive. At line 13, the
 OUTIMAGE called is that re-defined in PRFILE. However, consider
 now the loop at lines 15-18. If, at line 15, there is
 in-sufficient room in the image to accommodate the integer item,
 outimage is called implicitly by outint. In this case, the
 OUTIMAGE procedure actually invoked is the system-defined one of
 PRINTFILE.

 The user is recommended to avoid exploiting the partial
 virtuality of the file classes if the same ends can be achieved
 by other means. Future developments of Univac Simula may
 introduce complete virtuality. Effects similar to those achieved
 in the last example could have been achieved using SYSOUT as
 follows, without relying on the partial virtuality:

   BEGIN PROCEDURE outimage;
       BEGIN  image.sub(1,6).putint(line);
              sysout.outimage;
       END;
       ...
       outimage;
       ...
   END;
































                                63
 ^pg;



 7   PARAMETER TRANSMISSION


 In this chapter we use the concept "value types" - these are
 INTEGER, (LONG) REAL, COMPLEX, CHARACTER and BOOLEAN.

 Parameters may in Simula be transmitted

 - by value,
 - by reference, or
 - by name.

 By-reference transmission cannot be requested explicitly, and
 by-name transmission is not available for class parameters.

 If the transmission mode is not specified, a default mode will be
 selected: for value type parameters the default transmission is
 by value, for all other parameters it is by reference:


                               Transmission mode
     Parameter           value     reference     name

     value type            D        illegal   !    O
     REF (...)          illegal        D      !    O
     TEXT                  O           D      !    O
     value type ARRAY      O           D      !    O
     REF (...)  ARRAY   illegal        D      !    O
     -----------------------------------------
     (type) PROCEDURE   illegal        D           O
     LABEL, SWITCH      illegal        D           O

       D: default mode,  O: optionally available mode.

   The upper left subtable defines the parameters and the
   transmission modes available for class declarations.


 The rules governing the parameter transmission are stated in
 Common Base Simula, and only a few points and restrictions will
 be given here.



 7.1   _Parameter transmission by value_.




 7.1.1.   Value types.


 The actual parameter expression is evaluated and the result is
 assigned to a local variable identified by the formal parameter
 name. The assignment invokes type conversion if necessary.







                                64
 ^pg;
                     7. Parameter transmission


 7.1.2.   Reference type.


 Neither simple references nor arrays of reference type may be
 transmitted by value.


 7.1.3.   Value type array.


 The actual parameter expression is evaluated and the array
 referenced by the result is copied into a new array object. The
 formal parameter is identified with this copy. The copying
 represents an overhead at procedure or class entry, but not at
 the parameter references.


 7.1.4.   TEXT by value.


 The actual parameter value, which may be either a text value
 (string) or a (sub)text reference, is copied into a new text
 object and the formal parameter is identified with a text
 reference pointing to the new object. The position indicator will
 thus always be one at entry.  The copying represents an overhead
 at entry only.


 7.1.5.   PROCEDURE, LABEL or SWITCH.


 These types may not be transmitted by value.



 7.2   _Parameter by reference_.




 7.2.1.   Value types by reference.


 Value types may not be transmitted by reference.


 7.2.2.   Object reference.


 The reference resulting from the evaluation of the actual
 parameter expression is assigned to the formal parameter, subject
 to the normal qualification requirements. The formal parameter
 will thus refer the actual parameter object, and the attributes
 of the (global) object may thus be changed from within the
 procedure or class body.







                                65
 ^pg;
                     7. Parameter transmission


 7.2.3.   TEXT by reference.


 The result of the evaluation of the actual parameter is a text
 reference, including the position indicator. This reference is
 assigned (:-) to the formal parameter. Unless the reference is
 NOTEXT the formal parameter thus references a text existing
 global to the procedure or class. The (global) text object may
 thus be changed by operations within the body.  But observe that
 side effects such as adjustments of the position indicator affect
 only the formal parameter, and not any global text references
 which may point to the same text object.

 The OS1100 Simula relaxes the Common Base restrictions for text
 parameters called by reference in that the actual parameter may
 be a text constant (a string). The compiler will convert a call
 of the type  P("string") into P(COPY("string")).


 7.2.4.   Value type and TEXT array.


 The result of the evaluation of the actual parameter is an array
 descriptor pointing to an already existing array object. This
 descriptor is assigned to the formal parameter at entry. The
 (global) array object may thus be changed through assignments
 within the procedure or class body.


 7.2.5.   Object reference array.


 The qualifications of the actual and the formal parameter must be
 identical, in all other respects transmission of object reference
 arrays is exactly as for value type arrays.


 7.2.6.   PROCEDURE, LABEL and SWITCH.


 None of these are legal parameters to classes. The result of the
 evaluation of the actual parameter expression at procedure entry
 is assigned to the formal parameter. Thus a reference to the
 formal parameter works as if it was a reference to a non-local
 procedure, label or switch.

 Call of a formal procedure may result in overhead due to run time
 parameter checking. A <type> procedure may as actual parameter
 correspond to a no-type procedure, but if the formal procedure is
 type-specified the actual parameter must be type-compatible. In
 the case of formal reference procedures this means that the
 qualification of the formal must be a member of the prefix chain
 of the class which qualifies the actual parameter.









                                66
 ^pg;
                     7. Parameter transmission


 7.3   _Parameter transmission by name_.


 By-name transmission is not available for class parameters. At
 procedure entry each formal name parameter is assigned a
 parameter descriptor, which describe the actual parameter and how
 it can be accessed. Each time the formal parameter is evaluated
 during execution of the procedure body, the corresponding
 parameter descriptor is examined to determine how the actual
 parameter may be accessed and checks are performed to ensure the
 validity of its usage. Type conversion may be invoked if
 necessary. By-name transmission can thus be seen to result in
 considerable run time overhead.



 7.4   _Simula procedures_.


 Actual parameters must be type- or qualification-compatible with
 their corresponding formal parameters. Checks are performed to
 ensure that this requirement is fulfilled. Where the types are
 compatible but not identical, type conversions are invoked.  Such
 type conversions are performed at run time, unless the actual
 parameter is a constant which is converted by the compiler.

 The validity checking of the actual parameter list may be
 performed either at compile time or at run time, depending upon
 the context of the call. In most cases the parameter checking is
 performed at compile time in order to ensure faster execution.
 The exceptions to this rule are parameters of procedures passed
 as parameters (formal procedures) and virtual procedures. These
 are treated in the following sections.


 7.4.1.   Formal procedures.


 A call on a formal procedure results when the programmer, within
 a procedure body, refers to a parameter which has been specified
 as being a procedure.

 Any procedure declared in the program module may be passed as
 actual parameter to another procedure corresponding to a formal
 procedure parameter. Standard procedures may not be used as
 actual parameters.

 The checking of the parameter list of a formal procedure is
 performed at run time, thus implying a execution time overhead.


 7.4.2.   Virtual Procedures.


 The parameter checking for a virtual procedure may be performed
 either at compile time or at run time, depending upon the
 structure of the class hierarchy and the nature of the matching
 procedures.

 The matches may be given, not only at different prefix levels,


                                67
 ^pg;
                     7. Parameter transmission


 but in several branches of the subclass tree. When one prefix
 level is compiled, the structure of the concatenated objects,
 which will be created from it during execution, is not known.
 Thus it is not generally known what the matching virtual
 procedure will be. In such cases the compilation must proceed
 without the compiler being aware of the parameter requirements.
 In such cases, the parameter checking is deferred until run time.


 7.4.3.   Separately compiled modules.


 Section 1.8 describes how a procedure or a class may be compiled
 as a separate module. A successfull compilation may result in the
 generation of 3 elements:

       - a symbolic source element (optional)

       - a relocatable element

       - an omnibus element.

 The symbolic element contains the (updated) source text.

 The relocatable element contains the code generated by the
 compiler including the exact time of the latest incompatible
 update. This time will be checked once at execution initiation to
 ensure that the element actually included in the absolute element
 by the collector corresponds to the omnibus element inspected by
 the compiler during compilation of other modules including this
 procedure or class via an EXTERNAL declaration.

 The omnibus element contains a description of the procedure or
 class attribute structure and the time of the generation of the
 attribute element, i.e. the time of the latest incompatible
 compilation.

 Apart from the consistency check mentioned above, separatedly
 compiled procedures or classes are treated exactly as procedures
 or classes included wholly in the source module under
 compilation.





















                                68
 ^pg;



 8   CONCURRENT SIMULA ACTIVITIES


 Under EXEC it is possible to execute several cooperating programs
 concurrently. The chapter describes how to utilise this feature
 and the support that the SIMULA system offers.

 NOTE: This chapter describes facilities which will work on EXEC
 level 35 or above only. The results may be completely
 unpredictable if you try to use the features desribed under
 earlier versions of EXEC!



 8.1   _SIMULA program execution_.


 We will in the following refer to the source text of SIMULA
 programs as SIMULA source modules. The compiler takes a SIMULA
 source module as input and produces a relocatable program module.
 Such modules contains several references into relocatable modules
 within the SIMULA Runtime Library, the System Library and
 possible one or more User Libraries. A special System Processor
 called The Collector (MAP,see (4) vol 3, sect.2) is used to link
 together relocatable modules and produce an executable module. We
 will in the following call such a task "system preparation" and
 the executable module produced as the result of collecting a
 compiled Simula program a "program instance". The OS1100 allows
 us however to prepare a system consisting of several Simula
 program instances, intended to execute concurrently.

 When such a system starts executing a set of concurrently
 executing program instances are generated, comprising a so-called
 executing system.  A particular program instance may only
 communicate with program instances within the same executing
 system. However, there may exist several instances of the same
 program at the same time.



 8.2   _The SIMULA system preparator_.


 To make it easier for the users to carry out SIMULA system
 preparation a special processor called "@S*I.M-PREP" has been
 implemented with a source language which is easier to use than
 the general MAP language.

 The system preparator is normally used to collect an executable
 module from a set of relocatable modules. Optionally (R-option),
 the System Preparator can be used to produce a Stand Alone Common
 Bank Processor. The two basic inputs to the SIMULA System
 Preparator are the options supplied on the processor call card,
 and the information supplied by the System Preparator directives.

 The three basic outputs of the SIMULA System Preparator are:

 - A symbolic element which contains the System Preparator
   directives.



                                69
 ^pg;
                 8. Concurrent Simula activities.


 - A symbolic file named ADD$$$ which may be added to the
   run-stream.  This file contains an assembly program (preceded
   by the processor call @MASM), which will supply necessary
   information about the various program instances to the run time
   system kernel. After the assembly program follows a collector
   program (preceded by the processor call @MAP).

 - An edited listing.

 The SIMULA System Preparator is initiated by the processor call
 "@S*I.M-PREP,options  si,xout,so".

 All parameters on the control card are optional.  See (4) volume
 2 for additional information regarding processor call statements.


 8.2.1.   Options.


 Options include the standard processor options A I L N P Q S U W
 X and also:

 D         Debug and trace information printed.
 R         - see below.
 T         Test mode i.e. do not add generated file ADD$$$.
 V         Automatic load and go.


 8.2.1.1.   R-option.


 If R-option is present a single program instance is prepared, if
 no R-option is given a complete executing system is being
 prepared. The legality of the directives is dependent upon the
 setting of this option as follows:

    R-option present: PROC-LIB, SETMAX, and INCLUDE legal
    no R-option:      PROC-LIB, SETMAX, DEF, and ENT legal


 8.2.1.2.   ADD$$$ options.


 Option L will cause S-option on the generated MASM and MAP
 programs.  If a deeper understanding of the working of the
 preparator is wanted, the generated programs may thus be studied.

 Option X will cause X-option on the generated MAP program,
 otherwise an A-option is set on MAP.



 8.2.2.   Parameters.


 si        Specifies the input symbolic element which contains the
           System preparator directives.
 xout      Specifies the executable output element.  Under
           R-option xout is the name of the output absolute
           element which may be used as a stand alone common bank


                                70
 ^pg;
                 8. Concurrent Simula activities.


           or introduced as an EXEC-bank.
 so        Specifies the output symbolic element.



 8.3   _System Preparator Directives_.


 The System preparator is programmed by giving a series of
 directives as specified in  the following sections.


 8.3.1.   PROC-LIB - include library.


 This directive is used to include a user library in the generated
 MAP.

    PROC-LIB   <EXEC file name>;


 8.3.2.   SETMAX - set starting address.


 The generated D-bank will normally start at 040000; this
 directive forces another start address.

    SETMAX     <unsigned number>;


 8.3.3.   DEF - define program instance.


 This directive will define a program instance to be included in
 the executing system.

    DEF <instance name> = <instance definition>;

 where:
    <Instance definition> ::= <Program>
                           !  <Program> WITH <param set>
    <Program>             ::= PROGRAM <xoutname>
                           !  COPY <instance name>
                           !  SYSTEM-BANK <bankname>
                           !  COMMON-BANK <bankname>
    <param set>           ::= <param>
                           !  <param set> AND <param>
    <param>               ::= POOLSIZE <integer>
                           !  MAILBOXSIZE <integer>
    <xoutname>            ::= <EXEC element name>
    <instance name>       ::= <EXEC element name>
    <bankname>            ::= <EXEC element name>

 PROGRAM - will include an earlier prepared program instance in
           the system under the given instance name.
 COPY    - will include a copy of a previous included (by PROGRAM
           or COPY) instance as a concurrent instance under a
           different name.




                                71
 ^pg;
                 8. Concurrent Simula activities.


 8.3.4.   ENT - initially active program in


 When a system starts executing, all program instances are passive
 except the one designated by the ENT directive.

    ENT <instance name>;


 8.3.5.   INCLUDE - in program instance


 The INCLUDE directive has the format:

    INCLUDE <eltname>;



 8.4   _Program scheduling primitives_.


 During concurrent execution of several SIMULA programs, each
 program will at any time be in one (and only one) of the states
 terminated, operating, or passivated.

 When the last program instance of an executing system becomes
 terminated, the whole system is terminated.  If a non-terminated
 executing system contains no operating program instances then the
 system is in a deadlock situation.  To resolve this, all
 passivated program instances will be error terminated, which in
 turn will terminate the whole executing system.


 8.4.1.   The terminated state.


 The program has never been initiated for execution or it was
 effectively terminated when control passed through the final end,
 a runtime error occured or the PTerminate procedure was called.

 A terminated program occupies no resources such as CPU, memory
 space etc.


 8.4.2.   The operating state.


 The program is executing concurrently with all other operating
 programs.  An operating program instance remains operating until
 one of the following events occurs:

 - The PTerminate procedure is called or control passes through
   the final end, in which case the program instance becomes
   terminated.

 - A runtime error occur, in which case the program instance error
   terminates.

 - The PGetmail procedure is called with the 'wait' parameter
   being true when the mail box is empty.  In this case the


                                72
 ^pg;
                 8. Concurrent Simula activities.


   calling program instance is passivated and automatically
   reactivated when the next message is delivered in the mail box.

 - The PSendmail procedure is called with the 'wait' parameter
   true when the mail box of the receiver is full. In this case
   the calling program instance is passivated and automatically
   reactivated when space becomes available in the mail box.


 8.4.3.   The passivated state.


 The program execution is temporarily suspended.  It has a defined
 reactivation point at which it will resume execution when some
 other program instance removes the wait condition.


 8.4.4.   PSendmail.


 EXTERNAL LIBRARY
 INTEGER PROCEDURE PSendmail(message,progname,wait);
 VALUE message,progname; TEXT message,progname;
 BOOLEAN wait;
 ;

 Return value:

 0   Normal completion of the procedure.
 1   There is no program instance named 'progname', no message is
     sent.
 2   Receiver's mail box is full, no message is sent.

 Semantics:

 The PSendmail procedure normally inserts the value of the
 parameter 'message' and the name of the sender into the mail box
 associated with the program instance named 'progname'. PSendmail
 will insert the message after the last message in the mail box.

 A message longer than 72 characters is illegal and will give a
 runtime error.

 If no program instance is named 'progname' no message is sent and
 the value of PSendmail is 1.

 If the global mail pool is full, there is no room to store the
 message. In this case the parameter 'wait' is tested.  If 'wait'
 is true, the calling program instance is passivated and
 automatically reactivated when space become available in the
 global mail pool. Otherwise, if 'wait' is false no message is
 sent and the value of PSendmail is 2.

 If the receiver is terminated or passivated, it is automatically
 initiated or reactivated for concurrent execution.







                                73
 ^pg;
                 8. Concurrent Simula activities.


 8.4.5.   PGetmail.


 EXTERNAL LIBRARY
 INTEGER PROCEDURE PGetmail(message,wait);
 TEXT message; BOOLEAN wait;
 ;

 Return value:

 0   Normal completion of the procedure.
 1   Associated mail box is empty.
 2   This is a single program.

 Semantics:

 If the mail box associated with the calling program instance is
 not empty, the first message from the mail box and the name of
 the sender is removed and assigned to the parameter 'message' as
 follows:

    message.sub(1,12)  := <name of sender>;
    message.sub(13,72) := <message>;

 Otherwise, if the mail box is empty the parameter 'wait' is
 tested. If 'wait' is true the calling program instance is
 passivated and automatically reactivated when the next message is
 delivered in the mail box.  Otherwise, if 'wait' is false an
 error status results and no assignment is done to the parameter
 'message'.

 In case this procedure is called from a single program ie.  no
 concurrently running program instances have been defined, the
 result 2 will be returned immediately.


 8.4.6.   PTerminate.


 EXTERNAL LIBRARY PROCEDURE PTerminate;
 ;

 Semantics:

 If the associated mail box is empty, the calling program instance
 becomes terminated.  A terminated program instance occupies no
 resources such as CPU, memory space etc.

 Calling the PTerminate procedure or letting the control passes
 through the final end while the associated mail box is not empty
 cause a restart of the program instance.

 A terminated program instance may be restarted by the PSendmail
 procedure.








                                74
 ^pg;
                 8. Concurrent Simula activities.


 8.4.7.   PMode.


 EXTERNAL LIBRARY INTEGER PROCEDURE PMode(progname);
 VALUE progname; TEXT progname;
 ;

 Return value:

  0    There is no program instance named 'progname'.
  1    The program instance is terminated.
  2    The program instance is operating.
  3    The program instance is waiting for message.
  4    The program instance is waiting to send a message.

 Semantics:

 This procedure returns the current state of a named program
 instance.


 8.4.8.   PTrace.


 EXTERNAL LIBRARY PROCEDURE PTrace(i);
 INTEGER i;
 ;

 Semantics:

 This procedure is used to set trace modes depending upon the
 value of the parameter.  The following possibilities exists
 depending upon the value of 'i':

 0   No trace.
 1   Small trace.
 2   A dynamic print-out of the contents of the mail box.
 3   Debug trace (should not be used, for maintenace purpose).



 8.5   _File handling problems_.


 Prior to any reference a physical file must be assigned.  Such
 assignment can be done by a control card in the run-stream or
 from a program instance by a call on the standard procedure
 'CSF'. An option exists for a so-called exclusive assignment,
 i.e. the physical file is locked out for all other runs. Various
 dynamic file assignments are also performed by the SIMULA runtime
 system (see (3) under 'file handling').

 The 1100 Executive System is designed in such a way that several
 deadlock situations may occur. It is the user's responsibility to
 resolve such problems. As an example let R1 and R2 be two runs
 co-existing on a 1100 computer.  R1 has exclusively assigned the
 permanent file F1 and is trying to assign F2. R2 has exclusively
 assigned F2 and is trying to assign F1. A simple solution of such
 problems is to exclusively assign the files in the same order by
 all runs.


                                75
 ^pg;
                 8. Concurrent Simula activities.


 When several SIMULA program instances operate on the same
 physical file problems may arise due to background buffering. A
 background buffer is normally created when a file is opened.
 However, this is not the case for SYSIN and any print or punch
 file which we may regard as not buffered.

 Reading from a file normally causes no harm if the file is not
 concurrently being produced or updated. In the latter case it is
 strongly recommended to complete the transaction and close the
 file before trying to open it for reading.

 Writing into a file from several program instances concurrently
 is only possible for print and punch files within the same
 executing system. Note that procedure EJECT in this case will
 work in an unexpected manner!

 The best solution to the file handling problems is to create a
 program instance which is the sole owner of the file in question.
 All other instances must then communicate with the owner in order
 to read from or write into the file. This may however be rather
 cumbersome due to the present severe restriction on the amount of
 information it is possible to pass in one message.



 8.6   _Example: Subprogram and coprogram_.


 We will now define a framework of an executing system consisting
 of a main program, one subprogram and one coprogram.  Each
 program will be separately defined as a stand-alone common bank
 in a registered program library file named TEST*LIB and they will
 all be concatenated in the final system preparation.  This
 example does not use any form of parallellism. The main program
 may look like:

    @S*I.M,IS   Mainprogram
    BEGIN ...

       PROCEDURE Enter(Programname);
       VALUE Programname; TEXT Programname;
       BEGIN TEXT answ;  answ :- Blanks(84);
             PSendmail(NOTEXT,Programname,TRUE);
             PGetmail(answ,TRUE);
             END *** Enter ***;

       WHILE ... DO BEGIN
             IF ... THEN Enter("Subprogram");
             ...
             IF ... THEN Enter("Coprogram");
             ...
             END  *while*;
       END  *main*;

 The procedure 'Enter' is used to enter a subprogram or a
 coprogram.  It is defined using the program scheduling primitives
 'PSendmail' and 'PGetmail'. Entering is the same as sending an
 empty message to a named program instance and then waiting for an
 answer.



                                76
 ^pg;
                 8. Concurrent Simula activities.


 After the SIMULA compiler has processed the main program we may
 hand over the relocatable module to the SIMULA system preparator
 and inform it to produce a so-called stand-alone common bank
 absolute element (see(4)).  This may be done by a call on the
 @S*I.M-PREP processor as follows:

       @S*I.M-PREP,ISR   ,TEST*LIB.Main
       INCLUDE Mainprogram






















































                                77
 ^pg;
                 8. Concurrent Simula activities.


 A subprogram may look like:

    @S*I.M,IS   Subprogram
    BEGIN ...

       PROCEDURE Return;
       BEGIN PSendmail(NOTEXT,Mainprogram,TRUE);
             PTerminate;
             END *** Return ***;

       ...   ! Subprogram code;

       Return;   END *Subprogram*;

 The procedure 'Return' is defined using the program scheduling
 primitives 'PSendmail' and 'PTerminate'.  The return from a
 subprogram is the same as sending an empty message to the main
 program and simultaneously terminating the subprogram.

 After the SIMULA compiler has processed the subprogram we may
 produce a stand-alone common bank by a processor call like:

       @S*I.M-PREP,ISR   ,TEST*LIB.Sub
       INCLUDE Subprogram

 A coprogram may look like:

    @S*I.M,IS   Coprogram
    BEGIN ...

       PROCEDURE Enter(Programname);   ! as in main program;
       VALUE Programname; TEXT Programname;
       BEGIN TEXT answer;  answer :- Blanks(84);
             PSendmail(NOTEXT,Programname,TRUE);
             PGetmail(answer,TRUE);
             END *** Enter ***;

       WHILE TRUE DO BEGIN
             ...      ! Coprogram code;
             Enter("Main program");
             END  *while*;
       END  *Coprogram*;

 After the SIMULA compiler has processed the coprogram we may
 produce a stand-alone common bank by a processor call:

       @S*I.M-PREP,ISR   ,TEST*LIB.Cop
       INCLUDE Coprogram


 The final system preparation is (no R-option):

       @S*I.M-PREP,IS   ,Testsystem
       ENT Mainprogram;
       DEF Mainprogram = COMMON-BANK Main
                         WITH POOLSIZE 5K;
       DEF Subprogram  = COMMON-BANK Sub
                         WITH POOLSIZE 10K;
       DEF Coprogram   = COMMON-BANK Cop
                         WITH POOLSIZE 10K;


                                78
 ^pg;
                 8. Concurrent Simula activities.



 As soon as this system preparation is performed an executable
 module named 'Testsystem' is available in the file TPF$.  This
 module may be executed by the processor call statement:

       @TPF$.Testsystem


 To obtain full common bank processor support, each of the
 predefined common bank processors 'Main', 'Sub' and 'Cop' must be
 inserted in the system library SYS$*LIB$ due to a rigid
 restriction in the 1100 Executive System.  In that case, remember
 to change the COMMON-BANK specifications to SYSTEM-BANK in the
 source input which is given to the system preparator.



 8.7   _References to literature_.


  (1) - Dahl, Myhrhaug and Nygaard,
        "SIMULA COMMON BASE LANGUAGE"
        Norwegian Computing Centre

  (2) - "UNIVAC 1100-SIMULA, USERS GUIDE"
        Norwegian Computing Centre

  (3) - "UNIVAC 1100-SIMULA, PROGRAMMER'S REFERENCE MANUAL"
        Norwegian Computing Centre (first edition)

  (4) - "UNIVAC 1100 EXECUTIVE SYSTEM"  Volume 1-4
        Sperry Univac 1100 Series Library
        Document no. UP-4144.1-4

  (5) - "UNIVAC 1100 HARDWARE/SOFTWARE SUMMARY"
        Sperry Univac 1100 Series Library
        Document no. UP-7824

























                                79
 ^pg;



 9   PREDEFINED PROCEDURES


 This chapter contains a short description of the predefined
 procedures available to the Simula programmer, and a description
 of the LIBRARY procedures included in the run time library.

 The predefined procedures are the "stand-alone" standard
 procedures, the procedural attributes of texts and system classes
 are described in Common Base Simula, and will not be further
 mentioned here. The descriptions given here are rather tense and
 includes just enough information to be able to use the procedures
 syntactically and semantically correct, i.e. no information is
 given on the algorithms implemented.

 The procedures are grouped into the subsections arithmetic,
 character handling, random drawing and miscellaneous. The last
 contains standard procedures which are not part of Common Base
 Simula - they enable the program to communicate with OS1100.



 9.1   _Arithmetic procedures_.


 The following <type> procedures operates on arguments of type
 REAL or LONG REAL. INTEGER arguments, when used, are converted to
 REAL.  Unless otherwise stated arguments of type COMPLEX will not
 be accepted.  Normally the procedure operates in single precision
 arithmetic. If LONG REAL arguments are given the precision will
 be double length.  The value returned will be REAL or LONG REAL
 as appropriate.

 ABS(X)      returns the absolute value of X in the same type as
             X.  If X is COMPLEX the result is X.RE**2 + X.IM**2.

 ARCCOS(X)   returns arccos(X) in (LONG) REAL. The value is in
             radians in the interval (0,PI). ABS(X)<=1.

 ARCSIN(X)   returns arcsin(X), the value is in the interval
             (-PI/2,PI/2).

 ARCTAN(X)   - as ARCSIN, but computes arctan(X).

 ARCTAN2(X,Y)  use the signs of X and Y (supposed to be sin(a) and
             cos(a) respectively) to determine the correct value
             of arctan(X/Y).  The result will be in (0,2*PI).

 CBRT(X)     returns the cubic root of X.

 COS(X)      - the absolute value of X must be less than 3.35&+7
             (5.56&&+16 if LONG REAL X).

 COSH(X)     - the absolute value of X must be less than 88.028
             (709.089).

 ENTIER(X)   returns the greatest INTEGER not greater than X. X
             must be representable as an integer.

 EXP(X)      X may be COMPLEX, the value returned will be of the


                                80
 ^pg;
                     9. Predefined Procedures


             type of X. If X is COMPLEX, ABS(X.RE)<=88.028 and
             ABS(X.IM)<=3.35&+7.

 LN(X)       X may be COMPLEX, the value returned will be of the
             type of the argument. X must not be zero or negative.

 LOG(X)      base 10 logarithm, otherwise as LN.

 MAX(...)    may have any number of parameters of the same type.
             Returns the largest of the arguments.

 MIN(...)    may have any number of parameters of the same type.
             Returns the smallest  value of the arguments.

 MOD(X,Y)    returns the remainder of the integer division of
             INTEGER X by INTEGER Y.

 SIGN(X)     returns the INTEGER value 1 if X>0, -1 if X<0 and 0
             if X is zero (+0 or -0).

 SIN(X)      - see COS for restrictions.

 SINH(X)     - see COSH for restrictions.

 SQRT(X)     X may be COMPLEX. Negative (LONG) REAL arguments are
             not accepted.

 TAN(X)      - see COS for restrictions.

 TANH(X)     the absolute value of X must be less than 44.014
             (354.544 if LONG REAL).



 9.2   _Character handling procedures_.


 CHAR(N)     returns the character corresponding to ISO code N. N
             must be INTEGER and in the interval 0-255.

 DIGIT(C)    returns TRUE if CHARACTER C is a decimal digit and
             FALSE otherwise.

 ISOCHAR(N)  identical with CHAR.

 ISORANK(C)  identical with RANK.

 LETTER(C)   returns TRUE if CHARACTER C is a letter (A-Z,a-z) and
             FALSE otherwise (note that the national positions of
             the ISO code are not considered letters).

 RANK(C)     returns the ISO code corresponding to the CHARACTER C
             as an INTEGER value.









                                81
 ^pg;
                     9. Predefined Procedures


 9.3  _Random Drawing Procedures_.


 Each of the random drawing procedures is based on basic drawings
 from the uniform distribution in the interval <0,1>. The
 following multiplicative congruential generator is used:

         U(n+1) = ( 5**13 * U(n) )  modulo  2**35

 In the descriptions below the last parameter U represents a
 stream of psuedo random numbers. By giving U an initial value,
 the programmer effectively selects one particular pseudo random
 number stream. Repeated executions of a program in which the
 initial value of U is fixed will thus produce, on each occasion,
 an identical random number stream.

 U must be a variable which is declared as of type INTEGER. Its
 initial value must be odd.

 DISCRETE(A,U).  The function value is an integer in the range
        (lsb,usb+1), where lsb and usb are the lower and upper
        subscript bounds respectively of the one-dimensional REAL
        array A. A, augmented by the imaginary element A(usb+1)
        whose value is l, is interpreted as a step function of the
        subscript, defining a discrete (cumulative) distribution
        function.  The result is the smallest value of i such that
        A(i) is greater than a basic drawing "u". A runtime error
        occurs if A is not one-dimensional.

 DRAW(A,U).  The function returns the Boolean value TRUE with the
        probability A and the value FALSE with the probability
        1-A. The value is always true if A>=1 and FALSE if A<=0.

 ERLANG(A,B,U).  The function is a drawing from the Erlang
        distribution with mean 1/A and standard deviation
        1/A*SQRT(B)). If A and B are not both greater than zero, a
        runtime error occurs.

 HISTD(A,U).  The function value is an integer in the range
        (lsb,usb), where lsb and usb are the lower and upper
        subscript bounds respectively of the one-dimensional REAL
        array A. A is interpreted as a histogram defining the
        relative frequencies of its subscript values. Runtime
        errors occur if A is not one-dimensional or if any of its
        elements is negative.

 HISTO(HY,HX,X,DY).  (not standard)
          (INTEGER or REAL) ARRAY  HY, HX;
          (INTEGER or REAL)         X, DY; The procedure updates a
        histogram of X-values represented by the one-dimensional
        arrays HX and HY. The elements of HY represent the
        weighted number of occurrences of observations within the
        ranges defined by the corresponding elements of HX. HY
        must contain at least one more elemen than HX. This
        element is used to accumulate observations which are
        larger than all the elements of HX. HX is searched to find
        the pair of elements such that

                HX(i-1) < X <= HX(i)



                                82
 ^pg;
                     9. Predefined Procedures


        HY(i) is then incremented by the weight DY, e.g. if

                HY = ( 1, 4, 5, 7, 5, 3, 1, 1 )  and
                HX = ( 0, 5,10,15,20,25,30 )

        the procedure call HISTO(HY,HX,23,1) increments the sixth
        element of HY by 1. Runtime errors occur if HY is not
        longer than HX or if either array is not one-dimensional.

 LINEAR(A,B,U).  The function value is a drawing from a cumulative
        distribution function F. A and B are one-dimensional REAL
        arrays whose elements bear the relationship A(i)=F(B(i)).
        The values of the B(i) need not be equidistant but must be
        strictly increasing, i.e. B(i+1)>B(i). The first and last
        elements of A must be 0 and 1 respectively. Moreover, the
        A(i) must be such that A(i+1)>=A(i). If any of the
        requirements on A and B and their elements is not
        satisfied, a runtime error occurs.

 NEGEXP(A,U).  The function value is a drawing from the negative
        exponential distribution with mean 1/A. This represents a
        random waiting time in a Poisson distributed arrival
        pattern with an expected arrival rate of A per time unit.
        Thus, the expected interval between arrivals is 1/A.  A
        run time error occurs if A is negative or zero.

 NORMAL(A,B,U).  The function value is a drawing from the normal
        distribution with mean A and standard deviation B.

 POISSON(A,U).  The function value is a drawing from the Poisson
        distribution with parameter A. If A is negative, a runtime
        error occurs. If A is greater than 20, the function is
        approximated by
                ENTIER( NORMAL(A,SQRT(A),U) + 0.5 ).
        If this approximation formula yields a negative result,
        the function value is zero.

 RANDINT(A,B,U).  The function value is one of the integers A, A+1
        ... B with equal probability. A runtime error occurs if A
        is greater than B.

 UNIFORM(A,B,U).  The function value is a REAL number uniformly
        distributed in the interval (A,B). A runtime error occurs
        if A is greater than B.



 9.4   _Miscellaneous standard procedures_.


 The procedures below are additional to the standard procedures
 defined in Common Base Simula.

 CLOCK       returns an INTEGER value giving the time of day,
             measured in milliseconds from midnight, obtained by
             an ER TIME$.

 COM(T,R)    TEXT PROCEDURE COM(T,R);
             VALUE T;  TEXT T; BOOLEAN R;
             This procedure allows the programmer to employ the


                                83
 ^pg;
                     9. Predefined Procedures


             COM$ feature. The text T is written on the operator's
             console.  If R is TRUE, the reply from the operator
             is returned as the value of COM, otherwise NOTEXT is
             returned. Messages sent to or received from the
             operator may not exceed 50 characters in length.

 CSF(T)      INTEGER PROCEDURE CSF(T);
             VALUE T;  TEXT T;
             This procedure enables the programmer to employ the
             CSF$ feature. The text value designated by T must be
             a legal control statement for CSF$. The function
             value is the status code returned by EXEC after the
             execution of the CSF$ request.

 DATE        TEXT PROCEDURE DATE;
             Returns a 12 character text containing the time and
             date in the format MMDDYYHHMMSS.  The information is
             obtained via an DATE$ request.

 PRLINE      returns the INTEGER line number of the source text
             line in which it appears, independent of the setting
             of compiler option Z.

 RTOFF(C)    BOOLEAN PROCEDURE RTOFF(C);  CHARACTER C;
             The procedure may be used to switch off a RTS-option
             designated by the letter C. The procedure returns
             TRUE if the option was set at entry, otherwise FALSE.
             A warning will be issued if the option may not be
             changed during execution.

 RTON(C)     BOOLEAN PROCEDURE RTON(C);  CHARACTER C;
             - as RTOFF except that the option is switched on.

 RTOPT(C)    BOOLEAN PROCEDURE RTOPT(C);  CHARACTER C;
             The procedure returns the setting of the RTS-option
             as a boolean value, ie on corresponds to TRUE.

 TIMEUSED    returns an INTEGER value containing the CPU time used
             so far by this run in multiples of 200 microseconds.
             It is obtained by reading a part of the program
             control table (PCT$) and represents the accumulated
             run time therefrom.



 9.5   _External utility library_.


 The external utility library is a preliminary set of utility
 procedures to be used in Univac 1100 SIMULA programs. They are
 all written as external library procedures or external assembly
 procedures, and are not meant to be part of the Univac 1100
 SIMULA standard system. They are included in the SIMULA library
 file.

 The library consist at the moment of the following procedures:

 File and processor interface:
         COPELT, LOCELT
         LOCELT


                                84
 ^pg;
                     9. Predefined Procedures


         OPENINFOR,INFORCOMP,INFORCOMP0
         PROPS,PROP

 Source input utility routine:
         DEFSIR

 Text conversion routines:
         ASCIITOFD,FDTOASCII

 Print and punch control:
         PRINTCONTROL,PUNCHCONTROL

 Binary I/O:
         BININ,BINOUT

 Partial word operations:
         PUTBYTE,GETBYTE,STOREBYTE

 Get value of ARRAY attribute:
         LOWER,UPPER,NOELT

 Drawing Procedure:
         PSNORM

 Error and tracing procedures:
         SNAPSHOT,ERROR

 Storage management routines:
         FREESTORAGE,SETSTORAGE,GARBCOLLECT

 Synchronisation procedures:
         - see chapter 8

 If a procedure is used, it must be included in the user program
 exactly as shown under each procedure.


 9.5.1.   Copy file to element.


 EXTERNAL LIBRARY PROCEDURE Copelt(fl,elt);
 REF(FILE) fl; VALUE elt; TEXT elt;
 ;

 The reference parameter fl must refer to an object of class
 OUTFILE or DIRECTFILE which is not a PRINTFILE or a PUNCHFILE.
 The associated physical file must be on fastrand, and the file
 must have been closed by an explicit call on the procedure Close
 before Copelt is called.

 The parameter elt must be a text value of the form "<File-
 name>.<Element name>/<Version>", where the /<Version>-part is
 optional.

 An actual call on the procedure Copelt is analogous to the FURPUR
 command @COPY,I . The contents of the file fl will be copied into
 the symbolic element identified by the value of the parameter
 elt.

   Example:


                                85
 ^pg;
                     9. Predefined Procedures


 The following program will read the symbolic element ELT1/VER
 from the program file F1, insert sequence numbers in column 73-80
 of each image and finally insert the resulting set of images as a
 new element ELT2/VER in the program file F2.  The procedure
 Locelt is described in next section.

 BEGIN TEXT Card,Sequ; INTEGER I;

       EXTERNAL LIBRARY PROCEDURE Locelt(f,n,v);
       REF(Infile) f; VALUE n,v; TEXT  n,v;
       ;
       EXTERNAL LIBRARY PROCEDURE Copelt(f,elt);
       REF(FILE) f; VALUE elt; TEXT elt;
       ;
       Card:-Blanks(80); Sequ:-Card.Sub(73,8);
       INSPECT NEW Outfile("scratch") DO BEGIN
             Open(Card);
             INSPECT NEW Infile("F1") DO BEGIN
                   Locelt(THIS Infile,"ELT1","VER");
                   Open(Card);
             L:    I:=I+1; Inimage;
                   Sequ.Putint(I);
                   IF NOT Endfile THEN BEGIN
                      Outimage; GOTO L  END *if*;
                   Close   End  *inspect F1*;
             Close;
             Copelt(THIS Outfile,"F2.ELT2/VER");
             END  *inspect scratch*

       END  *program* ;


 9.5.2.   Locate element in a program file.


 EXTERNAL LIBRARY PROCEDURE Locelt(f,n,v);
 REF(Infile) f; VALUE n,v; TEXT n,v;
 ;

 The procedure Locelt can be used on an Infile whose associated
 physical file is a program file. At the time of call, the Infile
 must be closed and the function of the procedure is to provide
 the system with the neccessary data to ensure that when the
 Infile is opened it is located at the beginning of the element
 with name n and version v.  Without this procedure, a program
 file could not be used as the assosiated physical file for
 Infile.

 Note: The INIMAGE routine will not check any cycle numbers.  All
       images are given to the user.  Cycle updating is fully
       supported by the Defsir redefinition of SYSIN.











                                86
 ^pg;
                     9. Predefined Procedures


 The following program will list the element
 "PFILE.ELTNAME/VERSION".

 INSPECT NEW Infile("PFILE") DO BEGIN
       EXTERNAL LIBRARY PROCEDURE locelt(f,n,v);
       REF(Infile) f; VALUE n,v; TEXT n,v;
       ;
       Locelt(THIS Infile,"ELTNAME","VERSION");
       Open(Sysout.Image);
       WHILE NOT Endfile DO BEGIN Inimage; Outimage END;
       Close  END  *program*


 9.5.3.   Processor options utility routine


 EXTERNAL LIBRARY BOOLEAN PROCEDURE Props;
 ;

 The value of this procedure is TRUE if there are options on the
 processor call statement, otherwise the value is FALSE.

 EXTERNAL LIBRARY BOOLEAN PROCEDURE Prop(c);
 CHARACTER c;
 ;

 The value of this procedure is true if the processor option
 denoted by the character c is set on the processor call
 statement, otherwise the value is false.


 9.5.4.   INFOR table interface.


 EXTERNAL LIBRARY PROCEDURE Openinfor;
 ;

 The procedure Openinfor reads information from the processor call
 card (infor table, see (3) volume 4) into an internal buffer.
 This procedure must be called before the first call on
 Sysin.Inimage.


 EXTERNAL LIBRARY TEXT PROCEDURE Inforcomp(Fn,Sfn);
 INTEGER Fn,Sfn;       ! 1 <= Fn <= 63, 1 <= Sfn <= 8;
 ;

 This routine can only be used after a call on either Openinfor or
 Defsir. At most one of the procedures Openinfor or Defsir can be
 used in the same program because Openinfor is included in Defsir.

 The operand field of the processor call statement consists of a
 sequence of parameters, separated by commas.  Fn is the ordinal
 number of one of these parameters.  Each of these parameters may
 contain information of any kind, as long as it conforms to the
 syntax conventions of a file name or element name as defined in
 (3) and (5).

 Sfn is the code number of the requested component according to
 the following table:


                                87
 ^pg;
                     9. Predefined Procedures


            1  file qualifier
            2  file name
            3  file cycle
            4  read key
            5  write key
            6  element name
            7  version name
            8  element cycle

 Normally Inforcomp(Fn,Sfn) returns a text, the value being the
 component Sfn of parameter Fn if this exists.

 If the component is a file qualifier implied by a leading *
 before the file name, or if the component is a file name implied
 by a leading . before the element name, the text value returned
 will be BLANKS(12). In all other cases NOTEXT is the return
 value.


 EXTERNAL LIBRARY TEXT PROCEDURE Inforcomp0(Fn,Sfn);
 INTEGER Fn,Sfn;
 ;

 This routine is analogous to Inforcomp, and must not be called
 before either Openinfor or Defsir.  Inforcomp0 returns
 information from the operation field of the processor call
 statement e.g. the processor name.


 9.5.5.   Source input utility routine.


 EXTERNAL LIBRARY PROCEDURE Defsir;
 ;

 The procedure Defsir can be used when writing a processor in
 SIMULA, to make available all the facilities of SIR$ (See (3)
 volume 4).

 These facilities are the input of images from element in
 SDF-formatted file, use of correction cards to an element,
 inserting a new element from the runstream into a file, updating
 in cycles or producing a new element.  All this depends on
 options and specifications on the processor call statement.

 A call on Defsir is, in fact, a redefinition of SYSIN  and,
 therefore, an earlier use of SYSIN will cause an error when
 entering Defsir.  Only one call on Defsir is allowed.

 After a call on Defsir input images are available for the user by
 the normal call on INIMAGE as for SYSIN. The images obtained are
 different from a normal SYSIN.IMAGE because the first eight
 characters contain some special information which may be of
 interest to the user.  The first four characters contain the
 cycle number at which the image was added to the element. The
 next four characters contains the correction identification.
 This is "NEW" if this image is from the correction cards, "-xx"
 where xx is the number of images deleted before this image, or
 blank.  If an end of file is encountered by SIR$, these eight
 characters contain the text value "@EOF    ".


                                88
 ^pg;
                     9. Predefined Procedures


 The user may want to read the images more than once. He can
 easily perform a second pass by closing (Sysin.Close) and
 reopening (Sysin.Open) the file. The images are now available
 again from the beginning of the element by further calls on
 Inimage.  The file is initially opened and finally closed within
 BASICIO (Outside the program itself).

 Inimage will, as for ordinary Sysin.Inimage, work optimally if
 the original image text allocated by the runtime system is not
 changed.  When a different image text is used, the following
 should be noted. Use of an image of less than 86 characters when
 listing of correction cards (W-option), will cause the printed
 lines of correction cards to have an end-fringe of size
 ((86-Image.Length)//4)*4 which is not blanked.

 When a SIMULA program is going to be used as a processor,
 compilation ought to be performed under the D-option. In this
 case, the options specified on the processor call statement have
 no significance to the runtime system. Therefore SIMULA runtime
 options must be specified by the %RTSOPT directive.

 Example:

 Below a processor SIRELT is written in SIMULA analogously to the
 eltprocessor (@ELT). If the L-option is on, SIRELT will list the
 source input with linenumber in column 1-6, correction
 identification in column 9-11,cycle number in column 13-15, and
 the source image from column 19.  If listing of correction cards
 (W-option) is required and also L-option is on, then SIRELT is
 constructed to make two passes so that the listing of correction
 cards is not mixed with the output of source images.  The
 processor SIRELT is introduced as an absolute element in TPF$.

 The external procedure Prop was described above.  The additional
 text variable t is used to save the original Sysin.Image while
 Sysin is closed.

 @S*I.M,SIDV  SIRELT
   BEGIN
       EXTERNAL LIBRARY PROCEDURE Defsir;
       ;
       EXTERNAL LIBRARY BOOLEAN PROCEDURE Prop(c);
       CHARACTER c;
       ;
       TEXT t; BOOLEAN Loption;

       Defsir; Loption:=Prop('L');
       IF Prop('W') OR NOT Loption THEN BEGIN
             WHILE NOT Endfile DO Inimage;
             t:-Sysin.Image; Sysin.Close; Sysin.Open(t) END;
       IF Loption THEN BEGIN
           INTEGER Line;
           TEXT Cycle1,Cycle2,Corrid1,Corrid2;
           TEXT Prt1,Prt2;
           Cycle1:-Image.Sub(13,3);
           Cycle2:-Sysin.Image.Sub(1,3);
           Corrid1:-Image.Sub(9,3);
           Corrid2:-Sysin.Image.Sub(5,3);
           Prt1:-Image.Sub(19,Image.Length-18);
           Prt2:-Sysin.Image.Sub(9,Sysin.Image.Length-8);


                                89
 ^pg;
                     9. Predefined Procedures


           Inimage;
           WHILE NOT Endfile DO BEGIN
               Line:=Line+1;
               Outint(Line,6);
               Cycle1:=Cycle2; Corrid1:=Corrid2;
               Prt1:=Prt2; Outimage; Inimage;
           END  *** while ***
       END  *** loopt ***
   END *** SIRELT ***;
   %RTSOPTIONS = "ZR";


 Examples of processor call statements follows.

 List and introduce a new element INPUT into TPF$:

    @TPF$.SIRELT,IL    TPF$.INPUT


 List correction images, update and list a new cycle of element
 INPUT:

 @TPF$.SIRELT,UWL   TPF$.INPUT


 Produce a listing of the latest cycle of element INPUT:

 @TPF$.SIRELT,L     TPF$.INPUT


 Produce a new element INPT in TPF$ from cycle one of element
 INPUT:

 @TPF$.SIRELT       TPF$.INPUT(1),,TPF$.INPT


 All source input routine options and L-option apply to SIRELT.



 9.5.6.   Text conversion routines.


 In some cases it may be necessary to convert a text from the
 standard ASCII representation to fieldata representation. Note
 however that the fieldata "text objects" cannot be handled by the
 level 3 Simula system.  These procedures should therefore be used
 with extreme caution and only in connection with calls on
 external procedures written eg. in FORTRAN V.


 EXTERNAL LIBRARY TEXT PROCEDURE asciitofd(asciitext);
 VALUE asciitext; TEXT asciitext;
 ;

 The value is a "fieldata text descriptor" pointing to a "text
 object" which contains the fieldata representation of the
 asciitext.




                                90
 ^pg;
                     9. Predefined Procedures


 EXTERNAL LIBRARY TEXT PROCEDURE fdtoascii(fdtext);
 VALUE fdtext;    TEXT fdtext;
 ;

 The value is an ordinary text descriptor pointing to a text
 object containing the text value of fdtext converted to ascii.


 9.5.7.   Print and punch control.


 EXTERNAL LIBRARY PROCEDURE Printcontrol(pf,t);
 VALUE t;   REF(Printfile) pf; TEXT t;
 ;


 EXTERNAL LIBRARY PROCEDURE Punchcontrol(pf,t);
 VALUE t;   REF(Punchfile) pf; TEXT t;
 ;


 The library procedures Printcontrol and Punchcontrol are defined
 to make it possible to perform a number of control functions on
 Print and Punch files.  Each procedure has a text parameter used
 to define the actual control function. These control functions
 are the same as described in (3) under symbiont control.

 Example: Punch 8 channel paper tape.

   INSPECT NEW Punchfile("pchfile") DO BEGIN
       EXTERNAL LIBRARY PROCEDURE Punchcontrol(pf,t);
       VALUE t;   REF(Punchfile) pf; TEXT t;;

       Open(Sysin.Image);
       Punchcontrol(THIS Punchfile,"C,8.");
       WHILE NOT Endfile DO BEGIN Inimage; Outimage END;
       Close  END *punch*;

 Example: Listing with heading.

   INSPECT NEW Printfile("prtfile") DO BEGIN
       EXTERNAL LIBRARY PROCEDURE Printcontrol(pf,t);
       VALUE t;   REF(Printfile) pf; TEXT t;;

       Open(Sysin.Image);
       Printcontrol(THIS Printfile,"H, ,1,textofheading.");
       WHILE NOT Endfile DO BEGIN Inimage; Outimage END;
       Close  END *listing*;


 9.5.8.   Access to non-standard files.


 Under certain circumstances the user will need procedures to read
 and write non-standard files in binary form. The following two
 library procedures Binin and Binout are defined to meet this
 requirement. They will perform a transfer of a binary block
 between an array object in core storage and an external file.
 Both procedures are implemented using the executive request IOW$.
 A detailed description is given below.


                                91
 ^pg;
                     9. Predefined Procedures



 EXTERNAL LIBRARY INTEGER PROCEDURE binout(fn,loc,arr);
 VALUE fn;   TEXT fn; INTEGER loc;
 <type> ARRAY arr;
 ;

 The value of the text parameter fn must be the internal file name
 of some preassigned file. Depending upon the equipment type of
 the file Fn, this procedure performs one of the following
 functions:


 Fastrand file:  The elements of the array are written onto the
       file beginning at sector location loc. (Sector location
       numbers start at zero.)


 Word-addressable drum file:  The elements of the array are
       written onto the file beginning at address loc. (Address
       numbers start at zero.)


 Tape file:  The elements of the array are written onto the tape,
       thus constituting a new tape block.


 If the transfer is completed normally the number of words
 actually transfered becomes the value of the procedure. Otherwise
 the status code from IOW$ with negative sign becomes the value of
 the procedure. (IOW$ status codes are defined in (3) and (5)).
 EXTERNAL LIBRARY INTEGER PROCEDURE binin(fn,loc,arr);
 VALUE fn;   TEXT fn; INTEGER loc;
 <type> ARRAY arr;
 ;

 The value of the text parameter fn must be the internal file name
 of some preassigned file. Depending upon the equipment type of
 the file Fn, this procedure performs one of the following
 functions:


 Fastrand file:  The elements of the array are filled with the
       binary information in the file beginning at sector location
       loc.  (Sector location numbers start at zero).


 Word-addressable drum file:  The elements of the array are filled
       with the binary information in the file beginning at
       address loc.  (Address numbers start at zero).


 Tape file:  The elements of the array are filled with the binary
       information from the current tape block. If the tape block
       is too short, some elements at the end of the array object
       remain unchanged. If the tape block is too large to be
       contained within the array, the rest of the block is lost.


 If the transfer is completed normally, the number of words
 actually transfered becomes the value of the procedure.


                                92
 ^pg;
                     9. Predefined Procedures


 Otherwise, the status code from IOW$ with negative sign becomes
 the value of the procedure. (IOW$ status codes are defined in (3)
 and (5)).



 9.6   _Partial word operations_.


 EXTERNAL LIBRARY
 INTEGER PROCEDURE Putbyte(byte,n,bitpos,length);
 INTEGER byte, n, bitpos, length;
 ;

 The value associated with the procedure name is an integer
 constructed by putting byte into length bits of n, starting at
 bit number bitpos. The integers byte and n are not changed.  If
 byte occupies more than length bits, only the rightmost bits are
 used.  The bits are numbered from right to left in the range 0 -
 35.  That means that bit number 0 is the rightmost bit.


 EXTERNAL LIBRARY
 INTEGER PROCEDURE Getbyte(n,bitpos,length);
 INTEGER n,bitpos,length;
 ;

 The value associated with the procedure name is an integer
 constructed by extraction of length bits from n, starting at bit
 number bitpos.  The bits are numbered as in Putbyte.



 Note: Putbyte and Getbyte operate on the bit pattern.  The user
       himself must take precautions against conditions which may
       cause unexpected results i.e. overflow conditions (byte
       occupies more than length bits) or negative numbers.


 EXTERNAL LIBRARY PROCEDURE Storebyte(n,byte,index);
 NAME n;   INTEGER n, byte, index;
 ;

 The procedure Storebyte executes an instruction which stores the
 value of byte into a part of n designated by index according to
 the table below.


 EXTERNAL LIBRARY INTEGER PROCEDURE Loadbyte(n,index);
 NAME n;   INTEGER n,index;
 ;

 The procedure Loadbyte executes an instruction which loads the
 value to be associated  with the procedure name from a part of n
 designated by index according to the table below.







                                93
 ^pg;
                     9. Predefined Procedures


           -------------------------------------
          !           !  Assembly instruction:  !
          !           !                         !
          !  Index    !    Store  !   Load      !
          !-----------+-----------+-------------!
          !    1      !    S,S6   !   L,S6      !
          !    2      !    S,S5   !   L,S5      !
          !    3      !    S,S4   !   L,S4      !
          !    4      !    S,S3   !   L,S3      !
          !    5      !    S,S2   !   L,S2      !
          !    6      !    S,S1   !   L,S1      !
          ! - - - - - - - - - - - - - - - - - - !
          !    7      !    S,T3   !   LM,T3     !
          !    8      !    S,T2   !   LM,T2     !
          !    9      !    S,T1   !   LM,T1     !
          ! - - - - - - - - - - - - - - - - - - !
          !   10      !    S,H2   !   L,H2      !
          !   11      !    S,H1   !   L,H1      !
           -------------------------------------

                    Instruction Table.

             See Univac 1100 series reference
          (j-determined partial word transfers)



 9.7   _Retreive ARRAY attributes_.


 EXTERNAL ASSEMBLY INTEGER PROCEDURE Lower;


 EXTERNAL ASSEMBLY INTEGER PROCEDURE Upper;


 EXTERNAL ASSEMBLY INTEGER PROCEDURE Noelt;


 These procedures retrieve the lower bound, upper bound or number
 of elements in a given one-dimensional array of any type.

 Each of these procedures accepts only parameter which must be an
 array. An array called by value or default can also be used.  Use
 of an array called by name as a parameter to these procedures is
 illegal and will cause a runtime error.


  Example:

       TEXT ARRAY t(0:2);
       Outint(Upper(t),6);

 - the value 2, the upper bound of array t, is printed.








                                94
 ^pg;
                     9. Predefined Procedures


 9.8   _Pseudo-normal drawing procedure_.


 EXTERNAL LIBRARY REAL PROCEDURE Psnorm(a,b,c,u);
 NAME u;   REAL a, b;  INTEGER c, u;
 ;

 This procedure returns a value which is a sum of c basic
 drawings, suitably transformed so as to approximate a drawing
 from the Normal distribution.

 The following formula is used:

      A+B*(U(1)+...+U(C)-C/2)*SQRT(12/C)

 Psnorm is faster, but less accurate than the standard procedure
 Normal(a,b,u).


 Note: Antithetic drawings (when reversing the sign of the value
       u) are not obtained when the procedure Psnorm is used.



 9.9   _Error and tracing procedures_.




 9.9.1.   Trace Dynamic Chain


 EXTERNAL LIBRARY PROCEDURE Snapshot;
 ;

 The procedure Snapshot makes it possible for the user at certain
 points during program execution to trace the dynamic structure
 backwards until begin program. This backtrace is exactly the same
 as is given after the occurence of a runtime error.


 9.9.2.   Forced Runtime Error


 EXTERNAL LIBRARY PROCEDURE Error(t);
 VALUE t;   TEXT t;
 ;

 The call on this procedure causes the occurence of an ordinary
 runtime error. The very first message printed is equal to the
 text parameter t, and the program then terminates in error 48
 (forced runtime error).

 The text parameter t must always be specified. However, NOTEXT is
 a legal value of t.

 A text parameter longer than 132 characters will not be printed.





                                95
 ^pg;
                     9. Predefined Procedures


 9.10  _Storage management routines_.


 The user should be familiar with the storage allocation, internal
 representations and storage utilisation of the SIMULA run time
 system as described in chapter 10, in order to get a full
 understanding of the procedures described in this section.


 EXTERNAL LIBRARY INTEGER PROCEDURE Freestorage;
 ;

 A call on this routine during program execution gives the number
 of words which is not yet dynamically allocated from the runtime
 data storage pool i.e. the number of words which may be allocated
 before a garbage collection occurs.  Note that data storage
 allocated by objects which are no longer accessible cannot be
 reused before the occurence of a garbage collection. However,
 notices are put on a free chain and may be reused without any
 garbage collection.


 EXTERNAL LIBRARY PROCEDURE Setstorage(n);
 INTEGER n;
 ;

 The free notice chain is cleared and data storage is allocated
 until the size of free storage is the number of words specified
 by the parameter n.  However, no reference is established to the
 storage allocated and therefore it is released at next garbage
 collection.

 The procedure Setstorage and Freestorage make it possible for the
 user to control the occurence of garbage collection. By a call on
 Setstorage he can be sure that so little free storage remains
 that the next storage request cannot be satisfied. Thus he can
 force garbage collection to take place at certain contexts during
 program execution.


 EXTERNAL LIBRARY PROCEDURE Garbcollect;
 ;

 By means of the storage utilisation routines (described above)
 the user is able to decide the amount of free storage left and
 thus force garbage collection to take place at certain contexts
 (types of storage request).

 A call on the procedure Garbcollect invokes the garbage
 collection directly regardless of how much free storage is left.
 The result is that the amount of free storage left is increased
 by the storage of all unused objects at the time of call.










                                96
 ^pg;



 10  RUN TIME REPRESENTATION


 On entry to a block, procedure or class, a data block or object
 is allocated dynamically from the storage pool. The first word of
 this object is used for internal administrative purposes. The
 remaining words are used to store representations of the data
 referenced by quantities declared local to the block or specified
 as parameters to it. This section describes some of the internal
 formats used to represent declared quantities and parameters in
 blocks. It is included primarily to give the programmer the means
 to establish how much of the storage pool his program structures
 occupy at a given time. This can have considerable influence on
 the size of model his program can accommodate.

 We feel that in certain cases, particularly in connection with
 parameters called by name, more confusion than enlightenment
 would result from describing the internal formats. These formats
 are so heavily dependent on specialised implementation techniques
 which may be altered in future developments that it would be
 dangerous to rely on them. Thus the information is deliberately
 omitted from this description.

 The following subsections which outline the structures of the
 various types of object and the nature of their contents should
 be treated as no more than a guideline.



 10.1  _Program Structure_.


 SIMULA programs may be considered as assemblages of units which
 may be ALGOL blocks, procedures, classes, prefixed blocks and
 inspection blocks. In this section, the term "block" is used
 loosely to represent any of these program components. The term
 "ALGOL block" refers to the structure defined formally as a block
 in ALGOL 60. Compound statements are thus excluded from this
 informal definition of a block (as a matter of fact, the compound
 statement is a pure syntactic structure and no corresponding
 construction can be found in the executing program).

 The static (textual) structure of a program reflects the manner
 in which the program is built up from its various components,
 i.e. the positioning of its blocks relative to one another in the
 source listing. The word "dynamic" is used in connection with the
 situation which exists at any stage during execution. The dynamic
 situation reflects, not the composition of the program, but
 rather the sequence in which the components are brought into
 action.

 It is convenient to regard the static structure of a program as a
 hierarchy of block levels. A block which is defined within
 another block is said to be at a higher block level. Thus the
 outer block of a program has the lowest possible level. At any
 level, the user has access to the attributes which are local to
 this level, i.e. to attributes which are declared in the block,
 are formal parameters of the block or are inherited by the block
 through prefixing (concatenation). In addition to these
 attributes, the user may refer, in general, to attributes which


                                97
 ^pg;
                   10. Run Time Representation


 are global to the block, i.e.  which are accessible in the block
 textually  enclosing the block in question. Stepping back one
 level to the enclosing block, the same assertion holds in that
 the user has access to the local and global attributes of this
 block.

 For example:

        BEGIN INTEGER i;        <-------------------
            ...                                     !
            BEGIN REAL r;       <-----------        !
                ...                         !       !
                BEGIN TEXT t;   <---
                     ...           (3)     (2)     (1)
                END;            <---
                ...                         !       !
            END;                <-----------        !
            ...                                     !
        END;                    <-------------------


 The above example is composed of 3 block levels as shown.

 - At level 1, only the variable I is accessible.

 - At level 2, I and R are accessible while, at level 3, T is also
   available. Thus, within any program block, the programmer has
   access to the local attributes of this block plus those of all
   the blocks which textually enclose it. The exception, of
   course, is where attribute redeclaration "hides" those at lower
   levels.

 In OS1100 SIMULA, a mechanism which displays all visible
 attributes simultaneously ensures equally rapid access to each.
 Thus, in the example, within the innermost block it takes no
 longer to access I than to access T. Each time a block is entered
 or left, the display mechanism is adjusted to reflect the new
 situation.

 To achieve maximum efficiency in both attribute access and
 display updating, most of the computer's index registers are
 employed, one per block level.  This imposes a limit on the depth
 to which blocks may be nested. This is purely a static
 consideration and has no influence whatsoever on dynamic nested
 situations such as recursion.

 The maximum depth of nested block structure in OS1100 SIMULA is
 9, counting the outermost block as level 1. In practice, this
 limit is seldom restrictive for the programmer who designs his
 program structure sensibly. However, inadequate forethought or
 ignorance of the criteria controlling block level allocation can
 lead to the "frivolous" creation of new block levels which could
 result in the limit being exceed. This situation is diagnosed by
 the compiler.

 Although attribute access time is not impaired by deep block
 nesting, unnecessarily complicated block structure can introduce
 other inefficiencies.  Transition from one block level to another
 is always accompanied by overheads while the runtime system
 performs the necessary administration. In this respect, the


                                98
 ^pg;
                   10. Run Time Representation


 interests of efficiency can conflict with recommended structuring
 strategy. Compromise is the sensible solution.

 Block levels are allocated where new blocks are declared or
 defined. This is not necessarily where they are entered.

 In the following situations, new block levels are allocated:

 1)   Occurrence of a new Algol block, i.e. a program structure
      bounded by BEGIN and END and containing at least one
      declaration.

 2)   Declaration of a procedure or class. Whether the body is a
      simple statement, compound statement or block, only one new
      block level is allocated.

 3)   Occurrence of a prefixed block.

 4)   Occurrence of an inspection statement. If the connection
      block (i.e. the statement immediately following DO) is
      labelled, contains a label, contains a FOR-statement or
      takes the form of an block, two block levels are allocated,
      otherwise only one block level is allocated.

 At the end of each type of block, the block level is stepped back
 the appropriate number of levels.  Whether it has the appearance
 of a block or a compound statement, the outer block of a program
 always occupies block level 1.  The depth of prefixing has no
 influence on block level allocation, i.e. on the occurrence of a
 subclass declaration or prefixed block, only one block level is
 allocated regardless of the length of the prefix chain.































                                99
 ^pg;
                   10. Run Time Representation


 The following figure illustrates the rules above:

 Block level

     1 --->  BEGIN INTEGER i;
     2 ------->  CLASS c;
                 BEGIN REAL x;
                     ...
                 END;
     1 ........  REF(c) cref;
                 ...
     2 ------->  BEGIN
     3 ----------->  PROCEDURE p;
                     BEGIN
                         ...
     4 --------------->  INSPECT cref DO x := x + 1.0;
     3 ............      ...
                     END;
     3 ----------->  PROCEDURE q;
                     IF i = 10 THEN BEGIN
                        i    := 0;
                        cref :- NEW c;
                     END;
     2 ............  ...
                 END;
     1 ......... ...
             END;


     i --->   means: A new block level 'i' is allocated.

     j ....   means: The block level 'j' is continued.



 10.2  _Storage allocation_.


 All data storage used by the program is allocated by the Simula
 run time system as 'objects'. This chapter describes the lay-out
 of objects in a schematic manner so that the programmer can get
 an idea of the storage demands of a given program. We emphasize
 that the description given is not detailed. Also, the run time
 system may itself allocate control structures ('drivers' and
 'event notices'), it is outside the scope of this manual to
 describe these. Neither will the lay-out and meaning of the
 'prototypes' (constant records allocated by the compiler, which
 describe the contents of the dynamic objects to the run time
 system) be given.


 10.2.1.  Program objects.


 A program object provides storage for the parameters and declared
 variables of a program block (i.e. Algol block, prefixed block,
 class or procedure).  This subsection describes the general
 organisation of program objects, later subsections give details
 of their contents.



                                100
 ^pg;
                   10. Run Time Representation


 All program objects are headed by one control word; with the
 exception of text and array objects this word will not be further
 described.  The remaining words are e.g.  used for parameters,
 declared quantities and cells required for administering FOR
 statements (not WHILE or DO UNTIL statements). The number of
 words used as FOR-cells equals the highest level of FOR-nesting
 in the block.

 The structure of each type of object will be given in the
 following sections in the form of a diagram as shown below; the
 address of the control word is the lowest storage address of an
 object.

                  ------------------------
                 !      control word      !
                  ------------------------
                 !                        !
                    ... further           !
                 !      information ...
                 !                        !
                  ------------------------



 10.2.2.  Algol block structure.


                  ------------------------
                 !      control word      !
                  ------------------------
                 !                        !
                 !                        !
                 !   declared quantities  !
                 !        FOR cells       !
                 !                        !
                 !                        !
                 !                        !
                  ------------------------



 10.2.3.  Notype Procedure.


                  ------------------------
                 !      control word      !
                  ------------------------
                 !                        !
                 !       parameters       !
                 !                        !
                  ------------------------
                 !                        !
                 !   declared quantities  !
                 !        FOR cells       !
                 !                        !
                  ------------------------






                                101
 ^pg;
                   10. Run Time Representation


 10.2.4.  Type procedure (function).


                  ------------------------
                 !      control word      !
                  ------------------------
                 !         result         !
                  ------------------------
                 !                        !
                 !       parameters       !
                 !                        !
                  ------------------------
                 !                        !
                 !   declared quantities  !
                 !        FOR cells       !
                 !                        !
                  ------------------------

 This object is allocated when the procedure is called.  As for
 the result location, one or two words are allocated according to
 the type of the result.









































                                102
 ^pg;
                   10. Run Time Representation


 10.2.5.  Class instance.


 The object of a class which is not a subclass is structured in
 the same way as a notype procedure.

 Subclass instances are represented by compound objects consisting
 of one control word followed by a concatenation of the attribute
 portions of each prefix level, e.g.

           CLASS A  ... ;
         A CLASS B  ... ;

 An object of the class B will then be structured

                  ------------------------
                 !      control word      !
                  ------------------------
                 !                        !
                 !       parameters       !
                 !        (A-part)        !
                 !                        !
                  ------------------------
                 !                        !
                 !   declared quantities  !
                 !        FOR cells       !
                 !        (A-part)        !
                 !                        !
                  ------------------------
                 !                        !
                 !       parameters       !
                 !        (B-part)        !
                 !                        !
                  ------------------------
                 !                        !
                 !   declared quantities  !
                 !        FOR cells       !
                 !        (B-part)        !
                 !                        !
                  ------------------------



 10.2.6.  Prefixed Block.


 A prefixed block is represented by a concatenated object
 containing the attribute portions of each of its prefixes plus
 that of the block itself, e.g.
           CLASS A  ... ;
           ...
           A  BEGIN
              ...
           END;








                                103
 ^pg;
                   10. Run Time Representation


 This prefixed block object is structured

                  ------------------------
                 !      control word      !
                  ------------------------
                 !                        !
                 !       parameters       !
                 !        (A-part)        !
                 !                        !
                  ------------------------
                 !                        !
                 !   declared quantities  !
                 !        FOR cells       !
                 !        (A-part)        !
                 !                        !
                  ------------------------
                 !                        !
                 !   declared quantities  !
                 !        FOR cells       !
                 !      (block part)      !
                 !                        !
                  ------------------------



 10.2.7.  Text object structure.


                  ------------------------
                 !   +/- 0   !     3      !
                 !------------------------!
                 !   OSIZE   !    LC      !
                 !------------------------!
                 ! ch1 : ch2 : ch3 : ch4  !
                 !-----+-----+-----+------!
                 ! ch5 !    ...           !
                  ------------------------

        LC =  number of characters in main text value
     OSIZE =  2 + (LC+3)//4  i.e. total size of object

 The actual text value is stored as quarterwords, starting in Q1
 of the third word as shown. The last word is zerofilled, if
 necessary.


















                                104
 ^pg;
                   10. Run Time Representation


 10.2.8.  Array object structure.


                  ------------------------
         AOBJ:   !   +/- 0    ! - LENGTH  !
                 !------------------------!
                 !         array          !
                 !       elements         !
                 !------------------------!
                 ! T ! N ! DL !    NWRD   !
                 !------------------------!
         FPA:    !  - AOBJ    !     BA    !
                 !------------------------!
                 !       dope vector      !
                  ------------------------

  (T: type code, N: number of dimensions, DL = N//2,
   NWRD: size of array object, LENGTH: - see below)

 Each array element is allocated 1 or 2 words according to type.
 LENGTH gives the number of words used for array elements. The
 last part of the object from label FPA is simply a copy of the
 corresponding array quantity, and is described later in the
 chapter.



 10.3  _Declared quantities_.


 A declared quantity is the part of an object, which corresponds
 to a variable or parameter declaration given in the program
 structure that defines the object in question.  The internal
 representation of such a quantity will be given in the following
 subsections, with the exception of NAME specified parameters; as
 mentioned previously we consider the latter to be of such
 complexity that it is outside the scope of this manual to
 describe them. The table below summarise the storage demands of
 the different quantities.























                                105
 ^pg;
                   10. Run Time Representation


                                  parameter    parameter
                    declaration   by value     by reference

  INTEGER           1 word        1 word       illegal
  REAL              1 word        1 word       illegal
  LONG REAL         2 words       2 words      illegal
  COMPLEX           2 words       2 words      illegal
  CHARACTER         1 word        1 word       illegal
  BOOLEAN           1 word        1 word       illegal
  TEXT              2 words (1)   2 words (2)  2 words (3)
  REF               1 word        illegal      1 word
  LABEL             ---           illegal      1 word
  SWITCH            ---           illegal      1 word
  ARRAY             2 words (4)   1 word  (5)  1 word  (6)
  PROCEDURE         ---           illegal      1 word  (7)

 1) Text descriptor. The object is allocated elsewhere.
 2) A new text object is created, containing a copy of the actual
    parameter value. The (formal) text descriptor points to this
    object.
 3) The formal text descriptor points to the actual parameter
    value in the text object given as parameter.
 4) - or more, see below.
 5) A new array object is created, containing a copy of the values
    of the array elements given as actual parameter. The parameter
    descriptor points to this new object.
 6) The parameter descriptor points to the array given as
    parameter.
 7) The contents of this word is not described here.


 10.3.1.  INTEGER quantities.


 An INTEGER quantity occupies one word holding the value of the
 quantity.


 10.3.2.  REAL quantities.


 A REAL quantity occupies one word holding the value of the
 quantity in single length floating point representation.


 10.3.3.  LONG REAL quantities.


 A LONG REAL quantity occupies two words holding the value of the
 quantity in double length floating point representation.


 10.3.4.  COMPLEX quantities.


 A COMPLEX quantity occupies two words, the first holding the real
 part and the second the imaginary part of the quantity. Both are
 represented as single length floating point numbers.




                                106
 ^pg;
                   10. Run Time Representation


 10.3.5.  CHARACTER quantities.


 A CHARACTER quantity is represented in the ISO (Ascii) character
 code. It occupies one word with the value right-justified, i.e.
 Q1-Q3 are zero and Q4 holds the value.


 10.3.6.  BOOLEAN quantities.


 A BOOLEAN quantity occupies one word; TRUE is represented as one,
 FALSE as (plus) zero.


 10.3.7.  REF quantities.


 A REF quantity occupies one word; NONE is represented as (plus)
 zero.  Normally H1 is zero and H2 holds the address of the class
 object pointed to.
 The LINKAGE attributes SUC and PRED are exceptions to this rule;
 for efficiency reasons they are packed into one word:

                  -----------------------
                 !    PRED   !    SUC    !
                  -----------------------


 10.3.8.  LABEL and SWITCH quantities.


 Such parameter quantities occupy one word each; the contents of
 this word will not be described here.


 10.3.9.  TEXT quantities.


 A TEXT quantity is a descriptor pointing to the text object
 containing the text value. The text descriptor is a two word
 packet with the following format:

                  -----------------------
                 !     CP    !  - TOBJ   !
                 !-----------+-----------!
                 !     SP    !   LP + 1  !
                  -----------------------

  (CP: Current position, SP: Start pos., LP: Last pos.,
   TOBJ: address of text object holding the text value)

 The character positions CP, SP, and LP are relative to Q1  of the
 first word in the text object, starting at zero. This means that
 if the descriptor refers to a main text value, SP is 8 and LP+1
 is LC+8 (cf. text object lay-out given earlier). NOTEXT is
 represented by a descriptor containing zeroes, i.e. no text
 object is present.




                                107
 ^pg;
                   10. Run Time Representation


 10.3.10.  ARRAY quantities.


 An ARRAY quantity is a descriptor pointing to an array object,
 which contains the actual array element values.


 10.3.10.1.  Array variable.


 The descriptor for an array, which is not declared as a
 parameter, is a packet of two or more words in the following
 format:

                  -----------------------
                 !  - AOBJ   !     BA    !
                 !-----------+-----------!
                 !   DV(2)   !   DV(3)   !
                  -----------+-----------
                 !          ...          !
                  -----------------------

  (AOBJ:  address of array object, BA: base address,
   DV(i): i'th element of dope vector)

 The base address of an array object is the address of the
 (possibly fictituous) element with all indices zero (i.e. the
 address of A(0,...,0)). The dope vector consists of one halfword
 for each dimension except the first. Supposing that the array is
 declared A(L1:U1,L2:U2,...,Ln:Un), then the dope vector elements
 have the following values:

        DV(1) = 1                       (not stored)
        DV(i) = U(i-1) - L(i-1) + 1     i = 2, ... ,n

 Since the actual limits Li and Ui are not stored, it is not
 possible to check the legality of access to individual array
 elements; the index check performed does, however, ensure that
 references do not exceed the area allocated to the array
 elements. The advantage is a very fast check at the expense of
 not catching all illegal combinations of indices. The check is
 correct for one-dimensional arrays.


 10.3.10.2.  Array parameter.


 The parameter descriptor for an array is one word:

                  -----------------------
                 !     0     !  - FPA    !
                  -----------------------

  (FPA: - see description of array object).








                                108
 ^pg;
                   10. Run Time Representation


 10.4  _Storage Utilisation_.


 At program initiation a data storage pool is allocated, with a
 size determined by the run time options given. Objects are
 allocated dynamically from this pool. Additional allocations
 include space for entries (event notices) in the sequencing set
 of SIMULATION programs, as well as other special system objects;
 the structure of system objects will not be described in this
 manual.

 Objects are, in effect, discarded when the program blocks they
 represent have completed their actions or when there no longer
 exist any references to them. In actual fact, allocation of new
 objects continues until the pool has been exhausted. At this
 point, a garbage collection process preserves and compacts all
 surviving objects and the storage occupied by discarded objects
 is released for re-use.

 The advantage of this is that the initialisation (to binary zero)
 may be done at program initiation and after a garbage collection,
 but not at each object allocation, thus saving considerable
 execution time.

 The degree of utilisation of the storage pool at any instant
 during the execution of the program can be estimated if the
 programmer knows how many objects are still in use. For each
 program block which is still accessible, there is a program
 object whose size can be estimated from information given in this
 chapter. In addition to this, each program object has a 4-word
 system object if the actions of the block it represents have not
 yet been completed. Each SIMULATION PROCESS class object
 possesses an additional 4-word system object, if it is currently
 represented in the sequencing set, i.e. if it is scheduled. The
 total pool utilisation is thus approximately the sum of the
 accessible object storage (including arrays and texts) and the
 system objects. Objects and notices which are no longer
 accessible should not be included in the count since their
 storage will be re-used if necessary.



 10.5  _Program capacity limitations_.


 Besides the capacity limitations given in the table below, there
 are restrictions on the complexity of an expression, for which no
 comprehensive estimate can be given.














                                109
 ^pg;
                   10. Run Time Representation


   Item                                      Max. value

   Block level (1) .................................  9
   Prefix level (2) ................................ 63
   Number of parameters to procedure or class ...... 63
    (including parameters of prefixes)
   FOR statement nesting level ..................... 63
   Designational expressions in switch declaration   63
   Number of virtuals specified in class ........... 63
    (including virtuals in prefixes)
   Number of array subscripts ......................  9
   Number of identifiers declared in one list ...... 64
   Number of differently spelt identifiers ....... 1200
   Total number of blocks ......................... 350
    (including procedures, classes, pref.blocks)
   Redeclaration capacity ................... (dynamic)
   Number of working locations ................... 8000
   Number of quantities ..................... (dynamic)

   1)  Block level allocation is described in 10.1.
   2)  The prefix level of a class or prefixed block is the number
       of prefixes in its prefix chain.

 Various program constructions demand allocation of working
 locations.  The following table gives the maximum number of such
 locations generated, the actual number may be less.

   Construction                               Locations

   Class declaration ................................ 3
   ALGOL block ...................................... 2
   Prefix (forward reference) ....................... 1
   THEN ............................................. 1
   ELSE ............................................. 1
   label (forward reference) ........................ 1
   INSPECT .......................................... 2
   WHEN ............................................. 2
   FOR statement .................................... 2
   switch ........................................... 3
   prefixed block ................................... 3
   procedure ........................................ 3





















                                110
 ^pg;



 Appendix A:   EXAMPLES OF JOB SETUP


 This appendix contain several examples of (batch) job setups.


 A.1. Compilation with listing.


     @RUN,...
     @S*I.M,IS    SYMB,RELOC
     begin
     ...
     ...        (Simula source text)
     ...
     end;
     @FIN


 A.2. Compile without listing, link and execute.


     @RUN, ...
     @S*I.M,IV  SYMB,RELOC
     begin
     ...
     ...        (Simula source)
     ...
     end;
     @EOF
     ...
     ...        (data images)
     ...
     @FIN


 A.3. Compile and update, link and execute.


      @RUN,...
      @ASG,A          SF,...         assignment of symbolic
      @ASG,A          RF,...         and relocatable files
      @S*I.M,SUV      SF.SE,RF.RE    Update SF.SE in cycles

      -19,19
      -73,73-                        amendment cards
      /IMAGE/SYSIN.IMAGE/
      @EOF                           terminates source
      ...
      ...
      ...                            data cards
      @FIN










                                111
 ^pg;
                Appendix A: Examples of job setup


 A.4. Repeated Executions with Runtime Options.


      @RUN,...
      @S*I.M,IMV     TEST        "pretty-print"
      begin
      ...
      ...                        SIMULA source
      end;
      %RTSOPTION="UV";           options for 1st execution
      @EOF
      ...
      ...                        data for lst
      ...                        execution
      @EOF
      @XQT,UV      TPF$.TEST
      ...                        data for 2nd
      ...                        execution
      ...
      @EOF
      @XQT,S       TPF$.TEST
      ...
      ...                        data for 3rd
      ...                        execution
      @FIN


 Note that it is necessary to insert @EOF between the source text
 and the data for the first execution, since the compiler scans
 the input until an end-of-file condition arises. The first two
 executions are performed with (at most) 48K available data
 storage, while the third request the default value of 10K, but
 sends SYSOUT output to an alternate printfile.





























                                112
 ^pg;
                Appendix A: Examples of job setup


 A.5. Sample Program.


 In the following example all control images and SIMULA source
 images are shown.

 An input file is copied into a catalogued Fastrand file.  The
 images are listed simultaneously, each preceded by a line number.
 They are read and printed via SYSIN and SYSOUT respectively and
 the Fastrand file written by an instance of OUTFILE. To minimise
 data movement, SYSIN and the OUTFILE share the same image text.
 The data paths are shown diagramatically:


                       -----------     shared between
      SYSIN   ------> !   IMAGE   !    SYSIN and OUTFILE
                       -----------
                         !      !
                         !      !
                         !      !
                         !       ------>   OUTFILE
                         !
            ----------------------
           !      SYSOUT.IMAGE    !
            ----------------------
                         !
                          ------------>   SYSOUT


  @RUN,...
  @ASG,AX     NR*ARKIV//JIM
  @USE        CFILE., NR*ARKIV  .   internal file name
  @S*I.M,ISV    ELTLIST
  %RTSOPTION = "Z";
  BEGIN integer linenumber;
      ref(outfile) cfile;
      cfile :- new outfile("CFILE");
      cfile.open(sysin.image);

      inimage;
      while not endfile do begin
          linenumber := linenumber + 1;
          outint(linenumber,6);
          setpos(10);
          outtext(sysin.image);
          cfile.outimage;
          inimage;
      end while;

      cfile.CLOSE;
  END;
  @EOF                       terminates compiler input
  ...
  ...                        input data
  ...
  @EOF
  @FIN





                                113
 ^pg;



 Appendix B:   COMPILER DIAGNOSTICS


 This appendix contains the text of all diagnostic messages issued
 by the compiler proper. Some self-explaining messages may be
 given by the system, these are not mentioned here.

 If the situation, that gives raise to the message, is detected by
 the compiler pass 1 (source input and syntax analysis) the
 message will be preceded by a marker line pointing at the last
 character input to the compiler proper. This will in most cases
 mark the termination of the erroneous construction - sometimes it
 is, however, necessary to "scan ahead" (for instance when
 analysing comments after END) and in that case the marker may be
 placed after the point where the error is. The line pointed at
 will be printed even if the listing is turned off.  Problems
 found by the later passes will be diagnosed, but no source line
 is printed.

  The entries in the error message table conforms to the following
 lay-out:

  Message-number<level> <identifier>* <regdump>*
         "ERROR MESSAGE TEXT AS PRINTED".

         Possible comments if the message requires it

    <level>:

         Note     (0)   advisory message about suboptimal
                        programming etc, may be suppressed by
                        means of compiler n-option.

         Warning  (1)   an abnormal condition was detected but the
                        compiler recovered. The rb-element is not
                        marked in error.

         Error2   (2)   simple error - the compiler has probably
                        recovered succesfully, but the rb element
                        is marked in error.  In most cases the
                        erroneous construction is deleted.

         Error3   (3)   serious error - as (2) but execution of
                        the construction will cause run time
                        error. If not a-option the run is
                        terminated after compilation.

         Fatal    (4)   catastrophic error - the compilation
                        cannot be continued and is in most cases
                        terminated at once.

    <Identifier> (if included)

         nonames        no identifiers printed (used only with
                        regdump)
         onename        print one identifier after message
         twonames       print two identifiers after message
         threenames     print three identifiers after message

    regdump             dump registers after message.


                                114
 ^pg;
                 Appendix B:  Compiler diagnostics


    1    Error2.
         ILLEGAL NUMBER REPLACED BY ZERO

         A number does not conform to the Simula syntax.  E.g.
         3.   (Digit missing after the decimal point).


    2    Warning.
         ILLEGAL CHARACTER IGNORED

         The input stream contains a character which is misplaced
         or mistyped.


    3    Error3.
         CORRECTION LINE ERROR (SIR$)


    4    Error2.
         INCOMPATIBLE TYPES IN ASSIGNMENT

         The left-hand side type and the right-hand side type are
         incompatible.


    5    Warning.
         CONTROL CHARACTER REPLACED BY SPACE


    6    Error3.
         MISSING DELIMITER (SIMULA SYMBOL) OR SUPERFLUOUS OPERAND

         The sequence of incoming symbols is not defined in
         Simula.  This may be because of misspelling.


    7    Error3.
         WRONG DELIMITER - SIMULA SYMBOL MISSING OR MISPLACED

         The indicated statement or declaration is not correct.
         An illegal sequence of symbols is detected. This may be
         because of misspelling.


    8    Error3.
         ILLEGAL OPERAND

         A  user-defined symbol (variable, constant, etc) is used
         out of context.


    9    Error3.
         MISSING OPERAND

         A user-defined name or constant is missing.  There may be
         a misspelling.






                                115
 ^pg;
                 Appendix B:  Compiler diagnostics


    10   Error3.
         ILLEGAL CONSTRUCTION

         A declaration or a statement is illegally terminated or
         continued. Note that the error is probably at the
         beginning of that construction.


    11   Error2   onename.
         MISSING (OR INCORRECT) SPECIFICATION OF ...


    12   Fatal.
         COMPLICATED PROGRAM STRUCTURE OR TOO MANY PARAMETERS
         CAUSE STACK OVERFLOW

         The stack can accommodate up to 150 symbols at one time.
         If this number is exceeded, because of a deeply nested
         structure or many formal parameters in one list or a
         combination of both, this message is given. This error
         can also be caused by other errors.


    13   Error3   onename.
         MORE THAN ONE SUBSCRIPT TO SWITCH ...


    14   Error2   onename.
         GOTO NON-LABEL ...

         The expression after  GOTO  is not of type label.  This
         error may be caused by other errors.


    15   Error2   onename.
         DUPLICATE SPECIFICATION OF ...


    16   Error2   onename.
         FORMAL PARAMETER ILLEGALLY CALLED BY VALUE:  ...

         A parameter is illegally called by value, e.G. Procedure,
         ref, etc.


    17   Error2   onename.
         THIS IS NOT A FORMAL PARAMETER: ...

         The compiler found a specification for an identifier
         which did not appear in the parameter list.


    18   Warning.
         COMMENTS AFTER FINAL END ?

         The begin-end structure may be incomplete. This message
         is given when extra lines follow the final end.





                                116
 ^pg;
                 Appendix B:  Compiler diagnostics


    19   Error3.
         IMPROPER TERMINATION, INCOMPLETE PROGRAM STRUCTURE

         At source input end-of-file one or more constructions
         were not terminated. The compiler has inserted what was
         believed necessary.  This error may occur because the
         block structure was damaged by other errors, e.G. By an
         erroneous text quote.


    20   .   ******   Not used   ******


    21   Error2   twonames.
         PARAMETER QUALIFICATION CHECK FAILS: ...  ...


    22   Fatal.
         TOO MANY ERRORS

         When the number of Errors (level 2-4) diagnosed exceed a
         certain limit the compilation is aborted. The limit is
         default 50, but it may be changed by means of the
         directive MAXERRORS.


    23   Error3   onename.
         UNACCEPTED DECLARATION OR LABEL DEF. CHANGE ...

         A declaration was duplicated or conflicted with a
         specification.


    24   Error3   onename.
         NO DECLARATION OF ...


    25   Fatal.
         TOO MANY REDECLARATIONS, DIVIDE PROGRAM INTO SMALLER
         MODULES

         An identifier has been given a new meaning in an inner
         block.  The old meaning could not be saved due to lack of
         space.


    26   Fatal.
         THE COMPILER DID NOT RECOVER FROM PREVIOUS ERRORS


    27   Fatal.
         THE ERRORS FOUND ARE TOO SERIOUS TO PERMIT CONTINUED
         COMPILATION

         The compiler did not manage to recover from earlier
         errors. The programmer should correct all other errors
         and recompile the program.


    28   Error2.
         "=/" INTERPRETED AS "=/="

                                117
 ^pg;
                 Appendix B:  Compiler diagnostics


    29   Error3.
         SIMPLIFY THE EXPRESSION, OVERFLOW OF TEMPORARY RESULTS

         The object code makes use of the large number of
         accumulators for holding intermediate values or other
         entities instead of storing them in core. If all
         accumulators were in use the compiler gives this message.
         The programmer can easily avoid this error by using
         temporary variables.


    30   Fatal.
         THE COMPILER DID NOT RECOVER FROM OTHER ERRORS

         The recovery action taken did not succeed and the
         compiler data structures are inconsistent. Correct all
         other errors and re-run.


    31   Error3   onename.
         ILLEGAL OPERAND PRECEDES "(": ...

         The identifier preceding ( is not array, procedure,class
         or switch. This may be caused by a missing operator, or a
         missing declaration.


    32   Error3   onename.
         WRONG NUMBER OF SUBSCRIPTS TO ARRAY ...


    33   Error3   onename.
         IMPROPER TYPE IN EXPRESSION - ILLEGAL OPERAND: ...


    34   Error3   threenames.
         ILLEGAL KIND OF ACTUAL PARAMETER: ... ... ...


    35   Error3   threenames.
         ILLEGAL TYPE OF ACTUAL PARAMETER: ... ... ...


    36   Error3   onename.
         ILLEGAL ASSIGNMENT TO ...


    37   Fatal.
         CONSTANT TABLE OVERFLOW - USE FEWER CONSTANTS


    38   Error3   onename.
         WRONG NUMBER OF ACTUAL PARAMETERS TO ...


    39   Note.
         NON-INTEGER USED AS ARRAY BOUND

         A non-integer array bound is, if possible, converted
         (rounded) to integer.


                                118
 ^pg;
                 Appendix B:  Compiler diagnostics



    40   Warning.
         CONSTANT COMPARED WITH CONSTANT - MAY BE A TYPING ERROR

         The comparison of constants always gives the same boolean
         value. This may not be intended.


    41   Error2.
         NON-BOOLEAN EXPRESSION PRECEDES "THEN"


    42   Error2.
         IMPROPER TYPE IN RELATION


    43   Error3.
         INCOMPATIBLE TYPES - UNDEFINED TYPE CONVERSION

         The compiler detected an expression whose result would
         require conversion to a non-compatible type,  e.g.
         <integer>:= <boolean>  or <integer>:= <complex>.


    44   Fatal.
         OPERAND STACK OVERFLOW - SIMPLIFY THE CONSTRUCTION

         The program has so complicated constructions (e.g.
         expressions) that a table is exhausted. After simplifying
         these constructions the error should vanish.


    45   Error3.
         THE CONTROLLED VARIABLE MUST BE SIMPLE


    46   Note.
         ZERO STEP IN FOR-STATEMENT

         The step-value in a for-step-until construction is the
         constant zero. The for-variable will never be
         incremented.


    47   Error3.
         IMPROPER TYPE IN FOR LIST ELEMENT

         An expression in a for-statement is of a type which is
         incompatible with the type of the controlled variable.


    48   Error3.
         IMPROPER TYPE IN SUBSCRIPT EXPRESSION

         A subscript expression could not be converted to integer.


    49   Fatal.
         OPERATOR STACK OVERFLOW - SIMPLIFY THE CONSTRUCTION



                                119
 ^pg;
                 Appendix B:  Compiler diagnostics


         The program is too complex in structure, e.g. a very
         complicated expression. Simplify the program by using
         temporary variables.


    50   Error3   onename.
         QUALIFICATION PREVENTS LEGAL MATCH TO VIRTUAL: ...

         The qualification of a possibly matching quantity is not
         subordinate to the qualification of the virtual quantity
         or an earlier match.


    51   Warning  onename.
         NEVER EXECUTABLE WHEN-BRANCHE(S) IGNORED STARTING FROM:
         WHEN ...

         The qualification of the inspected expression is such
         that one particular when branch can always be executed.
         This means that succeeding when alternatives will never
         be executed.  It is possible that the programmer has
         written the when branches in the wrong order.


    52   Note.
         TEST FOR EQUALITY BETWEEN NON-INTEGERS MAY NOT BE
         MEANINGFUL

         Because of finite word length arithmetic, truncation may
         take place in non-integer computations. Non-integer
         values which should logically be identical but have been
         computed by different processes may have suffered
         different forms of truncation. Instead of testing for
         equality, it may be better to compare the magnitude of
         their difference with some small quantity.


    53   Error3.
         TOO MANY DIFFERENT IDENTIFIERS

         The dictionary has overflowed during the scan of the
         source text in pass 1. The size of the table allows for
         1500 user declared identifiers (not counting redefinition
         of standard identifiers). The compilation will almost
         certainly be of no value, but the syntactic analysis is
         carried through. The error may be circumvented by using
         the same identifier for different purposes in different
         blocks, or by segmenting the program into modules.


    54   Fatal.
         STACK OVERFLOW - PROGRAM TOO LARGE

         1. Too many nested blocks (procedures, classes, etc).
         2. Too much declaration code in one block (arrays or refs).
         3. Too many nested begin-ends or nested parentheses.
         4. Too many declarations in connection with one particular
            block.




                                120
 ^pg;
                 Appendix B:  Compiler diagnostics


    55   Fatal.
         EXEC/MACHINE ERROR IN I/O ON COMPILER WORK FILE


    56   Fatal.
         OVERFLOW IN COMPILER WORK FILE - PROGRAM TOO LARGE


    57   Error3.
         ILLEGAL CLASS/BLOCK PREFIX


    58   Error3   onename.
         ILLEGAL OBJECT REFERENCE "THIS" IN BLOCK PREFIX ...

         In the prefix chain of a prefixed block, there occurs an
         illegal reference to the prefixed block. The prefix may
         not be used for prefixing a block unless  THIS ---  is
         removed.


    59   Error3.
         MISSING RIGHT OR EXTRA LEFT PARENTHESIS


    60   Error3.
         MISSING LEFT OR EXTRA RIGHT PARENTHESIS


    61   Note     onename.
         MISSING DELIMITER, ACCEPTED BY U1100 SIMULA - ...



    62   Error3   twonames.
         QUALIFICATION CHECK FAILS - ... ...


    63   Error3   onename.
         UNKNOWN ATTRIBUTE: ...


    64   Error3.
         ILLEGAL EXPRESSION PRECEDES DOT


    65   Fatal    onename.
         CONFLICT IN CONNECTING ATTRIBUTES ...

         This error occurs because the compiler did not fully
         recover from earlier errors. The programmer should
         correct all other errors and re-run.


    66   Error2.
         OBJECTS THAT CONTAIN LOCAL CLASSES MAY NOT BE REFERENCED
         BY DOT NOTATION





                                121
 ^pg;
                 Appendix B:  Compiler diagnostics


    67   Error2.

         THIS FEATURE IS NOT IMPLEMENTED


    68   Error2   twonames.
         ILLEGAL EXTERNAL DECLARATION: ... ...


    69   Error3.
         ERROR IN EXTERNAL DECLARATION



    70   Fatal.
         INCORRECT PROGRAM START - SOURCE IS NOT PROGRAM

         Source output is not generated.


    71   Error3.
         MISSING OPERAND - POSSIBLY DUE TO OTHER ERROR(S)

         This is probably the result of other errors and the
         programmer should concentrate on correcting these first.


    72   Error2   onename.
         MISUSED IDENTIFIER ...

         This message is given when an identifier is misplaced,
         for instance if a simple variable is used as a statement.


    73   Error2.
         CONVERSION TO INTEGER CAUSES OVERFLOW

         The magnitude of an integer constant expression involving
         real constant operands is too large to be expressed as an
         integer


    74   Warning  onename.
         ARRAY BOUND EXPRESSION INVOLVES LOCAL IDENTIFIER ...


    75   Fatal    onename.
         WRONG NUMBER OF ACTUAL PARAMETERS TO STANDARD PROCEDURE
         ...


    76   Warning.
        THIS IS A PRECOMPILATION - SOURCE IS NOT PROGRAM

         BEGIN is not first Simula symbol of the source text (nb:
         External declarations do not count).


    77   Note     onename.
         INCONSISTENT USE OF DIMENSIONS TO ARRAY ...


                                122
 ^pg;
                 Appendix B:  Compiler diagnostics


    78   Error3   twonames.
         ILLEGAL ACTUAL PARAMETER TO STANDARD PROCEDURE ... ...


    79   Error3   twonames.
         PREFIX NOT AT SAME BLOCK LEVEL: ... ...

         This error may be caused by a faulty block structure due
         to previous errors.


    80   Error3   onename.
         UNKNOWN PREFIX ...

         This error can result from a faulty block structure due
         to previous errors.


    81   Error3   onename.
         PREFIX NOT CLASS: ...

         This error can result from a faulty block structure due
         to previous errors.


    82   Fatal.
         TABLE OVERFLOW - PROGRAM TOO LARGE

         E.g. more than 39 nested if-s or too many inspections.


    83   Error3   onename.
         PREFIX LOOP - A CLASS APPEARS IN ITS OWN PREFIX CHAIN ...

         Attempts by the compiler to recover from this error may
         cause the suppression of additional similar errors in
         this class hierarchy.


    84   Error2   onename.
         CONFLICTING VIRTUAL SPECIFICATION: ...


    85   Note.
         EXPONENTIATION INTEGER**INTEGER IS PERFORMED IN LONG REAL

         The expression i**j where i and j are both integer
         expressions is evaluated in double precision floating
         point arithmetic in order to preserve precision. If i**j
         is part of a longer expression, the rest of the
         expression is also computed in double precision. If i is
         replaced by a real variable the computation of the
         expression is faster but possibly at the expense of
         precision.


    86   Error3   twonames.
         UNKNOWN QUALIFIER ... ...

         The qualifier in a ref-declaration is not defined.


                                123
 ^pg;
                 Appendix B:  Compiler diagnostics



    87   Error3   onename.
         IDENTIFIER FOLLOWING "THIS" NOT CLASS OR USED OUT OF
         CONTEXT: ...


    88   Note     onename.
         NO MATCH IN THIS CLASS FOR VIRTUAL: ...


    89   Error2   onename.
         TYPE/KIND/QUAL CONFLICT WITH VISIBLE IDENTIFIER ...

         A quantity has been declared or specified whose
         identifier is identical to that of a virtual
         specification but whose type or kind or qualification is
         in conflict with that of the virtual specification.


    90   Error3.
         NON-CLASS IDENTIFIER FOLLOWS "IS" OR "IN"


    91   Error3.
         NON-REF EXPRESSION PRECEDES "IS" OR "IN"


    92   Note     onename.
         WHEN-BRANCH WILL NEVER BE EXECUTED: WHEN ...

         The qualification of the inspected expression is such
         that the when branch can never be executed. This arises
         when the class which qualifies the inspected expression
         and the class which is named after when are disjoint
         classes, i.E. They are not identical, and neither
         contains the other in its prefix chain.
          Example
               class a;;  a class b;;  a class c;;
               inspect new b when c do ....


    93   Warning.
         "X IS/IN C" WILL ALWAYS BE FALSE

         This situation arises when the qualification of the
         reference expression and the class named after IS/IN are
         classes which are not identical and neither contains the
         other in its prefix chain.


    94   Note.
         "X IN C" WILL ALWAYS BE TRUE EXCEPT FOR X == NONE

         This situation arises if the class which qualifies the
         reference expression is identical to, or a subclass of,
         the class named on the right-hand side of the
         in-relation.


    95   Warning.


                                124
 ^pg;
                 Appendix B:  Compiler diagnostics


         THIS STATEMENT IS REDUNDANT

         E.g. inspect none do ....


    96   Note.
        "QUA C" WILL IN THIS CASE BE EQUIVALENT TO A TEST FOR NONE

         This situation arises if the class which qualifies the
         reference expression before "qua" is identical to the
         class named after "qua". This use of "qua" is pointless
         and wastes time at runtime.


    97   Error2.
         NON-BOOLEAN EXPRESSION FOLLOWS "UNTIL"


    98   Error3.
         "NONE" IS WITHOUT ATTRIBUTES


    99   Error3.
         QUA AFTER NONE IS MEANINGLESS


    100  Error2.
         VALUE/NAME SPECIFICATION MISPLACED OR DUPLICATED

         An identifier occurred illegally in a value- or name-
         specification. The specification may have been given
         already.


    101  Error3.
         :- AND := OCCUR IN SAME STATEMENT

         This error may result from other errors.


    102  Error3   onename.
         :- APPLIED TO NON-REF OR NON-TEXT QUANTITY ...


    103  Error3   onename.
         ILLEGAL USE OF STANDARD PROCEDURE ...


    104  Warning  onename.
         INCONSISTENT NUMBER OF PARAMETERS TO PROCEDURE ...


    105  Error3   onename.
         INCORRECT USE OF ARRAY OR CLASS IDENTIFIER ...


    106  Error3   onename.
         INCORRECT USE OF ARRAY IDENTIFIER: ...




                                125
 ^pg;
                 Appendix B:  Compiler diagnostics


    107  Error3   onename.
         INCORRECT USE OF CLASS IDENTIFIER ...


    108  Error2.
         ILLEGAL OR REDUNDANT STAND-ALONE EXPRESSION, POSSIBLY DUE
         TO OTHER ERROR(S)

         This may be caused by a stand-alone expression used as a
         statement e.G.  9; Or x+y; . It may also result from a
         call on certain standard functions with constant
         parameters and not using the results, e.G.   ; Char(6);
         such a call has no purpose. This error may also result
         from previous errors.


    109  Error3   onename.
         ERRONEOUS ASSIGNMENT TO PROCEDURE IDENTIFIER ...


    110  Error3.
         NON-REF QUANTITY FOLLOWS "INSPECT"


    111  Error3   onename.
         ILLEGAL REFERENCE ASSIGNMENT TO ...

         This error may be caused by other errors.


    112  Error3   onename.
         ILLEGAL TEXT REFERENCE ASSIGNMENT TO ...


    113  Error3   onename.
         ILLEGAL REFERENCE RELATION: ...


    114  Warning.
         SIMPLE STRINGS MUST TERMINATE AT END OF LINE, " INSERTED


    115  Error2.
         MISSING COMMA AFTER REAL PART OF COMPLEX CONSTANT
         INSERTED


    116  Error2.
         INCORRECTLY TERMINATED COMPLEX CONSTANT, ">" INSERTED

         A complex constant must have the form:
             <  Real-part , imaginary-part  >    .


    117  Fatal.
         TOO MANY FORWARD REFERENCES - SIMPLIFY OR REARRANGE
         PROGRAM

         This can occur if there are too many goto statements,
         conditional statements/expressions, for statements,


                                126
 ^pg;
                 Appendix B:  Compiler diagnostics


         blocks, procedures or classes.  The program is really too
         large for the system. The use of external procedures may
         reduce the program to components of manageable
         dimensions.


    118  Note.
         DIFFERENT TYPES ON LEFT-HAND SIDE OF ASSIGNMENT: TIME
         CONSUMING CODE

         In multiple assignments, the value is transmitted from
         right to left. Type conversions occur whenever successive
         pairs of left-part variables have different types. There
         may thus be unnecessary but time consuming type
         conversions involved and possibly unexpected rounding.
         E.G. R2:= I:= R1:= 3.2; If r2, i and r1 are of types
         real, integer and real respectively, their values after
         the assignment are 3.0, 3, 3.2. It may be preferable to
         re-order or split up the multiple assignment.


    119  Error3   onename.
         INCORRECT USE OF PROCEDURE IDENTIFIER ...


    120  Warning.
         NON-SIMULA CONSTRUCTION - THE PROGRAM IS  N O T  PORTABLE

         U1100 Simula contains some features which are relaxations
         of common base restrictions or language extensions. These
         are flagged by this message. Note that future levels of
         the u1100 Simula system will conform strictly to the
         Simula definition, thus such constructions should be
         avoided.


    121  Error3.
         ILLEGAL KIND IN EXPRESSION - ILLEGAL OPERAND


    122  Note.
         STEP-EXPRESSION MAY CAUSE REPEATED EXECUTION OF REDUNDANT
         CODE

         If the step expression is not a constant or simple
         variable of the same type as the controlled variable,
         re-evaluation and/or type conversion take place at each
         cycle. These additional operations can be unnecessarily
         time consuming.  This is true also if the step expression
         is a parameter called by name or a virtual. It may be
         advisable to replace the step expression by a temporary
         variable which is initialised before executing the for
         statement.


    123  Note.
         UNTIL-EXPRESSION MAY CAUSE REPEATED EXECUTION OF
         REDUNDANT CODE

         If the until expression is not a constant or simple


                                127
 ^pg;
                 Appendix B:  Compiler diagnostics


         variable of the same type as the controlled variable,
         re-evaluation and/or type conversion take place at each
         cycle. These additional operations can be unnecessarily
         time consuming.  This is true also if the until
         expression is a parameter called by name or a virtual. It
         may be advisable to replace the until expression by a
         temporary variable which is initialised before executing
         the for statement.


    124  Error3   onename.
         ILLEGAL USE OF SYSTEM CLASS ...


    125  Error3.
         MISSING ELSE IN IF-EXPRESSION


    126  Warning.
         THIS FEATURE IS NOT FULLY IMPLEMENTED


    127  Note.
         "REACTIVATE" USED INSTEAD OF "CANCEL"

         E.g. (re)activate x after none.


    128  Error2.
         QUALIFICATION IS WRONG


    129  Error3.
         "PRIOR" IS MISPLACED

         The (re)activation statement is incorrectly formulated.


    130  Error2.
         TEXT VALUE IS MISUSED


    131  Error2.
         ILLEGAL EXPRESSION INVOLVING EXPONENTIATION


    132  Note     onename.
         IMPLICIT "QUA", RUN TIME CHECK ON ...

         The compiler could not check the validity of
         qualification, therefore a runtime qualification check is
         generated.


    133  Error3.
         NON-CLASS IDENTIFIER FOLLOWS NEW OR WHEN OR PRECEDES
         BEGIN





                                128
 ^pg;
                 Appendix B:  Compiler diagnostics


    134  Fatal    nonames     regdump.

         COMPILER ERROR (PLEASE REPORT TO NCC)  ......

         This message should never occur. If it does it indicates
         a problem within the compiler, which should be corrected.
         An error report should be submitted to your installation.


    135  Error2.
         QUANTITY PRECEDING == OR =/= IS NEITHER REF NOR TEXT


    136  Error2.
         NON-REF EXPRESSION PRECEDES "QUA"


    137  Error2.
         NON-CLASS IDENTIFIER FOLLOWS "QUA"


    138  Fatal.
         MAX PAGES


    139  Error2   onename.
         MORE THAN 12 CHARS IN EXEC-NAME - TRUNCATED AT THE RIGHT:
         ...


    140  Error3.
         "(RE)ACTIVATE" USED IN BLOCK/CLASS NOT PREFIXED BY
         "SIMULATION"

         An activation statement appears at a point which is not
         inside a prefixed block or class prefixed by class
         SIMULATION.


    141  Fatal.
         SOURCE TEXT ABSENT

         The compiler detected a control card without having
         received any source input.


    142  Note     onename.
         MATCH QUALIFIER IS SUBCLASS OF VIRTUAL QUALIFIER ...


    143  Note     onename.
         EXTERNAL REF PROCEDURE MAY CAUSE QUALIFICATION TROUBLE
         ...


    144  Note     onename.
         QUALIFICATION UNCHECKED FOR EXTERNAL REF PROCEDURE ...





                                129
 ^pg;
                 Appendix B:  Compiler diagnostics


    145  Fatal.
         BLOCKSTRUCTURE TOO BIG - TOO MANY BLOCKS, PROCEDURES,
         CLASSES OR INSPECTIONS

         Simplification of the program structure or the use of
         external procedures is necessary.


    146  Error3.
         "INNER" MUST BE IN SPLIT BODY AFTER INITIAL OPERATIONS

         The initial operations must be fully terminated before
         INNER. Therefore INNER can not stand within e.G. A
         compound statement.


    147  Warning.
         THIS NON-SIMULA FEATURE WILL BE WITHDRAWN - PLEASE CHANGE
         IT ...


    148  Fatal.
         TOO MANY CONSTANTS IN STATEMENT - SPLIT UP STATEMENT


    149  Fatal.
         TEXT CONSTANT CAUSES TABLE OVERFLOW - SPLIT UP TEXT
         CONSTANT


    150  Error3.
         ILLEGAL SWITCH ELEMENT


    151  Fatal.
         MORE THAN 63 NESTED FOR-STATEMENTS

         This error can be avoided by changing one of the
         for-statement bodies into a block by providing a dummy
         declaration.


    152  Fatal.
         TOO MANY FOR-STATEMENTS


    153  Fatal.
         MORE THAN 63 PARAMETERS


    154  Fatal.
         MORE THAN 63 VIRTUALS


    155  Warning.
         COMPILER OPTION CHANGED


    156  Error2   nonames   regdump.
         OUTPUT ERROR (SDFO$) TO SIMULA$MAP.  V/R OPTIONS DELETED,
         STATUS IN A5:  ......

                                130
 ^pg;
                 Appendix B:  Compiler diagnostics


    157  Error3.

         TOO MANY SWITCH ELEMENTS


    158  Fatal.
         EXEC ERROR RETURN FROM POSTPR

         This is a machine/exec error.


    159  Fatal    nonames   regdump.
         DYNAMIC WORKING FILE ASSIGNMENT VIA CSF$ FAILED - STATUS
         IN A0

         The compiler has been unable to allocate work files for
         its own use. This may be because the user has already
         assigned files called sy$$ or s$$$ or because the
         installation has no spare fastrand storage available.
         Failure for any other reason is almost certainly a
         machine/exec error. The status from csf$ for the work
         file assignment lies in a0 which can be inspected in the
         register dump which accompanies this error.


    160  Fatal.
         EXEC ERROR RETURN FROM SOR

         This is a machine/exec error.


    161  Fatal.
         EXEC ERROR RETURN FROM SIR

         This is a machine/exec error.


    162  Error2   nonames   regdump.
         WORK FILE "SIMULA$MAP" COULD NOT BE ASSIGNED. V AND/OR R
         OPTION DELETED, STATUS IN A0:  ......


    163  Error3.
         UNDEFINED EXPONENTIATION FUNCTION


    164  Note.
         SUBSCRIPT EXPRESSION IS NOT INTEGER

         The expression is rounded to an integer value, if
         possible.


    165  Error2.
         NON-BOOLEAN EXPRESSION FOLLOWS "WHILE"






                                131
 ^pg;
                 Appendix B:  Compiler diagnostics


    166  Note     onename.
         "QUA" MAY GENERATE SUPERFLUOUS CODE ...

         This situation arises if the class which qualifies the
         reference expression before qua is a subclass of the
         class named after qua. Unless qua is being used to
         restrict attribute access, the construction may have
         little purpose. The result may, however, be the execution
         of extra operations at runtime.


    167  Error2.
         ILLEGAL IF-EXPRESSION


    168  Note     onename.
         THIS STATEMENT WILL NEVER BE EXECUTED: WHEN ...

         The sequence of when-branches contains two branches where
         the second class identifier is a subclass of the first
         one, so that the second branch will never be executed.


    169  Fatal.
         EXEC ERROR

         This is a machine/exec error.


    170  Fatal.
         EXEC INTERRUPT (SEE EXEC UP4144, VOL. 2)

         The compiler was interrupted by the exec/machine. An
         abbreviation for the contingency type etc is printed in
         the standard format.  The error may be caused by lack of
         space in the rb element.


    171  Fatal .
         MAX TIME


    172  Error3.
         MORE THAN 500 EXTERNAL DEFINITIONS IN SEPARATE
         COMPILATION


    173  Error3.
         UNDEFINED OPERATION: KIND,TYPE OR VALUE OF OPERAND(S)
         DO(ES) NOT ALLOW THIS OPERATOR


    174  Error2.
         "FTN" REPLACED BY "FORTRAN" USE "FORTRANMODE(1)" TO CALL
         ASCII FORTRAN SUBROUTINES



    175  Error3.
         STEP-UNTIL-PHRASE IS ONLY DEFINED FOR INTEGER OR (LONG)
         REAL


                                132
 ^pg;
                 Appendix B:  Compiler diagnostics


    176  Error3.
         TOO MANY BLOCK LEVELS

         The block levels are closely connected to the index
         registers, which are used to hold the display vector.
         Only x2 - x10 are used, thus the number of levels is
         restricted to 9.


    177  Note     onename.
         LABEL REDEFINES ...

         The label definition may be undesired or the result of a
         typing error. This will change the interpretation of the
         occurrencies of this identifier elsewhere in the program
         and even result in errors.  E.G. Outimage: .


    178  Note     onename.
         INVISIBLE QUALIFIER - COMPILER SOLUTION MAY NOT BE
         CORRECT: ...

         The compiler scans a special class-stack, not the
         dictionary, to find the qualification during processing
         of declarations/specifications.  It checks,however, later
         on, whether the obtained class is visible.


    179  Note.
         COPY INSERTED - THE PROGRAM MAY NOT BE PORTABLE

         A text value could not be used, so the compiler changed
         it into a text expression by introducing a call on copy.


    180  .   ******   Not used   ****** .


    181  Warning.
         ETERNAL LOOP: DO-STATEMENT WITHOUT "UNTIL"


    182  Warning.
         ILLEGAL COMPILER DIRECTIVE OR MISPLACED % - SKIPPED

         The percent character has been recognised in a position
         after the first - or the directive is not correct.


    183  Note.
         CALL BY NAME GENERATES RUNTIME CHECK ON ACTUAL
         QUALIFICATION


    184  Error2.
         MORE THAN ONE "INNER" IN CLASS BODY


    185  Error3.
         THE QUALIFIER IS NOT CLASS


                                133
 ^pg;
                 Appendix B:  Compiler diagnostics


    186  Note     onename.

         TYPE/QUALIFICATION OF MATCHING QUANTITY IN COMPATIBLE
         WITH OUTER MATCH ...

         Although the matchtype is compatible with the type of the
         virtual specification, it is not compatible with an
         earlier match. This may cause no trouble at runtime, but
         it often does.
          Example
          class a; virtual: Procedure p; ...
          A class b;
          begin real r; real procedure p; ...
                R:=P; comment this is illegal for c-objects;
          end *b* ;
          b class c;
          begin complex procedure p; ...


    187  Note.
         "DETACH" IN TYPE PROCEDURE MAY BE UNINTENDED

         The <type> procedure result may be used in array bounds,
         so that this array is not generated. Later attempt to
         access this array will result in runtime error.


    188  Error3.
         ILLEGAL SPECIFICATION OF CLASS PARAMETER

         Procedure, switch, or label may not be parameter to
         class.


    189  Error3   onename.
         ELEMENT NOT FOUND (EXT. DECL.) ...

         The class (procedure) may be in another file - or it is
         not compiled yet.

    190  Fatal.
         STACK OVERFLOW - TOO MANY VIRTUAL SPECIFICATIONS


    191  Fatal    onename.
         THE PREFIX STRUCTURE IS INCONSISTENT - RECOMPILE CLASS
         ...


    192  Error3.
         FILE ERROR DURING INPUT OF PRECOMPILED CLASS OR PROCEDURE


    193  Error3.
         FILE ERROR DURING OUTPUT OF PRECOMPILED CLASS OR
         PROCEDURE


    194  Error3.
         INCOMPATIBLE LAYOUT OF PRECOMPILED CLASS OR PROCEDURE


                                134
 ^pg;
                 Appendix B:  Compiler diagnostics


    195  Fatal.
         TOO MANY NEW IDENTIFIERS INTRODUCED VIA "EXTERNAL"
         DECLARATIONS

         The compiler use a table to hold the identifiers
         implicitly introduced by external declarations (attribute
         id.). This table has overflowed, the number of different
         identifiers introduced in this manner should be reduced.


    196  Note.
         REDEFINITION MAY REQUIRE RECOMPILATION OF DEPENDENT
         MODULES


    197  Fatal.
         COMPILATION ABORTED


    198  Error3.
         TOO MANY GLOBALY DECLARED CLASSES AND PROCEDURES


    199  Error3.
         IDENTIFIER TABLE OVERFLOW





































                                135
 ^pg;



 Appendix C:   RUN TIME SYSTEM MESSAGES


 The following messages (hopefully self-explaining) may be
 issued by the run time system:


    0    SIMULA SYSTEM ERROR - PLEASE REPORT TO SYSTEM SUPERVISOR
    1    EXECUTIVE INTERRUPT
    2    SEQUENCING DEADLOCK
    3    CALL: OBJECT IS RESUMED
    4    DETACH: OBJECT IS ATTACHED, BUT NOT OPERATING
    5    DETACH: OBJECT IS DETACHED
    6    RESUME: OBJECT IS NOT LOCAL TO A SYSTEM HEAD
    7
    8
    9
    10
    11   THIS FEATURE IS NOT IMPLEMENTED
    12   STORAGE REQUEST CANNOT BE MET
    13   PARAMETER TO BLANKS OUT OF RANGE (NEGATIVE OR TOO LARGE)
    14   RHS LONGER THAN LHS IN TEXT VALUE ASSIGNMENT (LHS POSSIBLY NOTEXT)
    15   ARRAY DECLARATION HAS TOO MANY DIMENSIONS
    16   ARRAY UPPER BOUND LESS THAN LOWER BOUND
    17   ARRAY SUBSCRIPT OUT OF RANGE
    18   MORE=FALSE IN TEXT GET OPERATION
    19   MORE=FALSE IN TEXT PUT OPERATION
    20   SUBTEXT LONGER THAN CONTAINING TEXT
    21   SUBTEXT HAS NEGATIVE LENGTH
    22   SUBTEXT START POSITION OUTSIDE CONTAINING TEXT
    23   ININT,INREAL OR INFRAC (OR GETINT, ETC.) FOUND NO NUMERIC ITEM
    24   ITEM FOUND BY ININT,INREAL OR INFRAC (OR GETINT, ETC.)
         OUT OF RANGE
    25   SOURCE LANGUAGE ERROR - SEE COMPILATION DIAGNOSTIC
    26   T.PUTNUMBER(  ):    T==NOTEXT
    27   OUTREAL(R,N)/OUTFIX(R,N) OR PUTREAL/PUTFIX : NEGATIVE N
    28   TYPE CONVERSION UNDEFINED
    29   ARGUMENT FOR CONVERSION TO INTEGER OR ENTIER OUT OF RANGE
    30   DETACH: OBJECT IS TERMINATED
    31   RESUME: PARAMETER IS NONE
    32   RESUME: OBJECT IS TERMINATED
    33   RESUME: OBJECT IS ATTACHED
    34   CALL: PARAMETER IS NONE
    35   CALL: OBJECT IS TERMINATED
    36   CALL: OBJECT IS ATTACHED
    37   ILLEGAL GO TO STATEMENT
    38   LESS THAN 5 % OF TOTAL STORAGE AVAILABLE AFTER GARBAGE
         COLLECTION
    39   IRRECOVERABLE SYSOUT FILE NAME CLASH
    40   OUTIMAGE/OUTITEM: FILE IS CLOSED OR IMAGE == NOTEXT
    41   OUTTEXT/OUTITEM:   TEXT/ITEM IS LONGER THAN IMAGE
    42   RANDINT(A,B,U) OR UNIFORM(A,B,U) :   B IS LESS THAN A
    43   ILLEGAL PARAMETER TO SPACING OR LINES PER PAGE
    44   ILLEGAL PARAMETER TO EJECT
    45   INIMAGE/INITEM:  FILE IS CLOSED OR IMAGE == NOTEXT
    46   ATTEMPT TO READ THROUGH END OF FILE -
         CHECK FOR MISPLACED ENDFILE TEST


                                136
 ^pg;
                  Appendix C:  Run Time Messages


    47   NEGEXP(A,U) :   A IS NEGATIVE OR ZERO
    48   FORCED RUNTIME ERROR - DIAGNOSTICS SPECIFIED BY USER
    49   FILE NAME IS NOTEXT OR TOO LONG
    50   PARAMETER TO CHAR NEGATIVE OR >511
    51   DEVICE ERROR IN FILE HANDLING
    52   INIMAGE/OUTIMAGE:  INTERNAL IMAGE TOO LONG
    53   CSF IMAGE DOES NOT START WITH MASTERSPACE
         OR IS LONGER THAN 240 CHARS
    54   COM IMAGE IS LONGER THAN 50 CHARACTERS
    55   UNACCEPTABLE CHARACTER PARAMETER TO LOWTEN
    56   ILLEGAL PARAMETER TO CLOSE, I.E. NOT REWIND,FREE OR WAIT
    57   EXTERNAL FILE FORMAT IS INCOMPATIBLE WITH CLASS INFILE
    58   ATTEMPT TO ACCESS ATTRIBUTE OF NON-EXISTENT
         CLASS OBJECT (NONE.---)
    59
    60   OPEN:   FILE ALREADY OPEN
    61
    62   FORMAL PARAMETER OF WRONG KIND
    63   ATTEMPT TO STORE INTO A CONSTANT OR EXPRESSION
    64   QUALIFICATION CHECK FAILS
    65   ATTEMPT TO ACCESS ATTRIBUTE OF TEXT VALUE
    66   INCORRECT NUMBER OF PARAMETERS TO FORMAL/VIRTUAL PROCEDURE
    67   FORMAL ARRAY HAS WRONG TYPE
    68   INVALID PARAMETER TO STANDARD FUNCTION.
    69   VIRTUAL QUANTITY NOT MATCHED
    70   SQS EMPTY ON TERMINATION OF PROCESS
    71   EVTIME:   PROCESS IS IDLE
    72   CANCEL,PASSIVATE OR WAIT EMPTIES SQS
    73   REACTIVATE EMPTIES SQS
    74   PARAMETER TO ACTIVATE/REACTIVATE/CANCEL IS NOT IN CLASS PROCESS
    75   PARAMETER TO WAIT OR INTO IS NOT IN CLASS HEAD
    76   RESULT OF EXPONENTIATION IS UNDEFINED
    77   NORMAL(A,B,U) OR POISSON(A,U):    U IS ZERO
    78   PHYSICAL FILE NOT ASSIGNED
    79   ILLEGAL EQUIPMENT TYPE FOR PHYSICAL FILE
    80   DIRECTFILE.OPEN(NOTEXT) :  NO IMAGE LENGTH INDICATED
    81   ATTEMPT TO WRITE OUTSIDE FILE LIMITS
    82   DIRECTFILE:    ATTEMPT TO READ NON-EXISTENT EXTERNAL IMAGE
    83   LOCATE:    DIRECTFILE IS CLOSED
    84   TYPE OF ACTUAL PARAMETER IS INCOMPATIBLE WITH
         THAT OF FORMAL PARAMETER
    85   INIMAGE:    EXTERNAL IMAGE IS LONGER THAN INTERNAL IMAGE
    86   POISSON(A,U):    A IS NEGATIVE
    87   PSNORM(A,B,C,U):    ILLEGAL VALUE OF C
    88   DISCRETE(A,U):    A IS NOT 1-DIMENSIONAL
    89   HISTD(A,U):    A IS NOT 1-DIMENSIONAL
    90   HISTD(A,U):    AN ELEMENT OF A IS NEGATIVE
    91   HISTO(A,B,C,D):    A AND/OR B IS NOT 1-DIMENSIONAL
    92   HISTO(A,B,C,D):    A IS NOT LONGER THAN B
    93   ERLANG(LAMDA,K,U):    LAMBDA AND/OR K IS NOT GREATER THAN ZERO
    94   LINEAR(A,B,U):    A AND/OR B IS NOT 1-DIMENSIONAL
    95   LINEAR(A,B,U):    A DOES NOT CONTAIN ZERO AND/OR ONE
    96   SEPARATE RUNTIME MODULES ARE INCOMPATIBLE,
         WRONG ORDER OF SEPARATE COMPILATIONS
    97
    98   LOCATE(N):   N IS NOT GREATER THAN ZERO


                                137
 ^pg;
                  Appendix C:  Run Time Messages


    99   ILLEGAL USE OF NAME PARAMETER (TYPE-CONFLICT)
    100
    101  USER-DEFINED FILE(S) LEFT OPEN AT PROGRAM TERMINATION
    102  ERROR RETURN FROM EXEC 8 ROUTINE
    103  INVALID PARAMETER TO EXTERNAL LIBRARY/ASSEMBLY PROCEDURE
    104  NEGATIVE FIELD WIDTH IN OUTPUT OPERATION
    105  NEGEXP(A,U) OR ERLANG(A,B,U):    U IS ZERO
    106  SCHEDULED PROCESS IS TERMINATED,
         CHECK FOR NON-RECOMMENDED USE OF RESUME OR CALL
    107  LINEAR(A,B,U):    A AND B HAVE UNEQUAL LENGTH




















































                                138
 ^pg;



 Appendix D:   PROGRAMMING HINTS


 The appendix contains some disconnected tips which may be useful
 in reducing the size or improving the runtime efficiency of the
 object program. These should not be regarded as hard and fast
 rules. Where they conflict with good program structuring
 principles, common sense and compromise must prevail. The tips
 should be adopted where it is obviously expedient but the
 programmer should never be tempted to "twist" his program to
 incorporate a good tip unless he is certain that there really are
 benefits to be reaped.

 Those who undertake retrospective program optimisations should
 bear in mind that, in most cases, only repetitive processes are
 worth the effort.

 The greatest savings of all are probably afforded by carefully
 selecting the best approach to the problem and investing
 considerable effort in designing the program.

 The following hints are not ranked in order of importance.

 1)   Avoid the following as STEP and UNTIL elements in FOR
      statements:
       -  Procedure calls.
       -  Expressions which are not constants or simple variables.
       -  Parameters called by name.
       -  Subscripted variables.
       -  Variables of different type from the controlled
          variable.

 3)   Use WHILE statements if the generality of the FOR statement
      is not exploited.

 4)   Avoid unnecessary type conversions by declaring quantities
      with types consistent with their usage. Avoid arithmetic
      expressions involving operands of different types.

 5)   Do not transmit parameters by name if reference or value can
      be used instead.

 6)   Minimise the occurrence of parameters called by name if the
      re-evaluation effect of the textual replacement rule is not
      necessary.  Rather assign the parameter once to a simple
      variable and use this instead.

 7)   Do not redefine standard procedures simply because their
      names may be unsuitable. As an extreme instance, a call on
      the procedure

           REAL PROCEDURE MAGNITUDE (X); REAL X;
                          MAGNITUDE := ABS(X);

      takes about 65 times as long to execute as a direct call on
      ABS.






                                139
 ^pg;
                  Appendix D: Programming Hints


 8)   Choose the qualifications of REF variables carefully in
      order to minimise the use of QUA or implicit QUA (indicated
      by compiler messages).

  9)  Avoid creating unnecessary blocks. If a new temporary
      variable is required, declare it in an existing block in
      preference to converting a compound statement into a block.

 10)  Do not declare more variables than are really required.

 11)  Avoid the use of repeated expressions whose values do not
      change. The compiler does not optimise this situation. Thus,
                C(I+J-1):= A(I+J-1) + B(I+J-1)
       is better expressed as:
                K   := I+J-1;
                C(K):= A(K)+B(K)

 12)  When relevant, space can be saved if SIMSET or SIMULATION
      are used to prefix only the outermost block of the program
      and if the file classes are used for prefixing in only the
      outermost block.

 13)  Use EJECT and SPACING to achieve line spacing in PRINTFILE.
      This is faster than outputting blank lines.

 14)  Garbage collection time is reduced if care is taken to avoid
      maintaining references to space-consuming data structures
      which are no longer required. If temporary array storage
      required, it may be expedient to begin a new block within
      which the array is declared locally and which ends when the
      array is no longer required. In this way the space occupied
      by the "extinct" array is eventually released by garbage
      collection.

 15)  Use BOOLEAN expressions! The last example below is faster,
      uses less storage and is more readable:
       Do not use  ZERO := IF A = 0 THEN TRUE ELSE FALSE;
          or       IF A=0 THEN ZERO:=TRUE ELSE ZERO:=FALSE;
       - instead   ZERO := A=0;

 16)  Time and/or space may be saved by accessing remote
      attributes via INSPECTION blocks instead of dot notation. If
      more than 3 remote accesses are made to attributes of the
      same object, space is saved by using an inspection block.
      Execution time is generally saved by using inspection blocks
      if at least 12 remote attributes are accessed.  See also
      chapter 10 for the consequences of inspection blocks in
      relation to the allocation of block levels.

 17)  A 10-15% save in the generated code may be obtained by
      excluding the line number information from the code by means
      of compiler option Z.










                                140
 ^pg;



 Appendix E:   ERROR REPORTING (NB: no maintenance available)


 When an abnormal condition is discovered, either in the compiler
 or in the run time system, the error should be reported through
 the person at your installation who is responsible for the Simula
 system. It will however ease the maintenance situation
 considerably if a few simple rules are obeyed, so that the
 problem can be solved as quickly as possible.

 Try to isolate the error. In most cases it is possible to
 pinpoint the problem rather accurately, and such work is best
 done by the originator of the troublesome program.

 If the error is in the compiler (or in the generated MAP), the
 program should be compiled using the maintenance option 'C'; this
 will result in register dumps being produced for every message
 from the compiler together with an exact indication of the
 location and the pass where the error occurs.

 If the error occurs during execution of a Simula program,try to
 execute the program with the relevant trace options (see chapter
 2), before submitting the report.

 If you do not succeed in provoking the error in a short program,
 please submit the program together with the data in a complete
 job setup on tape; the tape will be returned to you when the
 error has been corrected. In all cases please submit a complete
 listing also including information about the level of EXEC, a
 listed MAP etc., quite a few errors are due to (sometimes
 erroneous) updates of the standard Univac software.

 Remember to keep the program, that caused the problem; it may be
 used in order to check whether the error has disappeared when you
 get a new release installed.

 Please report whether you found a way to avoid the error, e.g.
 "problem solved by using more core during execution". This may
 give valuable hints to the trouble shooters.

 Fill out the error report form, it should be available from your
 installation; the last page of this manual may also be used as an
 error report form master.

 Adherance to these rules will mean that we at the NCC will be
 able to provide a better maintenance support, to the advantage of
 all of us.  Thank You!


 E.1.   The PASS compiler directive.


 This directive is used for compiler maintenance only. It is
 enabled by the compiler C option. The use of this option will
 normally be of no interest to the programmer. It may be used to
 trace the workings of the compiler, and will often produce a lot
 of listing output!

 The directive takes the general form



                                141
 ^pg;
                   Appendix E:  Error reporting.


   %PASS <pass number> <trace setting>, <trace setting> ...

 <Pass number> is a digit between 1 and 7 incl., and the trace
 switches are IO, SMALL, BIG and SPEC which may be set ON or OFF
 in the standard manner. Only the IO trace (pass output) is
 implemented for all passes. Be warned again that especially the
 BIG and SPECial dumps may produce voluminous output.























































                                142
 ^pg;
                        Error Report Master


          (NO MAINTENANCE AVAILABLE - NOT APPLICABLE)
    ------------------------------------------------------
    SIMULA Error Report - when completed, send to:

          Norwegian Computing Center
          att. Univac Simula Group
          Postboks 335 Blindern
          N-Oslo 3, Norway.

    ------------------------------------------------------
    Name of customer:              Release no:


    ......................................................
    Installation:                  Date:


    ......................................................
    Project leader:                Originators ref:


    ------------------------------------------------------
    Description of problem:
    ======================










    ------------------------------------------------------
    Enclosures: (e.g. tape or listing)


    ======================================================
        For NCC use (will be returned to the submitter)
    ......................................................
    Problem analysis and description of actions taken:




















                                143
 ^pg;

 ^pg;


                         Table of contents


 Introduction                                                    3

 References                                                      4

 1.   The SIMULA Compiler.                                       5
     1.1.   Compiler options at a glance.                        6
     1.2.   Compiler parameters.                                 6
     1.3.   Compiler directives.                                 7
     1.3.1.   %CHECKS.                                           8
     1.3.2.   %CODE.                                             8
     1.3.3.   %COMPLEX.                                          8
     1.3.4.   %INDENT.                                           8
     1.3.5.   %LINENUMBERS.                                      8
     1.3.6.   %LIST.                                             8
     1.3.7.   %MAXERRORS.                                        9
     1.3.8.   %NATIONAL.                                         9
     1.3.9.   %NOCODE.                                           9
     1.3.10.  %NOLIST.                                           9
     1.3.11.  %NOSOURCE.                                         9
     1.3.12.  %OCTAL.                                            9
     1.3.13.  %PAGE.                                            10
     1.3.14.  %PASS.                                            10
     1.3.15.  %RTSOPTIONS.                                      10
     1.3.16.  %SOURCE.                                          10
     1.3.17.  %TITLE.                                           10
     1.3.18.  %XQTOPTIONS.                                      11
     1.4.   Source listing (S  and M option).                   11
     1.4.1.   S option.                                         11
     1.4.2.   M option.                                         12
     1.5.   Object program listing (L option).                  12
     1.6.   Link and go (V and R options).                      12
     1.6.1.   Contents of SIMULA$MAP.                           14
     1.6.2.   Adding SIMULA$MAP.                                15
     1.6.3.   Entry points in object modules.                   15
     1.6.4.   RB element inclusion.                             15
     1.6.5.   Repeated executions.                              16
     1.6.6.   Options for the compiled program.                 16
     1.7.   Processors in Simula (D option).                    16
     1.8.   Separate compilation.                               17
     1.8.1.   The external declaration.                         17
     1.8.2.   Separate compilation of classes.                  18
     1.8.3.   Restrictions on labels.                           19
     1.8.4.   Separately compiled procedures.                   19
     1.8.5.   Notes on separate compilation.                    19
     1.9.   Messages from the compiler.                         20
     1.10.  Hardware Representation.                            20
     1.10.1.  Identifiers and Keywords.                         20
     1.10.2.  Text and character constants.                     21
     1.10.3.  Numeric constants.                                22
     1.10.4.  Special symbols.                                  23
     1.10.5.  Predefined Identifiers.                           24
     1.10.6.  Comment conventions.                              25

 2.   The Run Time System.                                      26
     2.1.   Collection of Simula programs.                      26
     2.2.   Execution of the object program.                    27
     2.3.   Options.                                            27


                                145
 ^pg;



                         Table of contents

     2.4.   Separate SYSOUT files (option S).                   29
     2.5.   Program tracing.                                    29
     2.6.   Storage allocation.                                 30

 3.   Error Messages and Diagnostics.                           32
     3.1.   Messages from the compiler.                         32
     3.2.   Messages from the Run Time System.                  32

 4.   Deviations from the SIMULA standard.                      33
     4.1.   The DO UNTIL statement.                             33
     4.2.   Additional types.                                   33
     4.3.   Octal notation.                                     33
     4.4.   Class PUNCHFILE.                                    34
     4.5.   Class FILE.                                         34
     4.6.   Attribute protection.                               34
     4.7.   Virtuality of standard procedures.                  34
     4.8.   Expression evaluation.                              34
     4.9.   FOR statement.                                      35

 5.   Implementation Dependent Features.                        36
     5.1.   Physical limitations.                               36
     5.1.1.   Precision of numeric items.                       36
     5.1.2.   Zero.                                             36
     5.1.3.   Arithmetic relations.                             36
     5.1.4.   Program, array and text objects.                  37
     5.2.   Types and type conversion.                          37
     5.3.   Constants and constant expressions.                 38
     5.3.1.   LONG REAL constants.                              38
     5.3.2.   COMPLEX constants.                                39
     5.3.3.   Octal notation.                                   39
     5.4.   Initialisation of variables.                        39
     5.5.   Linkage to Fortran.                                 39
     5.5.1.   Fortran V (FOR) procedures.                       40
     5.5.2.   Ascii Fortran (FTN) procedures.                   41
     5.6.   Assembly language procedures.                       42
     5.6.1.   EXT. LIBRARY <type> PROCEDURE.                    43
     5.6.1.1.   Parameters called by value.                     43
     5.6.1.2.   Parameters called by reference.                 43
     5.6.1.3.   Parameters called by name.                      43
     5.6.2.   EXT. ASSEMBLY <type> PROCEDURE.                   44
     5.6.2.1.   Parameter transmission.                         44

 6.   The system classes.                                       46
     6.1.   SIMSET and SIMULATION.                              46
     6.2.   File handling.                                      46
     6.3.    Class BASICIO.                                     47
     6.4.    The file handling system.                          47
     6.5.   General File Characteristics                        48
     6.6.   Class OUTFILE.                                      50
     6.6.1.   File Generation (OUTFILE).                        50
     6.6.2.   OPEN (OUTFILE).                                   50
     6.6.3.   OUTIMAGE (OUTFILE).                               50
     6.6.4.   CLOSE (OUTFILE).                                  50
     6.7.   Class INFILE.                                       51
     6.7.1.   File Generation (INFILE).                         51
     6.7.2.   OPEN (INFILE).                                    52
     6.7.3.   INIMAGE (INFILE).                                 52
     6.7.4.   CLOSE (INFILE).                                   52


                                146
 ^pg;



                         Table of contents

     6.8.   Class DIRECTFILE.                                   53
     6.8.1.   File Generation (DIRECTFILE).                     54
     6.8.2.   OPEN (DIRECTFILE).                                54
     6.8.3.   LOCATE and LOCATION.                              54
     6.8.4.   ENDFILE.                                          54
     6.8.5.   INIMAGE (DIRECTFILE).                             55
     6.8.6.   OUTIMAGE (DIRECTFILE).                            55
     6.8.7.   CLOSE (DIRECTFILE).                               55
     6.9.   Class PRINTFILE.                                    56
     6.9.1.   File Generation (PRINTFILE).                      56
     6.9.2.   OPEN (PRINTFILE).                                 56
     6.9.3.   OUTIMAGE (PRINTFILE).                             57
     6.9.4.   LINESPERPAGE.                                     57
     6.9.5.   SPACING.                                          57
     6.9.6.   CLOSE (PRINTFILE).                                57
     6.10.   Class PUNCHFILE.                                   58
     6.11.   Magnetic Tape Files.                               58
     6.12.   SYSIN.                                             59
     6.12.1.   SYSIN.OPEN.                                      59
     6.12.2.   SYSIN.INIMAGE.                                   60
     6.12.3.   SYSIN.CLOSE.                                     60
     6.13.   SYSOUT.                                            61
     6.14.   Prefixing with the File Classes.                   61

 7.   Parameter transmission.                                   64
     7.1.   Parameter transmission by value.                    64
     7.1.1.   Value types.                                      64
     7.1.2.   Reference type.                                   65
     7.1.3.   Value type array.                                 65
     7.1.4.   TEXT by value.                                    65
     7.1.5.   PROCEDURE, LABEL or SWITCH.                       65
     7.2.   Parameter by reference.                             65
     7.2.1.   Value types by reference.                         65
     7.2.2.   Object reference.                                 65
     7.2.3.   TEXT by reference.                                66
     7.2.4.   Value type and TEXT array.                        66
     7.2.5.   Object reference array.                           66
     7.2.6.   PROCEDURE, LABEL and SWITCH.                      66
     7.3.   Parameter transmission by name.                     67
     7.4.   Simula procedures.                                  67
     7.4.1.   Formal procedures.                                67
     7.4.2.   Virtual Procedures.                               67
     7.4.3.   Separately compiled modules.                      68

 8.   Concurrent SIMULA activities.                             69
     8.1.   SIMULA program execution.                           69
     8.2.   The SIMULA system preparator.                       69
     8.2.1.   Options.                                          70
     8.2.1.1.   R option.                                       70
     8.2.1.2.   ADD$$$ options.                                 70
     8.2.2.   Parameters.                                       70
     8.3.   System Preparator Directives.                       71
     8.3.1.   PROC LIB   include library.                       71
     8.3.2.   SETMAX   set starting address.                    71
     8.3.3.   DEF   define program instance.                    71
     8.3.4.   ENT   initially active program in                 72
     8.3.5.   INCLUDE   in program instance                     72
     8.4.   Program scheduling primitives.                      72


                                147
 ^pg;



                         Table of contents

     8.4.1.   The terminated state.                             72
     8.4.2.   The operating state.                              72
     8.4.3.   The passivated state.                             73
     8.4.4.   PSendmail.                                        73
     8.4.5.   PGetmail.                                         74
     8.4.6.   PTerminate.                                       74
     8.4.7.   PMode.                                            75
     8.4.8.   PTrace.                                           75
     8.5.   File handling problems.                             75
     8.6.   Example: Subprogram and coprogram.                  76
     8.7.   References to literature.                           79

 9.   Predefined Procedures.                                    80
     9.1.   Arithmetic procedures.                              80
     9.2.   Character handling procedures.                      81
     9.3.   Random Drawing Procedures.                          82
     9.4.   Miscellaneous standard procedures.                  83
     9.5.   External utility library.                           84
     9.5.1.   Copy file to element.                             85
     9.5.2.   Locate element in a program file.                 86
     9.5.3.   Processor options utility routine                 87
     9.5.4.   INFOR table interface.                            87
     9.5.5.   Source input utility routine.                     88
     9.5.6.   Text conversion routines.                         90
     9.5.7.   Print and punch control.                          91
     9.5.8.   Access to non standard files.                     91
     9.6.   Partial word operations.                            93
     9.7.   Retreive ARRAY attributes.                          94
     9.8.   Pseudo normal drawing procedure.                    95
     9.9.   Error and tracing procedures.                       95
     9.9.1.   Trace Dynamic Chain                               95
     9.9.2.   Forced Runtime Error                              95
     9.10.  Storage management routines.                        96

 10.  Run Time Representation.                                  97
     10.1.  Program Structure.                                  97
     10.2.  Storage allocation                                 100
     10.2.1.  Program objects.                                 100
     10.2.2.  Algol block structure.                           101
     10.2.3.  Notype Procedure.                                101
     10.2.4.  Type procedure (function).                       102
     10.2.5.  Class instance.                                  103
     10.2.6.  Prefixed Block.                                  103
     10.2.7.  Text object structure.                           104
     10.2.8.  Array object structure.                          105
     10.3.  Declared quantities.                               105
     10.3.1.  INTEGER quantities.                              106
     10.3.2.  REAL quantities.                                 106
     10.3.3.  LONG REAL quantities.                            106
     10.3.4.  COMPLEX quantities.                              106
     10.3.5.  CHARACTER quantities.                            107
     10.3.6.  BOOLEAN quantities.                              107
     10.3.7.  REF quantities.                                  107
     10.3.8.  LABEL and SWITCH quantities.                     107
     10.3.9.  TEXT quantities.                                 107
     10.3.10.  ARRAY quantities.                               108
     10.3.10.1.  Array variable.                               108
     10.3.10.2.  Array parameter.                              108


                                148
 ^pg;



                         Table of contents

     10.4.  Storage Utilisation.                               109
     10.5.  Program capacity limitations.                      109

 A.   Examples of job setup.                                   111

 B.   Compiler diagnostics.                                    114

 C.   Run Time System Messages.                                136

 D.   Programming Hints.                                       139

 E.   Error reporting.                                         141
















































                                          149
           ^pg;



