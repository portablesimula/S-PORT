 Module EMATH("iAPX286");
%+D begin insert ECOMN,EBASE,EDUMP;
%-D begin insert ECOMN,EBASE      ;
       -----------------------------------------------------------------
       ---  COPYRIGHT 1990 by                                        ---
       ---  Simula a.s.                                              ---
       ---                                                           ---
       ---              P O R T A B L E     S I M U L A              ---
       ---                                                           ---
       ---                 F O R    i A P X    2 8 6                 ---
       ---                                                           ---
       ---                                                           ---
       ---        T  H  E     E  N  V  I  R  O  N  M  E  N  T        ---
       ---                                                           ---
       ---  Selection Switches: D                                    ---
       ---                                                           ---
       ---     D - Includes tracing dumps                            ---
       ---     M - Includes MS-DOS                                   ---
       ---     O - Includes MS-OS2                                   ---
       ---     X - Includes XENIX                                    ---
       ---                                                           ---
       ---                                                           ---
       ---     Status:                                               ---
       ---      RLOG10  Implemented by use of RLOGAR                 ---
       ---      DLOG10  Implemented by use of LOGARI                 ---
       ---      RSINH   Implemented by use of REXPON                 ---
       ---      SINH    Implemented by use of EXPONE                 ---
       ---      RCOSH   Implemented by use of REXPON                 ---
       ---      COSH    Implemented by use of EXPONE                 ---
       ---      RATAN2  Implemented by use of RARTAN                 ---
       ---      ATAN2   Implemented by use of ARCTAN                 ---
       ---                                                           ---
       -----------------------------------------------------------------

const real rpi      = 3.1415926536,
           rpihalf  = 1.5707963268,
           rpiquart = 7.8539816&-1,
           rpisixth = 5.2359877&-1,
           log2er   = 0.69314718056,
           rln10    = 2.302585093;
const long real lpi      = 3.141592653589793&&0,
                lpihalf  = 1.5707963267948965&&0,
                lpiquart = 7.853981633974483&&-1,
                lpisixth = 5.235987755982988&&-1,
                log2el   = 0.6931471805599453&&0,
                lln10    = 2.302585092994046&&0;
const long real mco(16) = (   1.0&&0,
    9.576032806985338&&-1, 9.170040432046712&&-1, 8.781260801866498&&-1,
    8.408964152537146&&-1, 8.052451659746272&&-1, 7.711054127039704&&-1,
    7.384130729697496&&-1, 7.071067811865476&&-1, 6.771277734684463&&-1,
    6.484197773255048&&-1, 6.209289060367420&&-1, 5.946035575013605&&-1,
    5.693943173783458&&-1, 5.452538663326289&&-1, 5.221368912137069&&-1);

Sysroutine("RTERR") RTERR;
import range(0:MaxByte) eno; ref() filref;  end;

%+E Visible Routine RSQROO;  --- rsqrt;
%-E Sysroutine ("RSQROO") RSQROO;  --- rsqrt;
    import real arg; export real res;
%+E begin short integer exp, t, cnt; real rtmp;
%+E       range (0:MaxWord) n, inc, man0, man1, rmn1, rmn2;
%+E       infix(Any4Byte) tmp; integer inci, ni;
%+DE      if TRCSW > 0
%+DE      then begtrace("RSQROO("); EdHexReal(trcbuf,arg);
%+DE           edchar(trcbuf,')'); outtrace;
%+DE      endif;
%+E       if arg <= 0.0             
%+E       then if arg < 0.0 then RTERR(128,none) endif;
%+E            res:= 0.0; goto E1;
%+E       endif;
%+E       tmp.AsReal:= arg;
%+E       exp:= wSHR(tmp.AsSint(1),7)-127;           -- Save exponent
%+E       man1:= wSHL(wAND(tmp.AsSint(1),127),9);
%+E       man0:= tmp.AsSint(0);                      -- Separate mantissa
%+E       man1:= wOR(man1,wSHL(wSHR(man0,15),8));
%+E       man0:= wSHL(man0,1);                       -- Even shifts    
%+E       -- Start computation.
%+E       if wAND(exp,1)=0 then rtmp:= 1.0 else rtmp:= 1.4142136; endif;
%+E       if exp<0 then rtmp:= 1.0/rtmp; exp:= exp+1; endif;
%+E       exp:= (exp/2)+127;                         -- New exponent
%+E       rmn1:= 0; rmn2:= 0; inc:= 0; cnt:= 0; n:= 3;
%+E       -- Square root of mantissa follows.
%+E       repeat while cnt<4 do    -- from first part of mantissa
%+E          inc:= wSHL(inc,2) + wSHR(man1,14);      -- no sign extension
%+E          man1:= wSHL(man1,2); n:= wSHL(n-1,1) + 1;
%+E          if inc >= n
%+E          then inc:= inc-n; n:= n+2; t:= 1; else t:= 0; endif;
%+E          rmn1:= wSHL(rmn1,1) + t; cnt:= cnt+1;
%+E       endrepeat;
%+E       repeat while cnt<9 do    -- to first part of result
%+E          inc:= wSHL(inc,2) + wSHR(man0,14);      -- no sign extension
%+E          man0:= wSHL(man0,2); n:= wSHL(n-1,1) + 1;
%+E          if inc >= n
%+E          then inc:= inc-n; n:= n+2; t:= 1; else t:= 0; endif;
%+E          rmn1:= wSHL(rmn1,1) + t; cnt:= cnt+1;
%+E       endrepeat;
%+E       repeat while cnt<12 do   -- number of digits
%+E          inc:= wSHL(inc,2) + wSHR(man0,14);
%+E          man0:= wSHL(man0,2); n:= wSHL(n-1,1) + 1;
%+E          if inc >= n
%+E          then inc:= inc-n; n:= n+2; t:= 1; else t:= 0; endif;
%+E          rmn2:= wSHL(rmn2,1) + t; cnt:= cnt+1;
%+E       endrepeat;
%+E       tmp.AsSint(0):= inc; tmp.AsSint(1):= 0; inci:= tmp.AsInt;
%+E       tmp.AsSint(0):= n; ni:= tmp.AsInt;
%+E       repeat while cnt<23 do   -- full integer for the rest
%+E          inci:= inci*4; ni:= (ni-1)*2 + 1;
%+E          if inci >= ni
%+E          then inci:= inci-ni; ni:= ni+2; t:= 1; else t:= 0; endif;
%+E          rmn2:= wSHL(rmn2,1) + t; cnt:= cnt+1;
%+E       endrepeat;
%+E       rmn2:= wOR(rmn2,wSHL(rmn1,14));
%+E       rmn1:= wOR(wSHR(rmn1,2),wSHL(wAND(exp,255),7));  
%+E       tmp.AsSint(0):= rmn2; tmp.AsSint(1):= rmn1;
%+E       res:= tmp.AsReal*rtmp;
%+DE      if TRCSW > 0
%+DE      then begtrace("RSQROO: Result = "); EdHexReal(trcbuf,res);
%+DE           outtrace;
%+DE      endif;
%+E E1:
    end;

%+E Visible Routine SQROOT;  --- sqrt;
%-E Sysroutine ("SQROOT") SQROOT;  --- sqrt;
    import long real arg; export long real res;
%+E begin long real inc, mul, tmp; short integer pres;
%+DE      if TRCSW > 0
%+DE      then begtrace("SQROOT("); EdHexLReal(trcbuf,arg);
%+DE           edchar(trcbuf,')'); outtrace;
%+DE      endif;
%+E       if arg <= 0.0&&0
%+E       then if arg < 0.0&&0 then RTERR(128,none) endif;
%+E            res:= 0.0&&0; goto E1;
%+E       endif;
%+E       mul:= 1.0&&0;
%+E       repeat while arg > 1.0&&2
%+E          do arg:= arg*1.0&&-2; mul:= mul*1.0&&1; endrepeat;
%+E       repeat while arg < 1.0&&0
%+E          do arg:= arg*1.0&&2; mul:= mul*1.0&&-1; endrepeat;
%+E       pres:= 1; res:= 0.0&&0; inc:= 1.0&&0;
%+E       repeat while pres < 18
%+E          do tmp:= 0.0&&0;
%+E          repeat while inc <= arg
%+E             do arg:= arg-inc; tmp:= tmp+1.0&&0;
%+E             inc:= inc+2.0&&0;
%+E          endrepeat;
%+E          inc:= (inc-1.0&&0)*1.0&&1+1.0&&0; arg:= arg*1.0&&2;
%+E          res:= tmp*mul+res; mul:= mul*1.0&&-1;
%+E          pres:= pres+1;
%+E          if arg = 0.0&&0 then goto E endif;
%+E       endrepeat;
%+DE      if TRCSW > 0
%+DE      then begtrace("SQROOT: Result = "); EdHexLReal(trcbuf,res);
%+DE           outtrace;
%+DE      endif;
%+E E:E1:
    end;

Visible Routine REXPON;  --- rexp;
import real arg; export real res;
begin long real y, d, d2, emd; short integer a,b;
%+D   if TRCSW > 0
%+D   then begtrace("REXPON("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg >  8.872284&1 then RTERR(26,none) endif;
      if arg < -8.733655&1 then res:= 0.0; goto E endif;
 --   y=arg/ln(2.0)=4a-b-d where a and b are integers>0, d fraction.
 --   then e**arg:= 2**y:= (16**a)(2**-b)(2**-d)
      a:= 0; b:= 0;
      y:= arg qua long real/log2el;
      repeat while y >= 0.0&&0 do a:= a + 1; y:= y - 4.0&&0 endrepeat;
      repeat while y <  -4.0&&0 do a:= a - 1; y:= y + 4.0&&0 endrepeat;
      repeat while y <= -1.0&&0 do b:= b + 1; y:= y + 1.0&&0 endrepeat;
      d:= -y; d2:= d*d;
 --   emd:= d2 + 8.74174972&&1;
 --   emd:= d2*0.34657359&&-1 - (6.17972269&&2/emd) + d + 9.95459478&&0;
 --   emd:= d*2.0&&0/emd;
 --   emd:= 1.0&&0 - emd;
      emd:= 1.0&&0 - (d*2.0&&0 /
            (d2*3.4657359&&-2 - (6.17972269&&2 /
            (d2 + 8.74174972&&1)) + d + 9.95459478&&0));
      case 0:4 (b)
          when 1: emd:= emd*5.0&&-1;
          when 2: emd:= emd*2.5&&-1;
          when 3: emd:= emd*1.25&&-1;
          when 4: emd:= emd*6.25&&-2;
      endcase;
      if (a > -5) and (a < 5) then a:= a+4;
         case 0:8 (a)
              when 0: emd:= emd*1.52587890625&&-5;
              when 1: emd:= emd*2.44140625&&-4;
              when 2: emd:= emd*3.90625&&-3;
              when 3: emd:= emd*6.25&&-2;
              when 4:
              when 5: emd:= emd*1.6&&1;
              when 6: emd:= emd*2.56&&2;
              when 7: emd:= emd*4.096&&3;
              when 8: emd:= emd*6.5536&&4;
         endcase;
      else emd:= DIPOWR(1.6&&1,a)*emd; endif;
      res:= emd qua real;
%+D   if TRCSW > 0
%+D   then begtrace("REXPON: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
E:end;

Visible Routine EXPONE;  --- exp;
import long real arg; export long real res;
begin long real y, d; short integer a,b,c;
%+D   if TRCSW > 0
%+D   then begtrace("EXPONE("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg >  7.097827128933840&&2 then RTERR(26,none) endif;
      if arg < -7.083964185322641&&2 then res:= 0.0&&0; goto E endif;
 --   arg = (4a-b-c/16)/ln(2.0&&0)-d, where a,b,c are integers
 --   a>0, 0<=b<=3, 0<=c<=15. d is a fraction, 0<= d <= 1/16.
 --   then e**arg:= 2**y:= (16**a)(2**-b)(2**-c/16)(e**-d)
      a:= 0; b:= 0; y:= arg/log2el;
      repeat while y >=  0.0&&0 do a:= a + 1; y:= y - 4.0&&0 endrepeat;
      repeat while y <  -4.0&&0 do a:= a - 1; y:= y + 4.0&&0 endrepeat;
      repeat while y <= -1.0&&0 do b:= b + 1; y:= y + 1.0&&0 endrepeat;
      c:= -y*16.0&&0 qua short integer;
      if -y < (c qua long real) then c:= c - 1 endif;
      d:= (y+(c qua long real*6.25&&-2))*log2el;
      res:= (((((d*0.13594970&&-2 +
            0.8331617720039062&&-2)*d +
            0.4166661730788750&&-1)*d +
            0.1666666659481656&&0)*d +
            0.4999999999951906&&0)*d +
            0.9999999999999892&&0)*d
      res:= res * mco(c) + mco(c);
      case 0:3 (b)
          when 1: res:= res*5.0&&-1;
          when 2: res:= res*2.5&&-1;
          when 3: res:= res*1.25&&-1;
      endcase;
      if (a > -5) and (a < 5) then a:= a+4;
      case 0:8 (a)
          when 0: res:= res*1.52587890625&&-5;
          when 1: res:= res*2.44140625&&-4;
          when 2: res:= res*3.90625&&-3;
          when 3: res:= res*6.25&&-2;
          when 4:
          when 5: res:= res*1.6&&1;
          when 6: res:= res*2.56&&2;
          when 7: res:= res*4.096&&3;
          when 8: res:= res*6.5536&&4;
      endcase;
      else res:= DIPOWR(1.6&&1,a)*res; endif;
%+D   if TRCSW > 0
%+D   then begtrace("EXPONE: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
E:end;

Visible Routine RLOGAR;  --- rln;
import real arg; export real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("RLOGAR("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg <= 0.0 then RTERR(128,none) endif;
      if arg = 1.0 then res:= 0.0;
      else res:= RELN(arg); endif;
%+D   if TRCSW > 0
%+D   then begtrace("RLOGAR: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine LOGARI;  --- ln;
import long real arg; export long real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("LOGARI("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg <= 0.0&&0 then RTERR(128,none) endif;
      if arg = 1.0&&0 then res:= 0.0&&0;
      else res:= LRLN(arg); endif
%+D   if TRCSW > 0
%+D   then begtrace("LOGARI: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Routine RELN;
import real arg; export real res;
begin real m, z2, a, b, w2; short integer exp;
      infix (Any4Byte) tmp;
      exp:= 0;
 --   Separate exponent and mantissa into exp and m.
      tmp.AsReal:= arg;
      exp:= wSHR(tmp.AsSint(1),7)-127;
      tmp.AsSint(1):= wOR(wAND(tmp.AsSint(1),127),wSHL(127,7));
      if tmp.AsReal < 0.7071068             -- m < 1/sqrt(2) ?
      then a:= 0.5; b:= 1.0
      else a:= 1.0; b:= 0.0
      endif;
      z2:= (tmp.AsReal-a) / (tmp.AsReal+a) * 2.0;
      w2:= z2 * z2;
--    Result is (exp-b)*log2e + log((1+z)/(1-z))
--    Computation of log((1+z)/(1-z)) is done by minimax
--    approximation of the form:
--      w+w*(0.55291406*w**2/(6.63515366-w**2))
      res:= log2er * (exp qua real -b) + z2 +
            (z2*(0.55291406*w2 / (6.63515366-w2)));
end;

Routine LRLN;
import long real arg; export long real res;
begin long real m, z2, a, b, w2, w3; short integer exp;
      exp:= 0; m:= arg;
--    Separate exponent and mantissa into exp and m.
      repeat while m > 1.0&&0
         do exp:= exp+1; m:= m*5.0&&-1; endrepeat;
      repeat while m < 0.5&&0
         do exp:= exp-1; m:= m*2.0&&0; endrepeat;
      if m < 0.7071068&&0              -- m < 1/sqrt(2) ?
      then a:= 0.5&&0; b:= 1.0&&0
      else a:= 1.0&&0; b:= 0.0&&0
      endif;
      z2:= (m-a) / (m+a) * 2.0&&0;
      w3:= z2 * z2 * z2; w2:= z2 * z2;
--    Result is (exp-b)*log2e + log((1+z)/(1-z))
--    Computation of log((1+z)/(1-z)) is done by minimax
--    approximation of the form:
--      W+c1*w**3(w**2+c2+c3/(w**2+c4+c5/(w**2+c6)))
      res:= log2el * (exp qua long real -b) + z2 +
            (0.2085992109128247&&-3*w3 *
            (w2 + 0.4777351196020117&&+2 - (0.2277631917769813&&+4 /
            (w2 - 0.6947850100648906&&+1 - (0.2625356171124214&&+1 /
            (w2 - 0.5561109595943017&&+1))))));
end;

Visible Routine RLOG10;
import real arg; export real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("RLOG10("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
 --   Log10(x) := Ln(x)/Ln(10) ;
      if arg <= 0.0 then RTERR(128,none) endif;
      if arg = 1.0 then res:= 0.0;
      else Res:= RELN(arg) / rln10; endif;
%+D   if TRCSW > 0
%+D   then begtrace("RLOG10: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine DLOG10;
import long real arg; export long real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("DLOG10("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
 --   Log10(x) := Ln(x)/Ln(10) ;
      if arg <= 0.0&&0 then RTERR(128,none) endif;
      if arg = 1.0&&0 then res:= 0.0&&0;
      else Res:= LRLN(arg) / lln10; endif;
%+D   if TRCSW > 0
%+D   then begtrace("DLOG10: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RIPOWR; --- res:=b**x ---
import real b; integer x; export real res;
begin real z; short integer r, sign;
      infix (Any4Byte) nt;
%+D   if TRCSW > 0
%+D   then begtrace("RIPOWR("); EdHexReal(trcbuf,b);
%+D        edchar(trcbuf,',');  Edint(trcbuf,x);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if x<0 then nt.AsInt:= -x; sign:= 1;
             else nt.AsInt:= x; sign:= 0; endif;
      res:= 1.0; z:= b;
      repeat
         r:= wAND(nt.AsSint(0),1);
         nt.AsSint(0):= wOR(wSHL(nt.AsSint(1),15),wSHR(nt.AsSint(0),1));
         nt.AsSint(1):= wSHR(nt.AsSint(1),1);
         if r=1 then res:= res*z endif;
      while nt.AsInt <> 0 do
         z:= z*z;
      endrepeat; 
      if sign=1 then res:= 1.0 / res endif;
%+D   if TRCSW > 0
%+D   then begtrace("RIPOWR: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RRPOWR; --- res:=b**x ---
import real b,x; export real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("RRPOWR("); EdHexReal(trcbuf,b);
%+D        edchar(trcbuf,',');  EdHexReal(trcbuf,x);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if b = 0.0
      then if x <= 0.0 then RTERR(26,none) else res:= 0.0 endif
      elsif x = 0.0 then res:= 1.0;
      else res:= REXPON(RELN(b)*x);
      endif;
%+D   if TRCSW > 0
%+D   then begtrace("RRPOWR: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RDPOWR; --- res:=b**x ---
import real b; long real x; export long real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("RDPOWR("); EdHexReal(trcbuf,b);
%+D        edchar(trcbuf,','); EdHexLReal(trcbuf,x);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if b = 0.0
      then if x <= 0.0&&0 then RTERR(26,none) else res:= 0.0&&0 endif
      elsif x = 0.0&&0 then res:= 1.0&&0
      else res:= EXPONE(LRLN(b qua long real)*x);
      endif;
%+D   if TRCSW > 0
%+D   then begtrace("RDPOWR: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine DIPOWR; --- res:=b**x ---
import long real b; integer x; export long real res;
begin long real z; short integer r, sign;
      infix (Any4Byte) nt;
%+D   if TRCSW > 0
%+D   then begtrace("DIPOWR("); EdHexLReal(trcbuf,b);
%+D        edchar(trcbuf,','); Edint(trcbuf,x);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if x<0 then nt.AsInt:= -x; sign:= 1;
             else nt.AsInt:= x; sign:= 0; endif;
      res:= 1.0&&0; z:= b;
      repeat
         r:= wAND(nt.AsSint(0),1);
         nt.AsSint(0):= wOR(wSHL(nt.AsSint(1),15),wSHR(nt.AsSint(0),1));
         nt.AsSint(1):= wSHR(nt.AsSint(1),1);
         if r=1 then res:= res*z endif;
      while nt.AsInt <> 0 do
         z:= z*z;
      endrepeat; 
      if sign=1 then res:= 1.0&&0 / res endif;
%+D   if TRCSW > 0
%+D   then begtrace("DIPOWR: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine DRPOWR; --- res:=b**x ---
import long real b; real x; export real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("DRPOWR("); EdHexLReal(trcbuf,b);
%+D        edchar(trcbuf,','); EdHexReal(trcbuf,x);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if b = 0.0&&0
      then if x <= 0.0 then RTERR(26,none) else res:= 0.0 endif
      elsif x =  0.0 then res:= 1.0
      else res:= EXPONE(LRLN(b)*x qua long real) qua real;
      endif;
%+D   if TRCSW > 0
%+D   then begtrace("DRPOWR: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine DDPOWR; --- res:=b**x ---
import long real b,x; export long real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("DDPOWR("); EdHexLReal(trcbuf,b);
%+D        edchar(trcbuf,','); EdHexLReal(trcbuf,x);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if b = 0.0&&0
      then if x <= 0.0&&0 then RTERR(26,none) else res:= 0.0&&0 endif
      elsif x =  0.0&&0 then res:= 1.0&&0
      else res:= EXPONE(LRLN(b)*x);
      endif;
%+D   if TRCSW > 0
%+D   then begtrace("DDPOWR: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RSINH;
import real arg; export real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("RSINH("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      res:= (REXPON(arg) - REXPON(-arg))*0.5;
%+D   if TRCSW > 0
%+D   then begtrace("RSINH: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine SINH;
import long real arg; export long real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("SINH("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      res:= (EXPONE(arg) - EXPONE(-arg))*5.0&&-1;
%+D   if TRCSW > 0
%+D   then begtrace("SINH: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RCOSH;
import real arg; export real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("RCOSH("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      res:= (REXPON(arg) + REXPON(-arg))*0.5;
%+D   if TRCSW > 0
%+D   then begtrace("RCOSH: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine COSH;
import long real arg; export long real res;
begin
%+D   if TRCSW > 0
%+D   then begtrace("COSH("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      res:= (EXPONE(arg) + EXPONE(-arg))*5.0&&-1;
%+D   if TRCSW > 0
%+D   then begtrace("COSH: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RTANH;
import real arg; export real res;
begin real ra, r2;
%+D   if TRCSW > 0
%+D      then begtrace("RTANH("); EdHexReal(trcbuf,arg);
%+D           edchar(trcbuf,')'); outtrace;
%+D   endif;
      ra:= if arg < 0.0 then - arg else arg; r2:= arg*arg;
      if ra < 3.9&-4 then res:= arg;
      elsif ra < 0.7
      then res:= (1.0 - (r2 * (3.7828&-3 +
                 (0.8145651 / (r2 + 2.471749))))) * arg;
      elsif ra < 9.011
      then r2:= REXPON(ra);
           res:= 1.0 - (2.0 / (r2 * r2 + 1.0));
           if arg < 0.0 then res:= -res endif
      elsif arg < 0.0 then res:= -1.0 else res:= 1.0;
      endif;
%+D   if TRCSW > 0
%+D   then begtrace("RTANH: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine TANH;
import long real arg; export long real res;
begin long real ra, r2;
%+D   if TRCSW > 0
%+D   then begtrace("TANH("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      ra:= if arg < 0.0&&0 then -arg else arg; r2:= arg*arg;
      if ra < 9.5&&-9 then res:= arg;
      elsif ra < 5.4931&&-1
      then res:= (-r2 * 0.9643735440816707&&0 /
                 (r2 + 0.9852988232825539&&1 -
                 (0.4530195153485250&&3 /
                 (r2 + 0.7718608264195518&&2 -
                 (0.3108853383729134&&3 /
                 (r2 + 0.2570185308319156&&2))))));
           res:= res * arg + arg;
      elsif ra < 2.0101&&1
      then r2:= EXPONE(ra);
           res:= 1.0&&0 - (2.0&&0 / (r2 * r2 + 1.0&&0));
           if arg < 0.0&&0 then res:= -res endif
      elsif arg < 0.0&&0 then res:= -1.0&&0 else res:= 1.0&&0;
      endif; 
%+D   if TRCSW > 0
%+D   then begtrace("TANH: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Routine Sinpi4r;
import real arg; export real res;
begin real rsq;
      if arg < 1.0&-10 then rsq:= 0.0 else rsq:= arg*arg endif;
      res:= (((-rsq*0.3595&-4 + 0.249001&-2)*rsq - 0.8074543&-1)*rsq
            + 0.78539816)*arg;
end;

Routine Cospi4r;
import real arg; export real res;
begin real rsq;
      if arg < 1.0&-10 then rsq:= 0.0 else rsq:= arg*arg endif;
      res:= ((-rsq*0.31957&-3 + 0.1585108&-1)*rsq - 0.30842480)*rsq
            + 1.0;
end;

Routine Sinpi4lr;
import long real arg; export long real res;
begin long real lrsq;
      if arg < 1.0&&-100 then lrsq:= 0.0&&0 else lrsq:= arg*arg endif;
      res:= ((((((lrsq*6.877360570940359&&-12
            - 1.757150074693567&&-9)*lrsq
            + 3.133616225433376&&-7)*lrsq
            - 3.657620415891387&&-5)*lrsq
            + 2.490394570188844&&-3)*lrsq
            - 8.074551218828053&&-2)*lrsq
            + 7.853981633974483&&-1)*arg;
end;

Routine Cospi4lr;
import long real arg; export long real res;
begin long real lrsq;
      if arg < 1.0&&-100 then lrsq:= 0.0&&0 else lrsq:= arg*arg endif;
      res:= ((((((-lrsq*3.858189006132306&&-13
            + 1.150051202818625&&-10)*lrsq
            - 2.461136403365227&&-8)*lrsq
            + 3.590860446027952&&-6)*lrsq
            - 3.259918869267376&&-4)*lrsq
            + 1.585434424381542&&-2)*lrsq
            - 3.084251375340424&&-1)*lrsq
            + 1.0&&0;
end;

Visible Routine RSINUS;
import real arg; export real res;
begin real r,z; integer q;
%+D   if TRCSW > 0
%+D   then begtrace("RSINUS("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0 then z:= -arg else z:= arg endif;
      z:= z / rpiquart;
      if z > 0.0 then q:= (z - 0.5) qua integer
                 else q:= 0 endif; 
      r:= z - (q qua real);
      if arg < 0.0 then q:= q + 4 endif;
      q:= bAND(q,7);
      case 0:7 (q)
         when 0: res:= Sinpi4r(r);
         when 1: res:= Cospi4r(1.0 - r); 
         when 2: res:= Cospi4r(r);
         when 3: res:= Sinpi4r(1.0 - r);
         when 4: res:= -Sinpi4r(r);
         when 5: res:= -Cospi4r(1.0 - r);
         when 6: res:= -Cospi4r(r);
         when 7: res:= -Sinpi4r(1.0 - r);
      endcase;
%+D   if TRCSW > 0
%+D   then begtrace("RSINUS: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine SINUSR;
import long real arg; export long real res;
begin long real r,z; integer q;
%+D   if TRCSW > 0
%+D   then begtrace("SINUSR("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0&&0 then z:= -arg else z:= arg endif;
      z:= z / lpiquart;
      if z > 0.0&&0 then q:= (z - 0.5&&0) qua integer
                    else q:= 0 endif; 
      r:= z - (q qua long real);
      if arg < 0.0&&0 then q:= q + 4 endif;
      q:= bAND(q,7);
      case 0:7 (q)
         when 0: res:= Sinpi4lr(r);
         when 1: res:= Cospi4lr(1.0&&0 - r); 
         when 2: res:= Cospi4lr(r);
         when 3: res:= Sinpi4lr(1.0&&0 - r);
         when 4: res:= -Sinpi4lr(r);
         when 5: res:= -Cospi4lr(1.0&&0 - r);
         when 6: res:= -Cospi4lr(r);
         when 7: res:= -Sinpi4lr(1.0&&0 - r);
      endcase;
%+D   if TRCSW > 0
%+D   then begtrace("SINUSR: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RCOSIN;
import real arg; export real res;
begin real r, z; integer q;
%+D   if TRCSW > 0
%+D   then begtrace("RCOSIN("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0 then z:= -arg else z:= arg endif;
      z:= z / rpiquart;
      if z > 0.0 then q:= (z - 0.5) qua integer
                 else q:= 0 endif; 
      r:= z - (q qua real);
      q:= q + 2; q:= bAND(q,7);
      case 0:7 (q)
         when 0: res:= Sinpi4r(r);
         when 1: res:= Cospi4r(1.0 - r); 
         when 2: res:= Cospi4r(r);
         when 3: res:= Sinpi4r(1.0 - r);
         when 4: res:= -Sinpi4r(r);
         when 5: res:= -Cospi4r(1.0 - r);
         when 6: res:= -Cospi4r(r);
         when 7: res:= -Sinpi4r(1.0 - r);
      endcase;
%+D   if TRCSW > 0
%+D   then begtrace("RCOSIN: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine COSINU;
import long real arg; export long real res;
begin long real r, z; integer q;
%+D   if TRCSW > 0
%+D   then begtrace("COSINU("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0&&0 then z:= -arg else z:= arg endif;
      z:= z / lpiquart;
      if z > 0.0&&0 then q:= (z - 0.5&&0) qua integer
                    else q:= 0 endif; 
      r:= z - (q qua long real);
      q:= q + 2; q:= bAND(q,7);
      case 0:7 (q)
         when 0: res:= Sinpi4lr(r);
         when 1: res:= Cospi4lr(1.0&&0 - r); 
         when 2: res:= Cospi4lr(r);
         when 3: res:= Sinpi4lr(1.0&&0 - r);
         when 4: res:= -Sinpi4lr(r);
         when 5: res:= -Cospi4lr(1.0&&0 - r);
         when 6: res:= -Cospi4lr(r);
         when 7: res:= -Sinpi4lr(1.0&&0 - r);
      endcase;
%+D   if TRCSW > 0
%+D   then begtrace("COSINU: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RTANGN;
import real arg; export real res;
begin short integer s; real r, w, pu, qu, hw2;
      infix (Any4Byte) qt;
%+D   if TRCSW > 0
%+D   then begtrace("RTANGN("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0 then s:= -1; arg:= -arg else s:= 1 endif;
      if arg > 8.2354966&5 then RTERR(128,none) endif;
      arg:= arg / rpiquart;
      qt.AsInt:= arg qua integer;
      if qt.AsInt qua real > arg then qt.AsInt:= qt.AsInt-1 endif;
      r:= arg - (qt.AsInt qua real);
      if wAND(qt.AsSint(0),1)=0 then w:= r else w:= 1.0 - r endif;
      if w > 1.5&-19
      then hw2:= w * w * 0.5; pu:= (hw2 - 8.460901) * w;
           qu:= (hw2 * 5.70366) - 10.772754 - (hw2*hw2*0.159321);
      else pu:= (w - 8.460901) * w; qu:= w*5.703366 - 10.772754;
      endif;
      case 0:3 (wAND(qt.AsSint(0),3))
      when 0: res:= pu / qu;
      when 1: res:= qu / pu;
      when 2: res:= -qu / pu;
      when 3: res:= -pu / qu;
      endcase;
      if s < 0 then res:= -res endif;
%+D   if TRCSW > 0
%+D   then begtrace("RTANGN: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Routine Ppw;
Import long real w2; export long real pw;
begin pw:= (((w2 - 6.078306953515&&2) * w2 + 4.50503889630777&&4) *
           w2 - 5.693090400634512&&5);
end;

Routine Pqw;
Import long real w2; export long real qw;
begin qw:= ((w2 * 3.54646216610&&1 - 6.4388583240077&&3) * w2 +
           2.064046948906228&&5) * w2 - 7.248667829840012&&5;
end;

Visible Routine TANGEN;
import long real arg; export long real res;
begin short integer s; long real r, w, pw, qw, w2;
      infix (Any4Byte) qt;
%+D   if TRCSW > 0
%+D   then begtrace("TANGEN("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0&&0 then s:= -1; arg:= -arg else s:= 1 endif;
      if arg > 1.1259&&15 then RTERR(128,none) endif;
      arg:= arg / lpiquart;
      qt.AsInt:= arg qua integer;
      if qt.AsInt qua long real > arg then qt.AsInt:= qt.AsInt-1 endif;
      r:= arg - (qt.AsInt qua long real);
      if wAND(qt.AsSint(0),1)=0 then w:= r else w:= 1.0&&0 - r endif;
      w2:= w * w;
      if w2 > 1.6&&-100         -- Test for underflow in w2*w2*w2.
      then pw:= Ppw(w2) * w; qw:= Pqw(w2);
      else pw:= w * (w2 - 5.693090400634512&&-5);
           qw:= w2*3.54646216610&&1 - 7.248667829840012&&5;
      endif;
      case 0:3 (wAND(qt.AsSint(0),3))
      when 0: res:= pw / qw;
      when 1: res:= qw / pw;
      when 2: res:= -qw / pw;
      when 3: res:= -pw / qw;
      endcase;
      if s < 0 then res:= -res endif;
%+D   if TRCSW > 0
%+D   then begtrace("TANGEN: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RCOTAN;
import real arg; export real res;
begin short integer s; real r, w, pu, qu, hw2;
      infix (Any4Byte) qt;
%+D   if TRCSW > 0
%+D   then begtrace("RCOTAN("); EdHexReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0 then s:= -1; arg:= -arg else s:= 1 endif;
      if arg > 8.2354966&5 then RTERR(128,none) endif;
      if arg < 1&-77 then RTERR(128,none) endif;
      arg:= arg / rpiquart;
      qt.AsInt:= arg qua integer;
      if qt.AsInt qua real > arg then qt.AsInt:= qt.AsInt-1 endif;
      r:= arg - (qt.AsInt qua real);
      if wAND(qt.AsSint(0),1)=0 then w:= r else w:= 1.0 - r endif;
      if w > 1.5&-19
      then hw2:= w * w * 0.5; pu:= (hw2 - 8.460901) * w;
           qu:= (hw2 * 5.70366) - 10.772754 - (hw2*hw2*0.159321);
      else pu:= (w - 8.460901) * w; qu:= w*5.703366 - 10.772754;
      endif;
      case 0:3 (wAND(qt.AsSint(0),3))
      when 0: res:= qu / pu;
      when 1: res:= pu / qu;
      when 2: res:= -pu / qu;
      when 3: res:= -qu / pu;
      endcase;
      if s < 0 then res:= -res endif;
%+D   if TRCSW > 0
%+D   then begtrace("RCOTAN: Result = "); EdHexReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine COTANG;
import long real arg; export long real res;
begin short integer s; long real r, w, pw, qw, w2;
      infix (Any4Byte) qt;
%+D   if TRCSW > 0
%+D   then begtrace("COTANG("); EdHexLReal(trcbuf,arg);
%+D        edchar(trcbuf,')'); outtrace;
%+D   endif;
      if arg < 0.0&&0 then s:= -1; arg:= -arg else s:= 1 endif;
      if arg > 1.1259&&15 then RTERR(128,none) endif;
      arg:= arg / lpiquart;
      qt.AsInt:= arg qua integer;
      if qt.AsInt qua long real > arg then qt.AsInt:= qt.AsInt-1 endif;
      r:= arg - (qt.AsInt qua long real);
      if wAND(qt.AsSint(0),1)=0 then w:= r else w:= 1.0&&0 - r endif;
      w2:= w * w;
      if w2 > 1.6&&-100         -- Test for underflow in w2*w2*w2.
      then pw:= Ppw(w2) * w; qw:= Pqw(w2);
      else pw:= w * (w2 - 5.693090400634512&&-5);
           qw:= w2*3.54646216610&&1 - 7.248667829840012&&5;
      endif;
      case 0:3 (wAND(qt.AsSint(0),3))
      when 0: res:= qw / pw;
      when 1: res:= pw / qw;
      when 2: res:= -pw / qw;
      when 3: res:= -qw / pw;
      endcase;
      if s < 0 then res:= -res endif;
%+D   if TRCSW > 0
%+D   then begtrace("COTANG: Result = "); EdHexLReal(trcbuf,res);
%+D        outtrace;
%+D   endif;
end;

Visible Routine RARTAN;
import real arg; export real res;
begin short integer s, inv, st;
%+D    if TRCSW > 0
%+D    then begtrace("RARTAN("); EdHexReal(trcbuf,arg);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if arg < 0.0 then s:= -1; arg:= -arg else s:= 1 endif;
       if arg > 1.0 then inv:= -1; arg:= 1.0/arg else inv:= 1 endif;
       if arg < 2.44&-4 then res:= arg
       else if arg <= 0.26795 then st:= 1
            else st:= -1;
                 arg:= (arg * 0.732051 - 1.0 + arg) /
                       (arg + 1.732051);
            endif;
            res:= arg * (0.60310579 - (0.05160454*arg*arg) +
                  (0.55913709 / (arg*arg + 1.4087812)));
            if st < 0 then res:= rpisixth + res endif;
       endif;
       if inv < 0 then res:= rpihalf - res endif;
       if s < 0 then res:= -res endif;
%+D    if TRCSW > 0
%+D    then begtrace("RARTAN: Result = "); EdHexReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

Visible Routine ARCTAN;
import long real arg; export long real res;
begin long real darg; short integer s, inv, st;
%+D    if TRCSW > 0
%+D    then begtrace("ARCTAN("); EdHexLReal(trcbuf,arg);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if arg < 0.0&&0 then s:= -1; arg:= -arg else s:= 1 endif;
       if arg > 1.0&&0 then inv:= -1; arg:= 1.0&&0/arg else inv:= 1 endif;
       if arg < 3.7&&-9 then res:= arg
       else if arg <= 2.6795&&-1 then st:= 1
            else st:= -1;
                 arg:= (arg * 0.732050807568877&&0 - 1.0&&0 + arg) /
                       (arg + 1.732050807568877&&0);
            endif;
            darg:= arg * arg;
            res:= darg + 1.331282181443987&&0;
            res:= 1.351430064094942&&-1 / res;
            res:= darg + 2.669186939532663&&0 - res;
            res:= 1.660051565960002&&0 / res;
            res:= darg + 2.717991214096480&&0 - res;
            res:= 6.752198191404210&&-1 / res;
            res:= -7.371899082768562&&-3 - res;
            res:= arg*darg*res + arg;
            if st < 0 then res:= lpisixth + res endif;
       endif;
       if inv < 0 then res:= lpihalf - res endif;
       if s < 0 then res:= -res endif;
%+D    if TRCSW > 0
%+D    then begtrace("ARCTAN: Result = "); EdHexLReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

Routine Arsinr;
import real arg; export real res;
begin real a2; a2:= arg * arg;
      res:= arg + (arg*arg*arg*(-0.5049404 / (a2 - 
            3.7042025 - (1.2516474 / (a2 - 1.8555182)))));
--    The routine assumes 0.0<arg<=0.5;
end;

Routine Arsinp;
import long real arg; export long real res;
begin long real a2; a2:= arg * arg;
      res:= a2 - 1.19625261960154476&&0;
      res:= 3.737027365107758&&-2 / res;
      res:= a2 - 1.74882357832528117&&0 - res;
      res:= 4.1896233680025977&&-1 / res;
      res:= a2 - 3.64565146031194167&&0 - res;
      res:= 4.53770940160639666&&0 / res;
      res:= a2 - 4.44110670602864049&&0 - res;
      res:= 4.9961647241138661&&-1 / res;
      res:= 5.87162904063511&&-3 - res;
      res:= arg*arg*arg*res + arg;
--    The routine assumes 0.0<arg<=0.5;
end;

Visible Routine RARCOS;
import real arg; export real res;
begin short integer s;
%+D    if TRCSW > 0
%+D    then begtrace("RARCOS("); EdHexReal(trcbuf,arg);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if arg < 0.0 then s:= -1; arg:= -arg else s:= 1 endif;
       if arg > 1.0 then RTERR(128,none) endif;
       if arg <= 0.5
       then res:= rpihalf - Arsinr(arg)
       else res:= 2.0*Arsinr(RSQROO((-arg+1.0)*0.5));
       endif;
       if s < 0 then res:= rpi - res endif;
%+D    if TRCSW > 0
%+D    then begtrace("RARCOS: Result = "); EdHexReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

Visible Routine ARCCOS;
import long real arg; export long real res;
begin short integer s; long real sq, a2;
%+D    if TRCSW > 0
%+D    then begtrace("ARCCOS("); EdHexLReal(trcbuf,arg);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if arg < 0.0&&0 then s:= -1; arg:= -arg else s:= 1 endif;
       if arg > 1.0&&0 then RTERR(128,none) endif;
       if arg <= 0.5&&0
       then res:= lpihalf - Arsinp(arg)
       else res:= 2.0&&0*Arsinp(SQROOT((-arg+1.0&&0)*5.0&&-1));
       endif;
       if s < 0 then res:= lpi - res endif;
%+D    if TRCSW > 0
%+D    then begtrace("ARCCOS: Result = "); EdHexLReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

Visible Routine RARSIN;
import real arg; export real res;
begin short integer s; real sq, a2;
%+D    if TRCSW > 0
%+D    then begtrace("RARSIN("); EdHexReal(trcbuf,arg);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if arg < 0.0 then s:= -1; arg:= -arg else s:= 1 endif;
       if arg > 1.0 then RTERR(128,none) endif;
       if arg <= 0.5
       then res:= Arsinr(arg)
       else res:= rpihalf - (2.0*Arsinr(RSQROO((-arg+1.0)*0.5)));
       endif;
       if s < 0 then res:= -res endif;
%+D    if TRCSW > 0
%+D    then begtrace("RARSIN: Result = "); EdHexReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

Visible Routine ARCSIN;
import long real arg; export long real res;
begin short integer s;
%+D    if TRCSW > 0
%+D    then begtrace("ARCSIN("); EdHexLReal(trcbuf,arg);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if arg < 0.0&&0 then s:= -1; arg:= -arg else s:= 1 endif;
       if arg > 1.0&&0 then RTERR(128,none) endif;
       if arg <= 0.5&&0
       then res:= Arsinp(arg)
       else res:= lpihalf -
                  (2.0&&0 * Arsinp(SQROOT((-arg+1.0&&0)*5.0&&-1)));
       endif;
       if s < 0 then res:= -res endif;
%+D    if TRCSW > 0
%+D    then begtrace("ARCSIN: Result = "); EdHexLReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

Visible Routine RATAN2;
import real y,x; export real res;
begin
%+D    if TRCSW > 0
%+D    then begtrace("RATAN2("); EdHexReal(trcbuf,y);
%+D         edchar(trcbuf,',');  EdHexReal(trcbuf,x);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if x = 0.0
       then if y = 0.0 then RTERR(128,none)
            elsif y > 0.0 then res:= rpihalf else res:= -rpihalf endif;
       else res:= RARTAN(y/x)
            if    y > 0.0 then if res < 0.0 then res:= res + rpi endif;
            elsif y < 0.0 then if res > 0.0 then res:= res - rpi endif;
            --- y = 0 corr. sep 91 pje
            else  res:= if x < 0.0 then rpi else 0.0 endif
       endif;
%+D    if TRCSW > 0
%+D    then begtrace("RATAN2: Result = "); EdHexReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

Visible Routine ATAN2;
import long real y,x; export long real res;
begin
%+D    if TRCSW > 0
%+D    then begtrace("ATAN2("); EdHexLReal(trcbuf,y);
%+D         edchar(trcbuf,','); EdHexLReal(trcbuf,x);
%+D         edchar(trcbuf,')'); outtrace;
%+D    endif;
       if x = 0.0&&0
       then if y = 0.0&&0 then RTERR(128,none)
            elsif y > 0.0&&0 then res:= lpihalf else res:= -lpihalf
            endif;
       else res:= ARCTAN(y/x)
            if    y > 0.0&&0 then if res < 0.0&&0 then res:= res + lpi endif;
            elsif y < 0.0&&0 then if res > 0.0&&0 then res:= res - lpi endif;
            --- y = 0 corr. sep 91 pje
            else  res:= if x < 0.0&&0 then lpi else 0.0&&0 endif
       endif;
%+D    if TRCSW > 0
%+D    then begtrace("ATAN2: Result = "); EdHexLReal(trcbuf,res);
%+D         outtrace;
%+D    endif;
end;

end;
