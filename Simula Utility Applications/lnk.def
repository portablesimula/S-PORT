Module
%-E    LNK("iAPX-286");
%+E    LNK("iAPX-386");
begin insert UCOMN,UBASE;
       -----------------------------------------------------------------
       ---  COPYRIGHT 1989 by                                        ---
       ---  Simula a.s., Oslo, Norway                                ---
       ---                                                           ---
       ---              P O R T A B L E     S I M U L A              ---
       ---                                                           ---
       ---             F O R    i A P X    2 8 6 / 3 8 6             ---
       ---                                                           ---
       ---     T  H  E     M  S  -  D  O  S     L  I  N  K  E  R     ---
       ---                                                           ---
       ---  Selection Switches:                                      ---
       ---                                                           ---
       ---     C - Includes Consistency Tests                        ---
       ---     D - Includes tracing dumps                            ---
       ---     M - Generate code for MS-DOS                          ---
       ---     O - Generate code for MS-OS2                          ---
       ---     X - Generate code for XENIX                           ---
       ---     E - Extended Mode I.e XENIX/386, UNIX/386             ---
       -----------------------------------------------------------------

Define MxpNam=2;      -- I.e. max   512 Local Names    (per OBJ-MODULE)
Define MxpSeg=2;      -- I.e. max   512 Local Segments (per OBJ-MODULE)
Define MxpLgr=1;      -- I.e. max   256 Local Groups   (per OBJ-MODULE)
Define MxpExt=4;      -- I.e. max  1024 Local EXTERNs  (per OBJ-MODULE)
Define MxpBnk=1;      -- I.e. max   256 Global BANKs
Define MxpGrp=1;      -- I.e. max   256 Global GROUPs
Define MxpFrm=8;      -- I.e. max  2048 Global FRAMEs
Define MxpMod=4;      -- I.e. max  1024 Global OBJ-MODULEs
Define MxpLib=2;      -- I.e. max   512 Global LIBRARIES
Define BufLng=4096;   -- size of .LIB and .OBJ file buffers
Define CBUFsize=5632  -- extra room 
Define nBuffers=11;   -- i.e. CBUFsize/512, also perfect for rts/env
unsigned curClng;
--- Define RelBufLng=8192   -- size of rel. code buffer
--- Define nrelBuf=16       -- no of same
--- Define bufTotal=131072  -- i.e. nrelbuf*relbuflng
unsigned relBufLng, nrelbuf; integer bufTotal;

Define cSTACK=0,cDATA=1,cCODE=2,cLINE=3;
Define fPOINTER=3,fBASE=2,fOFFSET=1,fHIBYTE=4,fLOBYTE=0;
Define iNOP=144,iINT=205,iJMP=233,iJMPF=234,iCALL=232,iCALLF=154;

Define SegAddr=0,GrpAddr=1,ExtAddr=2,NoAddr=3;
Define MaxAddr=3;

Record MemAddr; info "TYPE";
begin Byte Kind;  -- Variant kind code
      Word Ofst;  -- Offset part
      variant Word Segx; -- SegAddr: Mod.SegTab(Segx-1)+Offset
      variant Word Grpx; -- GrpAddr: Mod.GrpTab(Grpx-1)+Offset
      variant Word Extx; -- ExtAddr: Mod.ExtTab(Extx-1)+Offset
end;
%title ******    G L O B A L    D A T A    ******
    Boolean Verbose;
    boolean mergeLinBnk;            -- true if no LinBnk should be gen.
    Unsigned HDSIZE;                -- Default size of .EXE-File Header
                                    -- (in 512-Byte Pages)
    Byte xGOTO;                     -- INT-vector index
    Byte xJMPF;                     -- INT-vector index
    Byte xCALL;                     -- INT-vector index
    Byte xCALF;                     -- INT-vector index

    Boolean BankDefining;           -- 
    Ref(BANK) RotBnk;               -- Root Bank (EXE/Resident part)
    Ref(BANK) LinBnk;               -- LineNumber Bank
    Character NextChar;             -- Next Character from Standard Input
    Integer Total;                  -- Total size in Bytes
    Unsigned NextFrmx;              -- Next available FRAME index
    Ref(FRAME) FrmTab(256);         -- Used as Frmx to FRAME mapping
                                    --      during Module Loading.
    Infix(MemAddr) StartAddr;       -- Program's Start Address
    Ref(OBJMODULE) StartMod;        -- The OBJMODULE With Start Address
    Ref(FRAME) StackFrm;            -- Program's Stack Frame

    Word nBnk; Ref(RefBlock) BNKMAP(MxpBnk);   -- All Defined BANKs
    Word nGrp; Ref(RefBlock) GRPMAP(MxpGrp);   -- All Defined GROUPs
    Word nFrm; Ref(RefBlock) FRMMAP(MxpFrm);   -- All Defined FRAMEs
    Word nMod; Ref(RefBlock) MODMAP(MxpMod);   -- All Defined OBJ-MODULEs
    Word nLib; Ref(RefBlock) LIBMAP(MxpLib);   -- All Defined LIBRARIES
    unsigned nOpen;                 -- no of open LIBs and/or MODs
    Infix(ObjCodeBuffer) CBUF;      -- Object Code and LIB-DIC Input Buffer

    --------------- BANK INFO TABLE ---------------
    Unsigned TabLng;                -- Length of BankInfo Table
    Ref(WrdVector) BnkTab;          -- The BankInfo Table

    --------------- CURRENT MODULE UTILITIES ---------------
    Ref(OBJMODULE) CurMod;          -- Current OBJMODULE (During LOADING)
    Ref(FRAME) CurFrm;              -- Current FRAME
    Ref(SEGMENT) CurSeg;            -- Current SEGMENT
%+D Integer BytPos;                 -- Input Byte number
%+D Integer RecPos;                 -- First Byte of current record
    Unsigned RecLast;               -- first pos after current record
%+D Byte ChkSum;                    -- Check-sum of current record
%+D Byte RecTyp;                    -- Current Record Type
    Infix(MemAddr) ImpTarget(4);    -- Implicit Target Table
    Infix(MemAddr) ImpFrame(4);     -- Implicit Frame  Table
    Word nNam; Ref(WrdBlock) NamTab(MxpNam); -- All Locally Defined Names
    Word nSeg; Ref(RefBlock) SegTab(MxpSeg); -- All Locally Defined Segments
    Word nLgr; Ref(RefBlock) LgrTab(MxpLgr); -- All Locally Defined Groups
    Word nExt; Ref(WrdBlock) ExtTab(MxpExt); -- All Locally Defined Externals

    --------------- TRACING SWITCHES ---------------
%+D Byte AtrSw;                     -- Allocation Trace mode switch
    Byte LstSw;                     -- Listing Level
%+D Word LN1MOD,LN2MOD;             -- Trace Module's FileName
%+D Integer LN1POS,LN2POS;          -- Trace Start-Byte Pos in File
%+D Unsigned LN1CNT,LN2CNT;         -- Trace Byte Count
%+D Unsigned LN1TRC,LN2TRC;         -- Trace Switces:

    --------------- BASIC FILE HANDLING ---------------
    Unsigned Srcf;                  -- Source File Handle
    Unsigned Inpt;                  -- .LIB and .OBJ-Input File Handle
    Unsigned Oupt;                  -- Created Listing File Handle

    --------------- OUTPUT FILE HANDLING ---------------
    Unsigned ExeFile;               -- .EXE-Output File Handle
    Word ExeFilNam;                 -- .EXE-Output File Name
    Unsigned BnkFile;               -- .BNK-Output File Handle
    Word BnkFilNam;                 -- .BNK-Output File Name
    unsigned curWhandle;            -- handle of current output file
    unsigned curHandle;             -- current writerel file handle
    integer curFpos;                -- next file pos on curHandle
    integer curWpos;                -- next file pos on curWhandle
    Integer BnkFilLng;              -- Length of BnkFile (in Bytes)
    Ref(DATABLK) FreeBlk;           -- Head of Free Code Buffer Chain
    Ref(DATABLK) CurBlk;            -- Code Buffer during LOADER
    ref(relBuffer) freeRbuf;        -- head of free chain 
    ref(RelBuffer) RBUFr;           -- Buffers for abs. output
    ref(fileDescr) opChain;         -- Chain of open LIB/MOD files
    Infix(EXELABEL) ExeLab;         -- .EXE File Label

    --------------- SYMBOL TABLE ---------------
    Unsigned nUNDEF;                -- No.of UNDEFINED PUBLICs
    Ref(RefBlock) PUBREF(MxpSmb);   -- Public info (if PUBLIC Symbol)
    Word sHDSIZE,sLISTING,sINTGOTO,sINTJMPF,sINTCALL,sINTCALF;
    Word sCOMMENT,sLBRK,sRBRK,sCOMA,sEQUAL,sPLUS,sBNK,sEXE,sDEF,sEXT;
    Word sLIB,sEND,sSTACK,sEGOTO,sECALL,sBNKTAB;
%+D Word sLN1TRC,sLN2TRC,sTRACE,sATRACE;

    ---------------- Statistics -----------------
%+D integer scanStat(7); integer scanTotal; 
    -- THEADDR, COMENT, EXTDEF, PUBDEF, LNAMES, SEGDEF, GRPDEF
%+D integer loadStat(4); integer loadTotal;
    -- LINNUM, FIXUPP, LEDATA, LIDATA
%title ***   D y n a m i c   O b j e c t s    ***
Record BANK;
begin Word           Ident;
      Boolean     Allocated;  -- True: Bank is allocated
      Boolean        Extern;  -- True: Bank is external
      Dword          Start;   -- Bank's Start Address in Memory
      Integer        Length;  -- Bank's Length (in Bytes)
      Ref(RefVector) PrdBnk;  -- Bank's Predecessors
      Ref(FRAME)     FrmLnk;  -- Bank's FRAMEs (next: Frm.Suc)
      Unsigned       Handle;  -- Bank's OutPut File Handle (.EXE/.BNK)
      Ref(BankDescr) BnkDsc;  -- Bank's Bank Descriptor
      Unsigned       FrmPos;  -- Pos of FrmTab in Bank-Info-Table
      Unsigned       nFrmx;   -- No.of Frame indicies in Bank-Info-Table
end;

Record XBANK:BANK;  -- External BANK
begin Word FileName;
--    ...
--    ...
--    ...
--    ...
end;

Record FRAME;
begin Ref(FRAME) Suc;          -- Next FRAME belonging to same BANK
      Word Ident;        -- Frame's Identification
      Byte cType;        -- Combine Type, 0:STACK,1:DATA,2:CODE,3:LINE
      Dword Start;       -- Frame's Start Address in Memory
      Unsigned Length;   -- Frame's Length          (in Bytes)
      Ref(BANK) Bnk;           -- This FRAME is a member of Bnk
      Ref(GROUP) Grp;          -- This FRAME is a member of Grp
      Ref(FRAME) GrpLnk;       -- Next FRAME belonging to same GROUP
      Ref(SEGMENT) first,last; -- List of local segments
      Ref(RELOBLK) RelBlk;     -- List of relocation offset's
end;

Record GROUP;
begin Ref(FRAME) Frm;  -- First FRAME in this GROUP
      Word Ident;      -- GROUP's Identification
      Dword Start;     -- GROUP's Start Address in Memory
end;

Record SEGMENT;
begin Ref(SEGMENT) Suc;
      Word Modx;        -- 0:NoModule, x:MODMAP.Elt(x)
      Word Ident;       -- Segment Identification
      Byte cType;       -- Combine Type, 0:STACK,1:DATA,2:CODE,3:LINE
      Byte Align;       -- 1:Byte, 2:Word, 3:Para, 4:Page
      Unsigned Length;  -- No.of Bytes in segment
      Unsigned Filled;  -- No.of Bytes filled in segment
      Dword Start;      -- Segment's Start Address in Memory
      Ref(FRAME) Frm;
      Ref(DATABLK) first,last;
end;

Record ObjCodeBuffer;
begin Unsigned nxt; -- Next available Byte position
      variant character chr(CBUFsize);
      variant Byte byt(CBUFsize);
end;

Record LibBuffer; --- overlays CBUF when reading LIBs
begin variant character chr(CBUFsize);
      variant Byte byt(CBUFsize);
end;

Record RelBuffer;
begin ref(RelBuffer) suc;
      integer filpos;  -- start filepos for buffer
      integer curpos;  -- current filepos
      unsigned filled; -- i.e. curpos = filpos+filled
      unsigned handle;
---   character byt(RelBufLng);
      character byt(    0    );
end;

Record DATABLK;
begin Ref(DATABLK) Prd,Suc;
      Unsigned Ofst;    -- Relative to CurSeg.Start
      Unsigned Lng;     -- No.of significant Bytes in Image
      variant Byte Image(1024);      -- Load Text Image
      variant character chr(1024);   -- Load Text Image
end;

Record RELOBLK;
begin Ref(RELOBLK) Suc;
      range(0:MaxWord) nRel;
      range(0:MaxWord) Base;        -- Used by BnkTerm
      Word RELTAB(254); -- (0:nRel);
end;

Record PUBLIC;
begin Ref(SEGMENT) Seg;
      Unsigned Ofst;
end;

record fileDescr;
begin ref(filedescr) suc;
      Word Ident;      -- File or Element Name
      unsigned handle; -- >0: file handle (open)
end;

Record OBJMODULE:fileDescr;
begin Ref(RefVector) SegTab;  -- Local Segment Table
      Word Libx;       -- >0: Element of LIBMAP(Libx)
      Word EltLnk;     -- >0: Next Element is MODMAP(EltLnk)
      Unsigned EltRef;        -- Element FilePos in Paragraphs
      Ref(RefVector) LgrTab;  -- Local Group Table
      Ref(WrdVector) ExtTab;  -- Local External Table
end;

Record LIBRARY:fileDescr;
begin Word FstElt;     -- >0: First Element is MODMAP(FstElt)
      Dword nBlk;      -- Number of Dictionary Blocks
      Dword BlkRef;    -- File Position of First Dictionary Block
end;

Record EXELABEL;
begin Range(0:MaxWord) ChkCode;   --00-- (=23117) EXE-File Check code
      Range(0:MaxWord) Nblp;      --02-- Number of Byte in last page
      Range(0:MaxWord) Lngp;      --04-- File size in 512-Byte pages
      Range(0:MaxWord) nRel;      --06-- No.of relocation entries in table
      Range(0:MaxWord) Lngh;      --08-- Size of header in 16-Byte paragraphs
      Range(0:MaxWord) MinAlloc;  --10-- (=Size of BANK-area)
      Range(0:MaxWord) MaxAlloc;  --12-- (=Size of BANK-area) MUST BE NON-ZERO
      Range(0:MaxWord) SS;        --14-- SS initial value (+reloc)
      Range(0:MaxWord) SP;        --16-- SP initial value
      Range(0:MaxWord) ChkSum;    --18-- Check-Sum
      Range(0:MaxWord) IP;        --20-- IP initial value
      Range(0:MaxWord) CS;        --22-- CS initial value (+reloc)
      Range(0:MaxWord) Relo;      --24-- (=30) Rel. Byte offset of Reloc-Table
      Range(0:MaxWord) Ovln;      --26-- (=0)  Overlay number
      Range(0:MaxWord) Uknw;      --28-- (=1)  Unknown
--??  Dword           RelTab(0);  --30-- Relocation Table, NOTE: NOT Aligned 4
end;
%title ***   B A N K   I N F O   T A B L E   ***

--
-- NOTE: DO NOT CHANGE WITHOUT ALSO CHANGE MODULE  ../env/ecomn  !!!!!
--
-- NOTE: MUST BE INDEPENDENT OF 2/4-BYTE ALIGNMENT               !!!!!
--

Record BankInfo;
begin Byte nBnk;                  --00--
      Byte nNam;                  --01--
      Range(0:MaxWord) NamPos;    --02--
      Range(0:MaxWord) LinBnk;    --04-- Rel.Pos LinBnk's BankDescr or +0
      Range(0:MaxWord) BnkLng;    --06-- Size of Bank-area in paragraphs
      Byte xGOTO;                 --08-- INT-Vector index
      Byte xJMPF;                 --09-- INT-Vector index
      Byte xCALL;                 --10-- INT-Vector index
      Byte xCALF;                 --11-- INT-Vector index
--    Infix(BankDescr) BnkTab;    --12--
end;

Record BankDescr;
begin Range(0:MaxWord) fnam;       --00-- File Name Offset
      Range(0:MaxWord) bnam;       --02-- Bank Name Offset
      Boolean InMem;               --04-- 0:Not in Memory
      Byte nFrm;                   --05-- no.of local Frames
      Range(0:MaxWord) Length;     --06-- Length of Text in Paragraphs
      Integer TxtPos;              --08-- First File-pos (Load Text)
      Integer RelPos;              --12-- First File-pos (Relocations)
      Word MemBase;                --16-- First Paragraph Addr in Memory
      Word FrmBase(0);             --18-- Local Frame Base Addresses
end;

%title ***   O b j e c t    G e n e r a t i o n   ***
Routine NewBANK;
import Size ObjLng; Word Ident; Unsigned nPrd; export ref(BANK) Bnk;
begin ALLOC(Bnk,ObjLng); Bnk.Ident:=Ident;
      Bnk.PrdBnk:=NewRefVector(nPrd); Bnk.PrdBnk.nElt:=nPrd;
      nBnk.val:=nBnk.val+1;
      if nBnk.HI >= MxpBnk then CAPERR("Bank-Table Overflow") endif;
      if BNKMAP(nBnk.HI)=none
      then BNKMAP(nBnk.HI):=NEWOBJ(size(RefBlock)) endif;
      BNKMAP(nBnk.HI).Elt(nBnk.LO):=Bnk;
end;

macro NewDATABLK(0); --- Blk implicit parameter
begin if FreeBlk = none then ALLOC(Blk,Size(DATABLK))
      else Blk:=FreeBlk; FreeBlk:=Blk.Prd endif;
      Blk.Prd:=none; Blk.Suc:=none;
endmacro;

Routine NewMODULE; import Word Ident; export Word modx;
begin ref(OBJMODULE) Mod; nMod.val:=nMod.val+1;
      if nMod.HI >= MxpMod then CAPERR("Module-Table Overflow") endif;
      if MODMAP(nMod.HI)=none
      then MODMAP(nMod.HI):=NEWOBJ(size(RefBlock)) endif;
      ALLOC(Mod,  Size(OBJMODULE)); Mod.Ident:=Ident;
      Mod.Libx.val:=0; Mod.EltLnk.val:=0; Mod.EltRef:=0;
      Mod.LgrTab:=none; Mod.SegTab:=none; Mod.ExtTab:=none;
      MODMAP(nMod.HI).Elt(nMod.LO):=Mod; modx:=nMod;
end;

Routine NewLIBRARY; import Word Ident;
begin ref(LIBRARY) Lib; Unsigned h,n; character Fhdr(16);
%+D   if TrcSw > 0
%+D   then BegTrace("NewLIBRARY: "); EdSymb(TrcBuf,Ident); OutTrace endif
      nLib.val:=nLib.val+1;
      if nLib.HI >= MxpBnk then CAPERR("Library-Table Overflow") endif;
      if LIBMAP(nLib.HI)=none
      then LIBMAP(nLib.HI):=NEWOBJ(size(RefBlock)) endif;
      Lib:=NEWOBJ(Size(LIBRARY)); Lib.Ident:=Ident; Lib.handle:=0;
      Lib.FstElt.val:=0;
      LIBMAP(nLib.HI).Elt(nLib.LO):=Lib;
      openAfile(lib,".lib");
      READ(Inpt,16,@Fhdr,n); if OsStat<>0 then ERROR("NewLIBRARY-1")
      elsif n<>16 then EndFile:=true endif; closeAfile(Lib,false);
%+D   if TrcSw > 0 then HexDump(0,16,Name(Fhdr)) endif;
      if Fhdr(0) qua Integer <> 240
      then ERROR("Bad Magic -- File is not a Library"); goto E2 endif;
      Lib.BlkRef.LO   := Fhdr(3) qua Integer;
      Lib.BlkRef.LOHI := Fhdr(4) qua Integer;
      Lib.BlkRef.HILO := Fhdr(5) qua Integer;
      Lib.BlkRef.HI   := Fhdr(6) qua Integer;
      Lib.nBlk.val:=0;
      Lib.nBlk.LO   := Fhdr(7) qua Integer;
      Lib.nBlk.LOHI := Fhdr(8) qua Integer;
--    Lib.nBlk.HILO := Fhdr(9) qua Integer;
--    Lib.nBlk.HI   := Fhdr(10) qua Integer;
%+D   if TrcSw > 0 then EdLib(TrcBuf,Lib) endif;
E2:end;
%title ***  LIB/OBJ file open and close  ***
routine checkOpen;
 import word id; infix(string) ext; unsigned code; export unsigned handle;
begin repeat while nOpen>14 -- allowing for the 5 standard files
      do closeLast endrepeat;
      handle:=Open(Id,ext,code);
      if EndFile then OpenErr(Id) endif; nOpen:=nOpen+1;
end;

routine openAfile; import ref(fileDescr) fd; infix(string) ext;
begin ref(fileDescr) f1;
%+D   if inpt<>0 then MODERR("openAfile") endif
      Inpt:=fd.handle; if Inpt<>0 then goto E1 endif
      Inpt:=checkOpen(fd.ident,ext,accread);
      fd.handle:=Inpt; fd.suc:=opChain; opChain:=fd;
E1:end

routine closeAfile; import ref(fileDescr) fd; boolean closeit;
begin ref(fileDescr) f1;
      if nOpen > 14 then closeit:=true endif;
      if closeit
      then if fd=opChain then opChain:=fd.suc
           else f1:=opChain;
                repeat while f1.suc<>fd do f1:=f1.suc endrepeat;
                f1.suc:=fd.suc;
           endif;
           Close(fd.handle); OsStat:=0;
           fd.handle:=0; nOpen:=nOpen-1; fd.suc:=none;
      endif;
      Inpt:=0;
end

routine closeLast;
begin ref(fileDescr) f1;
      f1:=opChain;
      repeat while f1.suc<>none do f1:=f1.suc endrepeat
      closeAfile(f1,true);
end;

routine openMOD; import ref(OBJMODULE) mod;
--- special routine because of locate ---
begin integer loc;
%+D   if inpt<>0 then MODERR("openMod-0") endif
      Inpt:=mod.handle;
      if Inpt=0 then openAfile(Mod,".obj");
      else LOCATE(Inpt,0,0,Loc);
%+D        if OsStat<>0 then MODERR("openMod-1") endif;
%+D        if loc <> 0  then MODERR("openMod-2") endif;
      endif;
end;

Routine OpenErr; import word Ident;
begin edint(edtbuf,nOpen); ed(edtbuf," open files"); outimage;
      repeat while opChain<>none
      do EdSymb(EdtBuf,opChain.Ident); ed(edtbuf," closed ..."); Outimage;
         closeAfile(opChain,true) endrepeat;
      if Srcf<>0
      then ed(edtbuf,"Parameter file closed ..."); Outimage;
           close(srcf) endif;
      if exefile<>0
      then EdSymb(EdtBuf,exefilnam); ed(edtbuf," closed ..."); Outimage;
           close(exefile) endif;
      if bnkfile<>0
      then EdSymb(EdtBuf,bnkfilnam); ed(edtbuf," closed ..."); Outimage;
           close(bnkfile) endif;
      TERMIN(3,"*** Simula linker terminated ***"); end;

%title ***  U T I L I T I E S  ***

%-D macro MODERR(1);
%-D begin
%-D       ERROR(%1);
%-D endmacro
%+D Routine MODERR; import infix(string) msg;
%+D begin
%+D       ERROR(msg);
%+D       Ed(EdtBuf,"    At Byte "); EdInt(EdtBuf,BytPos); Ed(EdtBuf," in ");
%+D       EdRecType(EdtBuf,RecTyp); Ed(EdtBuf,"(At Byte ");
%+D       EdInt(EdtBuf,RecPos); Ed(EdtBuf,") in Module ");
%+D       EdModid(EdtBuf,CurMod); OutImage;
%+D end;

Routine FindBank; import Word Ident; export Ref(BANK) Bnk;
begin Word i; i:=nBnk;
      repeat while i.val > 0
      do if BNKMAP(i.HI).Elt(i.LO) qua BANK.Ident=Ident
         then Bnk:=BNKMAP(i.HI).Elt(i.LO); goto E endif;
         i.val:=i.val-1;
      endrepeat;
      Bnk:=none;
E:end;

Routine FindGROUP; import Word Ident; export ref(GROUP) Grp;
begin Word i; i:=nGrp;
      repeat while i.val > 0
      do Grp:=GRPMAP(i.HI).Elt(i.LO); i.val:=i.val-1;
         if Grp.Ident=Ident then goto E1 endif;
      endrepeat;
      nGrp.val:=nGrp.val+1;
      if nGrp.HI >= MxpGrp then CAPERR("Group-Table Overflow") endif;
      if GRPMAP(nGrp.HI)=none
      then GRPMAP(nGrp.HI):=NEWOBJ(size(RefBlock)) endif;
      ALLOC(Grp,  Size(GROUP)); Grp.Ident:=Ident;
      Grp.Frm:=none; Grp.Start.val:=0;
      GRPMAP(nGrp.HI).Elt(nGrp.LO):=Grp;
E1:end;

Routine FindFRAME; import Word Ident; export ref(FRAME) Frm;
begin Word i; i:=nFrm;
      repeat while i.val > 0
      do Frm:=FRMMAP(i.HI).Elt(i.LO); i.val:=i.val-1;
         if Frm.Ident=Ident then goto E1 endif;
      endrepeat;
      nFrm.val:=nFrm.val+1;
      if nFrm.HI >= MxpFrm then CAPERR("Frame-Table Overflow") endif;
      if FRMMAP(nFrm.HI)=none
      then FRMMAP(nFrm.HI):=NEWOBJ(size(RefBlock)) endif;
      ALLOC(Frm,  Size(FRAME)); Frm.Ident:=Ident; Frm.Start.val:=0;
      FRMMAP(nFrm.HI).Elt(nFrm.LO):=Frm;
E1:end;

Routine FindModule; import Word Ident; export ref(OBJMODULE) Mod;
begin Word modx; modx:=nMod;
      repeat while modx.val > 0
      do Mod:=MODMAP(modx.HI).Elt(modx.LO);
         modx.val:=modx.val-1;
         if Mod.Ident=Ident then goto E1 endif;
      endrepeat;
      modx:=NewMODULE(Ident); if modx.val=0 then Mod:=none
      else Mod:=MODMAP(modx.HI).Elt(modx.LO);
           openMod(Mod); SCANNER(Mod); closeAfile(Mod,false);
      endif;
E1:end;


%title ***  Address Convertion ***
macro mem2abs(0);
begin case 0:MaxAddr (adx.Kind)
      when SegAddr: Seg:=CurMod.SegTab.Elt(adx.Segx.val-1);
           if Seg=none then adr.val:=0 else adr:=Seg.Start; endif;
      when GrpAddr: Grp:=CurMod.LgrTab.Elt(adx.Grpx.val-1);
%+C        if Grp=none then ERROR("Mem2Abs-2"); goto E2 endif;
%+C        if Grp.Frm=none then ERROR("Mem2Abs-3"); goto E3 endif;
           adr:=Grp.Frm.Start; adr.Ofst.val:=0;  -- ?????????
      when ExtAddr: xSmb:=CurMod.ExtTab.Elt(adx.Extx.val-1);
           Pub:=PUBREF(xSmb.HI).Elt(xSmb.LO); 
%+C        if Pub=none then ERROR("Mem2Abs-4"); goto E4 endif;
           if Pub.Seg=none then adr.val:=0
           else adr:=Pub.Seg.Start;
                adr.Ofst.val:=adr.Ofst.val+Pub.Ofst;
           endif;
      otherwise adr.val:=0 endcase;
      adr.Ofst.val:=adr.Ofst.val+adx.Ofst.val;
endmacro;

Routine Mem2AbsAddr;
import infix(MemAddr) adx; export Dword adr;
begin ref(SEGMENT) Seg; ref(GROUP) Grp; ref(PUBLIC) Pub; Word xSmb;
%+C   if CurMod=none then ERROR("Mem2Abs-0"); goto E1 endif;
%+D   if adx.Kind > MaxAddr then ERROR("Mem2Abs-1"); adx.Kind:=MaxAddr endif;
      mem2abs;
%+C E1:E2:E3:E4:
end;

Routine FAddr; --- Form FRAME Address from Frame index
import Byte Frmx; Integer Ea; export Dword a;
begin Integer Eb; a.Segm.LO:=Frmx; a.Segm.HI:=Ea/4096;
      Eb:=a.Segm.val; Eb:=Eb*16;
      if Eb > Ea
      then if a.Segm.HI <> 0 then a.Segm.HI:=a.Segm.HI-1 endif;
           Eb:=a.Segm.val; Eb:=Eb*16;
      endif;
      if Eb > Ea
      then Ed(ErrMsg,"FAddr("); EdWrd(ErrMsg,Frmx); 
           EdChar(ErrMsg,','); EdInt(ErrMsg,Ea); 
           ERROR(") Produces an Illegal Address"); Eb:=Ea;
      endif; a.Ofst.val:=Ea-Eb;
end;

Routine BAddr; --- Form FRAME Address from Base Address
import Word Base; Integer Ea; export Dword a;
begin Integer Eb; a.Segm:=Base; Eb:=Base.val; Eb:=Eb*16;
      if Eb > Ea
      then Ed(ErrMsg,"BAddr("); EdWrd(ErrMsg,Base.val); 
           EdChar(ErrMsg,','); EdInt(ErrMsg,Ea); 
           ERROR(") Produces an Illegal Address"); Eb:=Ea;
      endif; a.Ofst.val:=Ea-Eb;
end;

Routine EAddr; --- Form Effective Address
import Dword a; export Integer Ea;
begin Ea:=a.Segm.val; Ea:=(Ea*16)+a.Ofst.val end;

--- Routine EBase; --- Form Effective Base
--- import Dword a; export Integer Eb;
--- begin Eb:=a.Segm.val; Eb:=Eb*16 end;
%title ***   P r i n t / E d i t   O b j e c t   ***
Routine ShowBnk; import ref(BANK) Bnk;
begin Unsigned i; ref(FRAME) Frm;
      EdSegAddr(EdtBuf,Bnk.Start); Ed(EdtBuf,"  BANK  ");
      EdSymb(EdtBuf,Bnk.Ident);
      if Bnk.PrdBnk.nElt > 0
      then EdChar(EdtBuf,'(');
           i:=0; repeat while i < Bnk.PrdBnk.nElt
           do EdSymb(EdtBuf,Bnk.PrdBnk.Elt(i) qua BANK.Ident); i:=i+1;
              if i=Bnk.PrdBnk.nElt then EdChar(EdtBuf,')')
                                   else EdChar(EdtBuf,',') endif;
           endrepeat;
      endif;
      MovePos(EdtBuf,65); Ed(EdtBuf,"LENGTH: ");
      EdHex(EdtBuf,Bnk.Length,5); OutImage;
%+D   if Bnk.BnkDsc <> none
%+D   then SetPos(EdtBuf,24); Ed(EdtBuf,"(File:");
%+D        if    Bnk.Handle=ExeFile then EdSymb(EdtBuf,ExeFilNam)
%+D        elsif Bnk.Handle=BnkFile then EdSymb(EdtBuf,BnkFilNam)
%+D        else Ed(EdtBuf,"none") endif;
%+D        Ed(EdtBuf,",Txt="); EdInt(EdtBuf,Bnk.BnkDsc.TxtPos);
%+D        Ed(EdtBuf,",Rel="); EdInt(EdtBuf,Bnk.BnkDsc.RelPos);
%+D        EdChar(EdtBuf,')'); OutImage;
%+D   endif;
      Frm:=Bnk.FrmLnk;
      repeat while Frm <> none do ShowFrm(Frm); Frm:=Frm.Suc endrepeat;
      OutImage;
end;

%+D Routine ShowGrp; import ref(GROUP) Grp;
%+D begin Dword Start; ref(FRAME) x; x:=Grp.Frm;
%+D       if x=none then Start.val:=0 else Start:=x.Start endif; 
%+D       EdSegAddr(EdtBuf,Start); Ed(EdtBuf,"        ");
%+D       EdSymb(EdtBuf,Grp.Ident); OutImage;
%+D       if x=none then Ed(EdtBuf,"Empty"); OutImage
%+D       else repeat while x <> none
%+D            do ShowFrm(x); x:=x.GrpLnk endrepeat;
%+D       endif;
%+D end;

Routine ShowFrm; import ref(FRAME) Frm;
begin ref(GROUP) Grp; ref(SEGMENT) x; x:=Frm.first; Grp:=Frm.Grp;
      EdSegAddr(EdtBuf,Frm.Start); Ed(EdtBuf,"        ");
      EdSymb(EdtBuf,Frm.Ident);
      if Grp <> none
      then EdChar(EdtBuf,'('); EdSymb(EdtBuf,Grp.Ident);
           EdChar(EdtBuf,')');
      endif;
      showType(EdtBuf,Frm.cType);
      MovePos(EdtBuf,65);
      Ed(EdtBuf,"LENGTH:  "); EdHexWrd(EdtBuf,Frm.Length,4); OutImage;
      if x=none then Ed(EdtBuf,"Empty"); OutImage
      else repeat while x <> none
           do ShowSeg(x); x:=x.Suc endrepeat;
      endif;
end;

routine showType; import ref(EdBuff) F; byte cType;
begin case 0:3 (cType)
      when cSTACK: Ed(F,":STACK") when cDATA: Ed(F,":DATA")
      when cCODE:  Ed(F,":CODE")
      when cLINE:  Ed(F,if mergeLinBnk then ":LIN_CODE" else ":LINE")
      endcase;
end;

Routine ShowSeg; import ref(SEGMENT) Seg;
begin ref(OBJMODULE) Mod; Word modx;
      modx:=Seg.Modx; Mod:=MODMAP(modx.HI).Elt(modx.LO);
      EdSegAddr(EdtBuf,Seg.Start); -- Ed(EdtBuf,"               ");
      ed(edtbuf,"  "); edsymb(edtbuf,seg.ident); ed(edtbuf,":");
      EdModid(EdtBuf,Mod); MovePos(EdtBuf,65);
      Ed(EdtBuf,"LENGTH:  "); EdHexWrd(EdtBuf,Seg.Length,4); OutImage;
end;

%+D Routine ShowBlk; import ref(DATABLK) Blk;
%+D begin if TrcSw < 10 then HexDump(0,Blk.Lng,name(Blk.chr)) endif end;

%+D Routine ShowFileSize; import Unsigned h; infix(String) msg;
%+D begin integer CurLoc,LstLoc;
%+D       LOCATE(h,1,0,CurLoc); -- Get Current Location
%+D       LOCATE(h,2,0,LstLoc); -- Get Last Location
%+D       BegTrace(msg); Ed(TrcBuf," Pos: "); EdInt(TrcBuf,CurLoc);
%+D       Ed(TrcBuf," Size: "); EdInt(TrcBuf,LstLoc); OutTrace;
%+D       LOCATE(h,0,CurLoc,CurLoc); -- Set Current Location
%+D end;

%+D Routine ShowExeLab;
%+D begin Integer nFil;            -- Size of .EXE File (in Bytes)
%+D       Integer BnkLng;          -- Size of .BNK File (in Bytes)
%+D       Integer nMld;            -- Minimum Load Size (in Bytes)
%+D       Integer nTxt;            -- Size of Load Text Image (in Bytes)
%+D       Unsigned nHed;   -- Size of Header (in 16-Byte Paragraphs)
%+D       Unsigned pRel;   -- Start pos of Relocation Table
%+D       Unsigned pTxt;   -- Start pos of Load Text Image
%+D       Dword StckAdr;  -- Stack Address (initial SS:SP)
%+D       Dword StrtAdr;  -- Start Address (initial CS:IP)
%+D       nFil:=ExeLab.Lngp-1; nFil:=(nFil*512)+ExeLab.Nblp;
%+D       pRel:=ExeLab.Relo;
%+D       nHed:=ExeLab.Lngh; pTxt:=nHed; pTxt:=pTxt*16; nTxt:=nFil-pTxt;
%+D       nMld:=ExeLab.MinAlloc; nMld:=(nMld*16)+nTxt; BnkLng:=BnkFilLng;
%+D       StckAdr.Segm.val:=ExeLab.SS;  StrtAdr.Segm.val:=ExeLab.CS;
%+D       StckAdr.Ofst.val:=ExeLab.SP;  StrtAdr.Ofst.val:=ExeLab.IP;
%+D       Ed(EdtBuf,"Size of .EXE File (in Bytes)            ");
%+D       EdInt(EdtBuf,nFil); OutImage;
%+D       Ed(EdtBuf,"Size of .BNK File (in Bytes)            ");
%+D       EdInt(EdtBuf,BnkLng); OutImage;
%+D       Ed(EdtBuf,"Minimum Load Size (in Bytes)            ");
%+D       EdInt(EdtBuf,nMld); OutImage;
%+D       if LstSw > 0
%+D       then Ed(EdtBuf,"Size of Header (in 16-Byte Paragraphs)  ");
%+D            EdWrd(EdtBuf,nHed); OutImage;
%+D            Ed(EdtBuf,"Start Pos of Relocation Table           ");
%+D            EdWrd(EdtBuf,pRel); OutImage;
%+D            Ed(EdtBuf,"Number of Relocation Items              ");
%+D            EdWrd(EdtBuf,ExeLab.nRel); OutImage;
%+D            Ed(EdtBuf,"Start Pos of Load Text Image            ");
%+D            EdWrd(EdtBuf,pTxt); OutImage;
%+D            Ed(EdtBuf,"Size of Load Text Image (in Bytes)      ");
%+D            EdInt(EdtBuf,nTxt); OutImage;
%+D            Ed(EdtBuf,"Minimum Allocation (in Paragraphs)      ");
%+D            EdWrd(EdtBuf,ExeLab.MinAlloc); OutImage;
%+D            Ed(EdtBuf,"Maximum Allocation (in Paragraphs)      ");
%+D            EdWrd(EdtBuf,ExeLab.MaxAlloc); OutImage;
%+D            Ed(EdtBuf,"Stack Address (+Relocation)             ");
%+D            EdAbsAddr(EdtBuf,StckAdr); OutImage;
%+D            Ed(EdtBuf,"Start Address (+Relocation)             ");
%+D            EdAbsAddr(EdtBuf,StrtAdr); OutImage;
%+D       endif;
%+D end;

%+D Routine ShowBankInfo;
%+D begin Unsigned i; ref() x; infix(String) FilNam;
%+D       x:=Name2Ref(@BnkTab.Elt(0)); ShowBnkInf(x); x:=x+size(BankInfo);
%+D       i:=0; repeat i:=i+1 while i <= nBnk.val
%+D       do ShowBnkDsc(x);
%+D          x:=x+size(BankDescr:wOR(x qua BankDescr.nFrm,1));
%+D       endrepeat;
%+D       FilNam:=ASCIIZ2String(x,72); x:=x+size(ASCIIZ:FilNam.nchr+1);
%+D       Ed(TrcBuf,"ExeFilNam:"); Ed(TrcBuf,FilNam); OutTrace;
%+D       if BnkFile <> 0
%+D       then FilNam:=ASCIIZ2String(x,72); x:=x+size(ASCIIZ:FilNam.nchr+1);
%+D            Ed(TrcBuf,"BnkFilNam:"); Ed(TrcBuf,FilNam); OutTrace;
%+D       endif;
%+D       i:=0; repeat i:=i+1 while i <= nBnk.val
%+D       do FilNam:=ASCIIZ2String(x,72); x:=x+size(ASCIIZ:FilNam.nchr+1);
%+D          Ed(TrcBuf,"BankName:"); Ed(TrcBuf,FilNam); OutTrace;
%+D       endrepeat;
%+D end;

%+D Routine ShowBnkInf; import ref(BankInfo) x;
%+D begin Ed(EdtBuf,"***  BANK INFO TABLE  ***"); OutImage;
%+D       Ed(EdtBuf,"nBnk:");       EdWrd(EdtBuf,x.nBnk);
%+D       Ed(EdtBuf,", nNam:");     EdWrd(EdtBuf,x.nNam);
%+D       Ed(EdtBuf,", NamPos:");   EdWrd(EdtBuf,x.NamPos);
%+D       Ed(EdtBuf,", LinBnk:");   EdWrd(EdtBuf,x.LinBnk);
%+D       Ed(EdtBuf,", BnkLng:");   EdWrd(EdtBuf,x.BnkLng);
%+D       Ed(EdtBuf,", xGOTO:");    EdWrd(EdtBuf,x.xGOTO);
%+D       Ed(EdtBuf," xJMPF:");     EdWrd(EdtBuf,x.xJMPF);
%+D       Ed(EdtBuf," xCALL:");     EdWrd(EdtBuf,x.xCALL);
%+D       Ed(EdtBuf," xCALF:");     EdWrd(EdtBuf,x.xCALF); OutImage;
%+D end;

%+D Routine ShowBnkDsc; import ref(BankDescr) x;
%+D begin Integer i;
%+D       Ed(EdtBuf,"***  BANK DESCRIPTOR  ***"); OutImage;
%+D       Ed(EdtBuf,"fnam:"); EdWrd(EdtBuf,x.fnam);
%+D       Ed(EdtBuf,", bnam:"); EdWrd(EdtBuf,x.bnam);
%+D       Ed(EdtBuf,", InMem:"); if x.InMem
%+D       then Ed(EdtBuf,"True") else Ed(EdtBuf,"False") endif;
%+D       Ed(EdtBuf,", nFrm:");   EdWrd(EdtBuf,x.nFrm); OutImage;
%+D       Ed(EdtBuf,"MemBase:");  EdHexWrd(EdtBuf,x.MemBase.val,4);
%+D       Ed(EdtBuf,", TxtPos:"); EdInt(EdtBuf,x.TxtPos);
%+D       Ed(EdtBuf,", RelPos:"); EdInt(EdtBuf,x.RelPos);
%+D       Ed(EdtBuf,", Length:"); EdWrd(EdtBuf,x.Length); OutImage;
%+D       Ed(EdtBuf,"FrmBase:");
%+D       i:=0; repeat while i < x.nFrm
%+D       do if EdtBuf.Pos > 50 then OutImage; SetPos(EdtBuf,8) endif;
%+D          EdChar(EdtBuf,' '); EdHexWrd(EdtBuf,x.FrmBase(i).val,4); i:=i+1
%+D       endrepeat; OutImage;
%+D end;
%title ***   E D I T I N G   ***

macro EDFAST(1);
begin EdtBuf.chr(EdtBuf.pos):=%1; EdtBuf.pos:=EdtBuf.pos+1;
endmacro;

macro FASTUP(1);
begin %1 .nchr  :=EdtBuf.pos;
      %1 .chradr:= if EdtBuf.pos=0 then noname else @EdtBuf.chr;
      EdtBuf.pos:=0;
endmacro;

Routine EdSegAddr; import ref(EdBuff) F; Dword adr;
begin EdHex(F,EAddr(adr),5);
      EdChar(F,'('); EdAbsAddr(F,adr); EdChar(F,')');
end;

Routine EdAbsAddr; import ref(EdBuff) F; Dword adr;
begin EdHexWrd(F,adr.Segm.val,4); EdChar(F,':');
      EdHexWrd(F,adr.Ofst.val,4);
end;

Routine EdAddr; import ref(EdBuff) F; infix(MemAddr) adr;
begin case 0:MaxAddr (adr.Kind)
 when SegAddr: EdSymb(F,CurMod.SegTab.Elt(adr.Segx.val-1) qua SEGMENT.Ident);
 when GrpAddr: EdSymb(F,CurMod.LgrTab.Elt(adr.Grpx.val-1) qua GROUP.Ident);
 when ExtAddr: EdSymb(F,CurMod.ExtTab.Elt(adr.Extx.val-1));
 when NoAddr:  Ed(F,"NoAddr"); adr.Ofst.val:=0  endcase;
      if adr.Ofst.val<>0 then EdChar(F,'+'); EdWrd(F,adr.Ofst.val) endif
end;

Routine EdModid; import ref(EdBuff) F; ref(OBJMODULE) Mod;
begin Word libx; libx:=Mod.Libx;
      if Libx.val=0 then EdSymb(F,Mod.Ident)
      else EdSymb(F,LIBMAP(libx.HI).Elt(libx.LO) qua LIBRARY.Ident);
           if Mod.Ident.val=0 then EdChar(F,':'); EdHex(F,Mod.EltRef,4)
           else EdChar(F,'!'); EdSymb(F,Mod.Ident) endif;
      endif;
end;

%+D Routine EdLib; import ref(EdBuff) F; ref(LIBRARY) Lib;
%+D begin Ed(F,"LIBRARY: "); EdSymb(F,Lib.Ident); PrintOut(F);
%+D       Ed(F,"DIC Start Address:    "); EdHex(F,Lib.BlkRef.val,8);
%+D       Ed(F," = "); EdInt(F,Lib.BlkRef.val); PrintOut(F);
%+D       Ed(F,"Number of DIC Blocks: "); EdHex(F,Lib.nBlk.val,8);
%+D       Ed(F," = "); EdInt(F,Lib.nBlk.val); PrintOut(F);
%+D end;

%+D Routine EdRecType; import ref(EdBuff) F; Byte t;
%+D begin if t=110 then Ed(F,"RHEADR") elsif t=112 then Ed(F,"REGINT")
%+D    elsif t=114 then Ed(F,"REDATA") elsif t=116 then Ed(F,"RIDATA")
%+D    elsif t=118 then Ed(F,"OVLDEF") elsif t=120 then Ed(F,"ENDREC")
%+D    elsif t=122 then Ed(F,"BLKDEF") elsif t=124 then Ed(F,"BLKEND")
%+D    elsif t=126 then Ed(F,"DEBSYM") elsif t=128 then Ed(F,"THEADR")
%+D    elsif t=130 then Ed(F,"LHEADR") elsif t=132 then Ed(F,"PEDATA")
%+D    elsif t=134 then Ed(F,"PIDATA") elsif t=136 then Ed(F,"COMENT")
%+D    elsif t=138 then Ed(F,"MODEND") elsif t=140 then Ed(F,"EXTDEF")
%+D    elsif t=142 then Ed(F,"TYPDEF") elsif t=144 then Ed(F,"PUBDEF")
%+D    elsif t=146 then Ed(F,"LOCSYM") elsif t=148 then Ed(F,"LINNUM")
%+D    elsif t=150 then Ed(F,"LNAMES") elsif t=152 then Ed(F,"SEGDEF")
%+D    elsif t=154 then Ed(F,"GRPDEF") elsif t=156 then Ed(F,"FIXUPP")
%+D                                    elsif t=160 then Ed(F,"LEDATA")
%+D    elsif t=162 then Ed(F,"LIDATA") elsif t=164 then Ed(F,"LIBHED")
%+D    elsif t=166 then Ed(F,"LIBNAM") elsif t=168 then Ed(F,"LIBLOC")
%+D    elsif t=170 then Ed(F,"LIBDIC") else EdHex(F,t,2); Ed(F,"H=????") endif;
%+D end;

%title ***  A l l o c a t e   B a n k  ***

Routine AllocBnk; import ref(BANK) Bnk;
begin Word Base; Unsigned i,Align,nFrmx; Integer MemPos,mm;
      ref(BANK) Prd; ref(GROUP) Grp; ref(FRAME) Frm; ref(SEGMENT) Seg;
      ref(BankDescr) BnkDsc;
      if Bnk.Allocated then goto E endif;
      Bnk.Allocated:=true; MemPos:=TabLng; i:=Bnk.PrdBnk.nElt;
      BnkDsc:=Bnk.BnkDsc; nFrmx:=0;
%+D   if AtrSw > 0
%+D   then AllocTrace(MemPos,EAddr(Bnk.Start),Bnk.Length,
%+D                  " Begin Allocate Bank ",Bnk.Ident);
%+D        if AtrSw > 1 then ShowBnk(Bnk) endif;
%+D   endif;
      if i=0
      then if Bnk <> RotBnk
           then ERROR("More than one Root Bank") endif;
      endif;
      repeat while i > 0
      do i:=i-1; Prd:=Bnk.PrdBnk.Elt(i); AllocBnk(Prd);
         mm:=EAddr(Prd.Start) + Prd.Length;
         if mm > MemPos then MemPos:=mm endif;
%+D      if AtrSw > 0
%+D      then AllocTrace(MemPos,EAddr(Prd.Start),Prd.Length,
%+D                     "                Pred ",Prd.Ident);
%+D      endif;
      endrepeat;
      if Bnk=RotBnk then MemPos:=((MemPos+1)/2)*2; BnkDsc.MemBase.val:=0;
      else MemPos:=((MemPos+15)/16)*16; BnkDsc.MemBase.val:=MemPos/16 endif;
      Bnk.Start:=FAddr(NextFrmx,MemPos);
      if Bnk.Extern
      then
           -- ... NB: TRACE
           -- ... NB: TRACE
           -- ... NB: TRACE
           NextFrmx:=NextFrmx+Bnk.nFrmx;
           if NextFrmx > 255 then ERROR("Too Many Frames") endif;
           -- ... ... ...
           -- ... ... ...
           -- ... ... ...
           -- ... ... ...
      else Frm:=Bnk.FrmLnk;
           repeat while Frm <> none
           do Grp:=Frm.Grp;
              if Grp <> none
              then if Grp.Start.val=0 ---- Grp.Start.Kind=NoAddr    ????????
                   then Grp.Start:=FAddr(NextFrmx,MemPos);
                        FrmTab(NextFrmx):=Frm;
                        BnkDsc.FrmBase(nFrmx):=Grp.Start.Segm;
                        NextFrmx:=NextFrmx+1; nFrmx:=nFrmx+1;
                   endif;
                   Base:=Grp.Start.Segm; Frm.Start:=BAddr(Base,MemPos)
              else Frm.Start:=FAddr(NextFrmx,MemPos); FrmTab(NextFrmx):=Frm;
                   NextFrmx:=NextFrmx+1; Base:=Frm.Start.Segm;
                   BnkDsc.FrmBase(nFrmx):=Base; nFrmx:=nFrmx+1;
              endif;
              Frm.Length:=0; Seg:=Frm.first;
%+D           if AtrSw > 0
%+D           then AllocTrace(MemPos,EAddr(Frm.Start),Frm.Length,
%+D                          "       Frame         ",Frm.Ident);
%+D           endif;
              if Seg <> none
              then repeat while Seg <> none
                   do Align:=Seg.Align;
                      if    Align=1 then -- nothing ;
                      elsif Align=2 then MemPos:=((MemPos+1)/2)*2
                      elsif Align=3 then MemPos:=((MemPos+15)/16)*16
                      elsif Align=4 then MemPos:=((MemPos+511)/512)*512
                      else ERROR("Alignment is not supported") endif;
                      Seg.Start:=BAddr(Base,MemPos);
                      MemPos:=MemPos+Seg.Length;
%+D                   if AtrSw > 0
%+D                   then AllocTrace(MemPos,EAddr(Seg.Start),Seg.Length,
%+D                                  "             Segment ",Seg.Ident);
%+D                   endif;
                      Seg:=Seg.Suc;
                   endrepeat;
                   Frm.Start:=Frm.first.Start;
                   Frm.Length:=MemPos-EAddr(Frm.Start);
                   if NextFrmx > 255 then ERROR("Too Many Frames") endif;
%+D                if AtrSw > 0
%+D                then AllocTrace(MemPos,EAddr(Frm.Start),Frm.Length,
%+D                               "   End Frame         ",Frm.Ident);
%+D                endif;
              endif;
              Frm:=Frm.Suc;
           endrepeat;
      endif;
      Bnk.Length:=MemPos-EAddr(Bnk.Start); MemPos:=((MemPos+15)/16)*16;
      BnkDsc.Length:=(Bnk.Length+15)/16;  --- ?????????
      if MemPos > Total then Total:=MemPos endif;
      if Bnk <> RotBnk
      then BnkDsc.TxtPos:=BnkFilLng;
           BnkFilLng:=BnkFilLng+Bnk.Length;
      endif;
%+D   if AtrSw > 0
%+D   then AllocTrace(MemPos,EAddr(Bnk.Start),Bnk.Length,
%+D                  " End   Allocate Bank ",Bnk.Ident);
%+D        if AtrSw > 1 then ShowBnk(Bnk) endif;
%+D   endif;
E:end;

%+D Routine AllocTrace; 
%+D import Integer MemPos,Start,Lng;
%+D        infix(String) ms; Word id;
%+D begin BegTrace("MemPos="); EdInt(TrcBuf,MemPos); Ed(TrcBuf,ms);
%+D       EdSymb(TrcBuf,id); Ed(TrcBuf,", Start="); EdInt(TrcBuf,Start);
%+D       Ed(TrcBuf,", Lng="); EdInt(TrcBuf,Lng);
%+D       Ed(TrcBuf,", Total="); EdInt(TrcBuf,Total); OutTrace;
%+D end;
%title ***  Insert Segment into Bank  ***
Routine InsertSegment; import ref(SEGMENT) Seg; ref(BANK) Bnk;
begin Unsigned i; ref(FRAME) Frm,x,y; Byte c;
      if Seg.Frm <> none
      then Ed(EdtBuf,"*** WARNING *** "); EdModid(EdtBuf,CurMod);
           EdChar(EdtBuf,':'); EdSymb(EdtBuf,Seg.Ident);
           if Seg.Frm.Bnk = none
           then Ed(EdtBuf," Already Included in this Bank")
           else Ed(EdtBuf," Already Included in Bank ");
                EdSymb(EdtBuf,Seg.Frm.Bnk.Ident);
           endif; OutImage;
      else Frm:=FindFRAME(Seg.Ident);
           -- Include Logical Segment (Seg) into Frame (Frm) --
           if Frm.first <> none then Frm.last.Suc:=Seg; Frm.last:=Seg;
           else Frm.first:=Frm.last:=Seg; Frm.cType:=Seg.cType endif;
           Seg.Suc:=none; Seg.Frm:=Frm;
           if Seg.cType=cSTACK
           then if StackFrm=none then StackFrm:=Frm
                else ERROR("More than one Stack Segment") endif;
           endif;
           -- Check if Frame should be Placed in RotBnk or LinBnk --
           if    Frm.cType = cCODE then -- OK
           elsif Frm.cType = cLINE
           then if LinBnk=none
                then LinBnk:=NewBANK(Size(BANK),DICDEF("{LINMAP}"),1);
                     LinBnk.PrdBnk.Elt(0):=RotBnk;
                endif; Bnk:=LinBnk;
           else Bnk:=RotBnk endif;
           -- Check if Frame is already Placed in another Bank --
           if (Frm.Bnk <> none) and (Frm.Bnk <> Bnk)
           then Ed(EdtBuf,"*** WARNING *** "); EdSymb(EdtBuf,Seg.Ident);
                Ed(EdtBuf," Already Part of Bank ");
                EdSymb(EdtBuf,Frm.Bnk.Ident); OutImage;
           endif;
           if Frm.Bnk = none
           then -- Place Frame (Frm) in Bank (Bnk) --
                x:=Bnk.FrmLnk; c:=Frm.cType;
                if x=none then Bnk.FrmLnk:=Frm elsif Frm.Grp=none
                then if c < x.cType then Bnk.FrmLnk:=Frm; Frm.Suc:=x;
                     else L1: y:=x; x:=x.Suc; if x=none then y.Suc:=Frm
                          elsif c < x.cType then Frm.Suc:=x; y.Suc:=Frm
                          else goto L1 endif;
                     endif;
                elsif c <= x.cType then Bnk.FrmLnk:=Frm; Frm.Suc:=x;
                else L2: y:=x; x:=x.Suc; if x=none then y.Suc:=Frm
                     elsif c <= x.cType then Frm.Suc:=x; y.Suc:=Frm
                     else goto L2 endif;
                endif; Frm.Bnk:=Bnk;
           endif;
      endif;
end;
%page

Routine InsertAllSeg; import ref(OBJMODULE) Mod; ref(BANK) Bnk;
begin ref(SEGMENT) Seg; Unsigned segx; segx:=0;
      repeat while segx < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(segx); segx:=segx+1;
         if (Seg.Length>0) and (Seg.Frm=none)
         then InsertSegment(Seg,Bnk) endif;
      endrepeat;
end;

Routine ChkInsert; import ref(OBJMODULE) Mod;
begin Unsigned segx; ref(BANK) Bnk; ref(FRAME) Frm; ref(SEGMENT) Seg;
      segx:=0; repeat while segx < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(segx); segx:=segx+1; Bnk:=none;
         if Seg.Length>0
         then Frm:=Seg.Frm; if Frm <> none then Bnk:=Frm.Bnk endif;
              if Bnk = none
              then Ed(ErrMsg,"Segment "); EdSymb(ErrMsg,Seg.Ident);
                   EdChar(ErrMsg,'('); EdModid(ErrMsg,Mod);
                   ERROR(") Not Included"); InsertSegment(Seg,RotBnk);
              endif;
         endif;
      endrepeat;
end;
%title ***   M A K E   B A N K   I N F O   T A B L E   ***

--- In case LineBank is the only bank, and mergeLinBnk is true, this
--- bank shall be inmcluded in the exefile instead.

Routine MakeBankInfoTable;
begin Unsigned i,nNam,nFrmx,ExeNamPos,FilNamPos; Word w;
      ref(BANK) Bnk; ref(GROUP) Grp;
      ref(FRAME) Frm; infix(String) FilNam;
      ref() x; ref(BankInfo) BnkInf; ref(BankDescr) BnkDsc;
      ref(ASCIIZ) Nam;
      Integer Root;

      if mergeLinBnk
      then if nBnk.val=2 then merge else mergeLinBnk:=false endif endif
      DefPUBLIC(sBNKTAB,none,0); -- S@BNKTAB=0000:0000+Reloc
      TabLng:=Size2Int(Size(BankInfo));
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         Frm:=Bnk.FrmLnk; nFrmx:=0;
         repeat while Frm <> none
         do Grp:=Frm.Grp;
            if Grp = none then nFrmx:=nFrmx+1
            elsif Grp.Frm=Frm then nFrmx:=nFrmx+1 endif;
            Frm:=Frm.Suc;
         endrepeat;
         Bnk.FrmPos:=TabLng+Size2Int(Size(BankDescr:wOR(0,1)));
         Bnk.nFrmx:=nFrmx;
         TabLng:=TabLng+Size2Int(Size(BankDescr:wOR(nFrmx,1)));
      endrepeat;

      --- Add Size of all ASCIIZ file/bank names
      nNam:=1; ExeNamPos:=TabLng;
      EdSymb(EdtBuf,ExeFilNam); FilNam:=PickUp(EdtBuf);
      TabLng:=TabLng+Size2Int(Size(ASCIIZ:FilNam.nchr+1)); -- .exe File
      if BnkFile <> 0
      then nNam:=nNam+1; FilNamPos:=TabLng;
           EdSymb(EdtBuf,BnkFilNam); FilNam:=PickUp(EdtBuf);
           TabLng:=TabLng+Size2Int(Size(ASCIIZ:FilNam.nchr+1)); -- .bnk
      endif;
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; nNam:=nNam+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         FilNam:=DICREF(Bnk.Ident);
         TabLng:=TabLng+Size2Int(Size(ASCIIZ:FilNam.nchr+1)); -- BnkName
      endrepeat;

      BnkTab:=NewWrdVector((TabLng+1)/2); x:=Name2Ref(@BnkTab.Elt(0));

      BnkInf:=x; x:=x+size(BankInfo); --- First
      BnkInf.nBnk:=nBnk.val; BnkInf.nNam:=nNam;
      BnkInf.NamPos:=ExeNamPos; BnkInf.LinBnk:=0;
      BnkInf.xGOTO:=xGOTO; BnkInf.xJMPF:=xJMPF;
      BnkInf.xCALL:=xCALL; BnkInf.xCALF:=xCALF;

      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         Frm:=Bnk.FrmLnk; nFrmx:=0;
         repeat while Frm <> none
         do Grp:=Frm.Grp;
            if Grp = none then nFrmx:=nFrmx+1
            elsif Grp.Frm=Frm then nFrmx:=nFrmx+1 endif;
            Frm:=Frm.Suc;
         endrepeat;
         BnkDsc:=x; Bnk.BnkDsc:=x;
         if Bnk=LinBnk then BnkInf.LinBnk:=Size2Int(BnkDsc-BnkInf) endif
         x:=x+size(BankDescr:wOR(nFrmx,1)); BnkDsc.nFrm:=nFrmx;
         if Bnk=RotBnk then BnkDsc.fnam:=ExeNamPos; BnkDsc.InMem:=True;
         else BnkDsc.fnam:=FilNamPos; BnkDsc.InMem:=False endif;
      endrepeat;

      --- Fill in File Names ---
      EdSymb(EdtBuf,ExeFilNam); EDFAST(0 qua Character);
      FilNam:=PickUp(EdtBuf); Nam:=x; x:=x+size(ASCIIZ:FilNam.nchr);
      APX_SMOVEI(FilNam.nchr,Ref2Name(Nam),FilNam.chradr);
      if BnkFile <> 0
      then EdSymb(EdtBuf,BnkFilNam); EDFAST(0 qua Character);
           FilNam:=PickUp(EdtBuf); Nam:=x; x:=x+size(ASCIIZ:FilNam.nchr)
           APX_SMOVEI(FilNam.nchr,Ref2Name(Nam),FilNam.chradr);
      endif;

      --- Fill in Bank Names ---
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnk:=BNKMAP(w.HI).Elt(w.LO);
         EdSymb(EdtBuf,Bnk.Ident); EDFAST(0 qua Character);
         FilNam:=PickUp(EdtBuf); Nam:=x; x:=x+size(ASCIIZ:FilNam.nchr);
         APX_SMOVEI(FilNam.nchr,Ref2Name(Nam),FilNam.chradr);
         Bnk.BnkDsc.bnam:=Size2Int(Nam-BnkInf);
      endrepeat;

%+D   if AtrSw > 1 then ShowBankInfo endif;
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; AllocBnk(BNKMAP(w.HI).Elt(w.LO)) endrepeat;
%+D   if AtrSw > 1 then MapListing endif;
      Root:=(((TabLng+1)/2)*2)+RotBnk.Length;
      BnkInf.BnkLng:=((Total+15)/16) - ((Root+15)/16);
      --- set bnklng non-zero to avoid LOAD HIGH !!!!! ---
      if BnkInf.BnkLng = 0 then if mergeLinBnk
      then BnkInf.BnkLng:=1 endif endif
%+D   if AtrSw > 1 then ShowBankInfo endif;
end;

routine merge;
begin ref(FRAME) Frm,x,y;
      Frm:= LinBnk.FrmLnk;
      --- move frames from LinBnk to RotBnk
      x:=RotBnk.FrmLnk;
      repeat y:=x; x:=x.suc while x<>none do endrepeat;
      y.suc:=Frm;
      --- adjust Frm.Bnk
      repeat while Frm<>none do Frm.Bnk:=RotBnk; Frm:=Frm.suc endrepeat;
      --- adjust root length
      RotBnk.length:= EAddr(LinBnk.Start)+LinBnk.length-EAddr(RotBnk.Start);
      --- remove LinBnk
      BNKMAP(nBnk.HI).Elt(nBnk.LO):=none; nBnk.val:=1; LinBnk:=none;
end;

%title ***  B A S I C    O B J - C O D E    I N P U T  ***

macro InitObjCode(0);
begin InCbuffer; RecLast:=0 endmacro;

Routine InCbuffer;
begin Unsigned k;
      READ(Inpt,BufLng,%@CBUF.chr%,k);
      if OsStat <> 0 then MODERR("inCbuffer") endif;
      if k < BufLng then CBUF.byt(k):=0 endif;
      CBUF.nxt:=0; curClng:=BufLng;
end;

Macro InByte(1);
begin
%+D   ChkSum:=ChkSum+CBUF.byt(CBUF.nxt); --- ChkSum:=(ChkSum+ ..) rem 256;
      %1:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%+D   BytPos:=BytPos+1;
endmacro;

%-D macro skiprecord(0);
%-D begin CBUF.nxt:=RecLast endmacro;

%+D Routine SkipRecord;
%+D                 import byte typ; -- type of current record
%+D begin Integer Loc; Byte b;
%+D   if TrcSw > 3
%+D   then if (RecLast-CBUF.nxt) > 1
%+D        then OutTrace; Ed(TrcBuf,"*** "); EdWrd(TrcBuf,RecLast-CBUF.nxt-1);
%+D             Ed(TrcBuf," Bytes Skipped"); OutTrace;
%+D        endif;
%+D        if TrcSw <> typ then goto nodump endif;
%+D        repeat while CBUF.nxt < RecLast
%+D        do if TrcBuf.Pos > 63 then OutTrace endif;
%+D           EdChar(TrcBuf,' '); InByte(%b%); EdHex(TrcBuf,b,2);
%+D        endrepeat;
%+D        ChkSum:=0;   --- Bypass ChkSum Testing
%+D   else --- Locate Next Record ---
%+D   nodump:
%+D            CBUF.nxt:=RecLast;
%+D        ChkSum:=0; --- Bypass ChkSum Testing
%+D   endif;
%+D end;

Routine ScanData; import Unsigned Lng; export Ref(DATABLK) Blk;
begin Unsigned Rst,j,k;
      NewDATABLK; Blk.Lng:=Lng; Blk.Ofst:=0; j:=0;
%+D   BytPos:=BytPos+Lng;
      APX_SMOVEI(Lng,@Blk.chr,@CBUF.chr(CBUF.nxt));
      CBUF.nxt:=CBUF.nxt+Lng;
%+D   if CBUF.nxt >= RecLast then MODERR("ScanData-1"); endif;
%+D   if TrcSw > 3 then ShowBlk(Blk) endif;
end;

Macro ScanByte(2);
begin
%-D   --- InByte-call expanded ---
%-D   %1:=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%+D   %1:=DoScanByte(%2);
endmacro;
%+D Routine DoScanByte;
%+D import infix(string) id;
%+D export Byte n;
%+D begin InByte(%n%);
%+D       if TrcSw > 2
%+D       then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D            EdChar(TrcBuf,':'); EdHex(TrcBuf,n,2);
%+D       endif;
%+D end;

Macro ScanIndex(2);
begin
%-D   %1 .val :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   if %1 .val>127
%-D   then %1 .HI:=%1 .LO-128;
%-D        %1 .LO :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   endif;
%+D   %1:=DoScanIndex(%2);
endmacro;
%+D Routine DoScanIndex;
%+D import infix(string) id;
%+D export Word w;
%+D begin InByte(%w.val%);
%+D   if w.val>127 then w.HI:=w.LO-128; InByte(%w.LO%) endif;
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdWrd(TrcBuf,w.val);
%+D   endif;
%+D end;

Macro ScanName(2);
begin InByte(%scannn%);
      if scannn=0 then %1 .val:=0;
%-D   else scanns.chradr:=@CBUF.chr(CBUF.nxt); CBUF.nxt:=CBUF.nxt+scannn;
%-D        scanns.nchr:=scannn;
%-D        %1:=DICDEF(scanns);
%+D   else %1:=DoScanName(scannn,%2);
      endif
endmacro

%+D Routine DoScanName;
%+D import byte n; infix(string) id;
%+D export Word res;
%+D begin Byte c; infix(string) s;
%+D       repeat while n <> 0
%+D       do n:=n-1; InByte(%c%); EDFAST(c qua character) endrepeat;
%+D       s:=PickUp(EdtBuf); res:=DICDEF(s);
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdSymb(TrcBuf,res);
%+D   endif
%+D end;

Macro ScanWord(2);
begin
%-D   %1 .LO :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%-D   %1 .HI :=CBUF.byt(CBUF.nxt); CBUF.nxt:=CBUF.nxt+1;
%+D  %1:=DoScanWord(%2);
endmacro;
%+D Routine DoScanWord;
%+D import infix(string) id;
%+D export Word w;
%+D begin InByte(%w.LO%); InByte(%w.HI%);
%+D   if TrcSw > 2
%+D   then EdChar(TrcBuf,' '); Ed(TrcBuf,id);
%+D        EdChar(TrcBuf,':'); EdWrd(TrcBuf,w.val);
%+D   endif;
%+D end;
%title ***  B A S I C    R E L - C O D E    O U T P U T  ***

routine writeRel;
--- Note: curHandle and curFpos are implicit parameters
---       curFpos is updated
import name() imaddr; Unsigned lng;
begin ref(relbuffer) RBUF,r1,r2;
      if lng<>0
      then
         RBUF:=RBUFr;
         repeat while RBUF<>none
         do if RBUF.curpos=curFpos
            then if RBUF.handle=curHandle
                 then if (RBUF.filled+lng) > RelBufLng
                      then exhaustRel(RBUF); goto M1 endif;
                      --- move into buffer ---
                      APX_SMOVEI(lng,name(RBUF.byt(RBUF.filled)),
                                     imaddr qua name(character));
                      RBUF.filled:=RBUF.filled+lng;
                      goto M2;
                 endif
            endif
            RBUF:=RBUF.suc
         endrepeat;
         --- get free buffer ---
         if freeRbuf=none
         then sort;
              RBUF:=RBUFr; r1:=none;
              repeat r2:=RBUF.suc while r2<>none
              do if RBUF.curpos=r2.filpos then if RBUF.handle=r2.handle
                 then if (RBUF.filled+r2.filled)<RelBufLng
                      then APX_SMOVEI(r2.filled,name(RBUF.byt(RBUF.filled)),
                                                name(r2.byt));
                           RBUF.filled:=RBUF.filled+r2.filled;
                           RBUF.curpos:=RBUF.curpos+r2.filled;
                           RBUF.suc:=r2.suc; r2.suc:=freeRbuf; freeRbuf:=r2
                      else exhaustRel(RBUF);
                           RBUF.suc:=freeRbuf; freeRbuf:=RBUF; RBUF:=r2;
                           if r1=none then RBUFr:=r2 else r1.suc:=r2 endif;
                      endif
                 else r1:=RBUF; RBUF:=r2 endif else r1:=RBUF; RBUF:=r2 endif
              endrepeat;
              if freeRbuf=none
              then RBUF:=RBUFr.suc; RBUFr.suc:=RBUF.suc;
                   exhaustRel(RBUF); goto M0 endif;
         endif
         RBUF:=freeRbuf; freeRbuf:=freeRbuf.suc;
   M0:   RBUF.suc:=RBUFr; RBUFr:=RBUF;
         --- set fresh buffer ---
   M1:   RBUF.handle:=curHandle; RBUF.filPos:=curFpos; RBUF.filled:=lng;
         --- move into buffer ---
         APX_SMOVEI(lng,name(RBUF.byt),imaddr qua name(character));
   M2:   curFpos:=curFpos+lng; RBUF.curpos:=curFpos;
      endif;
end;

routine sort;
begin ref(RelBuffer) RB,r1,r2;
      r2:=none;
      repeat while RBUFr<>none
      do RB:=RBUFr; r1:=RB;
         repeat r1:=r1.suc while r1<>none
         do if r1.filpos>RB.filpos
            then if r1.handle=RB.handle then RB:=r1 endif endif endrepeat;
         if RB=RBUFr then RBUFr:=RB.suc
         else r1:=RBUFr; repeat while r1.suc<>RB do r1:=r1.suc endrepeat;
              r1.suc:=RB.suc
         endif;
         RB.suc:=r2; r2:=RB
      endrepeat;
      RBUFr:=r2;
end;

routine exhaustAll; -- output buffers in order
begin ref(RelBuffer) RB;
      sort;
      repeat RB:=RBUFr while RB<>none
      do exhaustRel(RB);
         RBUFr:=RB.suc; RB.suc:=freeRbuf; freeRbuf:=RB endrepeat
end;

routine exhaustRel; import ref(relBuffer) RBUF;
begin integer loc,n;
      if RBUF.handle=0 then elsif RBUF.filled=0 then
      else --- Set File Location ---
%+D        if AtrSw > 0
%+D        then BegTrace("Exhaust: Handle="); EdWrd(TrcBuf,RBUF.Handle);
%+D             Ed(TrcBuf,", FilePos="); EdInt(TrcBuf,RBUF.filpos);
%+D             Ed(TrcBuf,", Filled="); EdInt(TrcBuf,RBUF.Filled); OutTrace
%+D        endif;
           if curWhandle=RBUF.handle then if curWpos=RBUF.filpos
           then goto W1 endif endif;
           curWhandle:=RBUF.handle;
           LOCATE(curWhandle,0,RBUF.FilPos,curWpos);
           if OsStat <> 0 then MODERR("exhaust-1"); OsStat:=0;
           elsif curWpos <> RBUF.FilPos then MODERR("exhaust-2") endif;
           --- Write Buffer to File ---
      W1:  WRITE(curWhandle,RBUF.filled,@RBUF.byt,n);
           if OsStat <> 0 then MODERR("exhaust-3"); OsStat:=0;
           elsif n <> RBUF.filled then MODERR("exhaust-4") endif;
           curWpos:=curWpos+n;
      endif;
      RBUF.filpos:=0; RBUF.curpos:=0; RBUF.filled:=0; RBUF.handle:=0;
end;
      
%title ***    L o g i c a l    A d d r e s s    ***
routine notImplFrameAddr;
begin
%+D   word UnUsed;
      ERROR("Address with FrameNumber -- Not supported");
%+D   ScanWord(UnUsed,"FrameNumber");  -- ERROR terminates otherwise
end;

Routine ScanLogicalAddr; export infix(MemAddr) Adr;
begin Byte n,TARGT,FRAM,Pbit,Tbit,Fbit; Word UnUsed; infix(MemAddr) FrmAdr;
%+C   Dword a1,a2; boolean Fchk; Fchk:=false;
      InByte(%n%);              TARGT:=bAND(n,3);
%+D   Pbit:=bAND(bSHR(n,2),1);  Tbit:=bAND(bSHR(n,3),1);
%+D   FRAM:=bAND(bSHR(n,4),7);  Fbit:=bAND(bSHR(n,7),1);
%+D   if TrcSw > 3
%+D   then OutTrace; SetPos(TrcBuf,10);
%+D        Ed(TrcBuf,"<F:");      EdWrd(TrcBuf,Fbit);
%+D        Ed(TrcBuf," FRAME:");  EdWrd(TrcBuf,FRAM);
%+D        Ed(TrcBuf," T:");      EdWrd(TrcBuf,Tbit);
%+D        Ed(TrcBuf," P:");      EdWrd(TrcBuf,Pbit);
%+D        Ed(TrcBuf," TARGT:");  EdWrd(TrcBuf,TARGT);
%+D   endif;
%-D   FRAM:=bAND(bSHR(n,4),7);  -- Fbit:=bAND(bSHR(n,7),1);
      if n > 127 then FrmAdr:=ImpFrame(FRAM);
%+C                                           Fchk:=true;
      elsif FRAM < 4
      then FrmAdr.kind:=FRAM; FrmAdr.Ofst.val:=0;
%+C        Fchk:=true;
           case 0:3 (FRAM)
           when SegAddr: ScanIndex(FrmAdr.Segx,"Segx")
           when GrpAddr: ScanIndex(FrmAdr.Grpx,"Grpx")
           when ExtAddr: ScanIndex(FrmAdr.Extx,"Extx")
           otherwise notImplFrameAddr endcase;
      endif;
%-D   if bAND(n,8) = 0
%+D   if Tbit      = 0
      then Adr.kind:=TARGT;
           case 0:3 (TARGT)
           when SegAddr: ScanIndex(Adr.Segx,"Segx")
           when GrpAddr: ScanIndex(Adr.Grpx,"Grpx")
           when ExtAddr: ScanIndex(Adr.Extx,"Extx")
           otherwise notImplFrameAddr endcase;
      else Adr:=ImpTarget(TARGT); endif;
%-D   if bAND(n,4) = 0
%+D   if Pbit      = 0
      then
           ScanWord(Adr.Ofst,"Disp");
      else Adr.Ofst.val:=0 endif;
--- E1:E2:E3:E4:
%+D   if CBUF.nxt>=RecLast then MODERR("LogicalAddr") endif;
%+D   if TrcSw > 3 then EdChar(TrcBuf,'>'); OutTrace endif;
%+C   if Fchk 
%+C   then a1:=Mem2AbsAddr(FrmAdr); a2:=Mem2AbsAddr(Adr);
%+C        if a1.Segm <> a2.Segm
%+C        then EdAddr(ErrMsg,Adr); EdChar(ErrMsg,'=');
%+C             EdAbsAddr(ErrMsg,a2); Ed(ErrMsg," not in Frame(");
%+C             EdAddr(ErrMsg,FrmAdr); EdChar(ErrMsg,'=');
%+C             EdAbsAddr(ErrMsg,a1); MODERR(") -- Fixup Failed");
%+C        endif;
%+C   endif;
end;
%title ***   THEADR / LNAMES / COMENT / LINNUM   ***

Routine THEADR; import ref(OBJMODULE) Mod;
begin Word s;
      --- used by macro scanName ---
      byte scannn; infix(string) scanns;
%+D   scanStat(0):=scanStat(0)+1;
      ScanName(s,"ModuleName");
      if Mod.Libx.val <> 0 then Mod.Ident:=s endif;
end; 

Routine LNAMES;
begin Word nam; unsigned last;
      --- used by macro scanName ---
      byte scannn; infix(string) scanns;
%+D   Byte p; p:=TrcBuf.Pos;
%+D   scanStat(4):=scanStat(4)+1;
      last:=RecLast-1; repeat while CBUF.nxt < last
      do
%+D      if TrcBuf.Pos>50 then OutTrace; SetPos(TrcBuf,p) endif;
         nNam.val:=nNam.val+1;
         if nNam.HI >= MxpNam then CAPERR("Name-Table Overflow") endif;
         if NamTab(nNam.HI)=none
         then NamTab(nNam.HI):=NEWOBJ(size(WrdBlock)) endif;
         ScanName(nam,"Name");
         NamTab(nNam.HI).Elt(nNam.LO):=nam;
      endrepeat;
end;

--- NOTE! under OS/2 COMENT fields with CLS 160 are used for dynamic
---       linking. We don't handle that (new EXE hdr format is NOT
---       implemented). Therefore, COMENTs are ALWAYS skipped !!!!!!

%+D Routine COMENT;
%+D begin Unsigned n,NP,NL,CLS;
%+D   scanStat(1):=scanStat(1)+1;
%+D       InByte(%n%); -- FORMAT: <NP>1<NL>1<-->6 <CLS>8
%+D       NL:=bAND(bSHR(n,6),1); NP:=bAND(bSHR(n,7),1); InByte(%CLS%);
%+D       if TrcSw > 2
%+D       then Ed(TrcBuf," NP:"); EdWrd(TrcBuf,NP);
%+D            Ed(TrcBuf," NL:"); EdWrd(TrcBuf,NL);
%+D            Ed(TrcBuf," CLASS:"); EdWrd(TrcBuf,CLS);
%+D            Ed(TrcBuf," n:"); EdWrd(TrcBuf,n); OutTrace;
%+D       endif;
%+D end;

%+D Routine LINNUM;
%+D begin
%+D       loadStat(0):=loadStat(0)+1;
%+D       -- ...   MERE SENERE ... ;
%+D       -- ...   MERE SENERE ... ;
%+D end;
%title ***   P U B D E F / E X T D E F   ***
Routine PUBDEF;
begin Word Grpx,Segx,Type,Ident,Ofst; ref(SEGMENT) Seg; unsigned last;
      --- used by macro scanName ---
      byte scannn; infix(string) scanns;
%+D   Word UnUsed; Byte p; p:=TrcBuf.Pos;
%+D   scanStat(3):=scanStat(3)+1;
      ScanIndex(Grpx,"Grpx"); ScanIndex(Segx,"Segx");
%+D   if Segx.val=0
%+D   then ScanWord(UnUsed,"FrameNumber");
%+D        MODERR("PUBDEF with FrameNumber - Not Supported");
%+D        goto E;
%+D   endif;
      Seg:=SegTab(Segx.HI).Elt(Segx.LO);
      last:=RecLast-2; repeat while CBUF.nxt < last
      do
%+D      if TrcBuf.Pos > 40 then OutTrace; SetPos(TrcBuf,p) endif;
         ScanName(Ident,"Name"); ScanWord(Ofst,"Offset");
         ScanIndex(Type,"Type"); DefPUBLIC(Ident,Seg,Ofst.val);
      endrepeat;
%+D E:
end;

Routine DefPUBLIC;
import Word xSmb; ref(SEGMENT) Seg; Unsigned Ofst
begin ref(PUBLIC) Pub; Word modx;
      if PUBREF(xSmb.HI)=none
      then PUBREF(xSmb.HI):=NEWOBJ(size(RefBlock)) endif;
      Pub:=PUBREF(xSmb.HI).elt(xSmb.LO);
      if Pub=none
      then ALLOC(Pub,  Size(PUBLIC)); PUBREF(xSmb.HI).elt(xSmb.LO):=Pub;
      elsif Pub.Seg=none then nUNDEF:=nUNDEF-1;
      else Ed(ErrMsg,"Public "); EdSymb(ErrMsg,xSmb);
           Ed(ErrMsg," Already Defined in "); modx:=Pub.Seg.Modx;
           EdModid(ErrMsg,MODMAP(modx.HI).Elt(Modx.LO)); MODERR(" ");
      endif;
      Pub.Seg:=Seg; Pub.Ofst:=Ofst;
end;

Routine EXTDEF;
begin Word xSmb,Type; ref(PUBLIC) Pub; unsigned last;
      --- used by macro scanName ---
      byte scannn; infix(string) scanns;
%+D   Byte p; p:=TrcBuf.Pos;
%+D   scanStat(2):=scanStat(2)+1;
      last:=RecLast-2; repeat while CBUF.nxt < last
      do
%+D      if TrcBuf.Pos>40 then OutTrace; SetPos(TrcBuf,p) endif;
         ScanName(xSmb,"Name"); ScanIndex(Type,"Type");
         if PUBREF(xSmb.HI)=none
         then PUBREF(xSmb.HI):=NEWOBJ(size(RefBlock)) endif;
         Pub:=PUBREF(xSmb.HI).elt(xSmb.LO);
         if Pub=none
         then ALLOC(Pub,  Size(PUBLIC)); Pub.Seg:=none; Pub.Ofst:=0;
              PUBREF(xSmb.HI).Elt(xSmb.LO):=Pub; nUNDEF:=nUNDEF+1;
         endif;
         nExt.val:=nExt.val+1;
         if nExt.HI >= MxpExt then CAPERR("Extern-Table Overflow") endif;
         if ExtTab(nExt.HI)=none
         then ExtTab(nExt.HI):=NEWOBJ(size(WrdBlock)) endif;
         ExtTab(nExt.HI).Elt(nExt.LO):=xSmb;
      endrepeat;
end;
%title ***   G R P D E F   ***

Routine GRPDEF;
begin Byte n; Word Ident,Grpx,Segx; unsigned last;
      ref(GROUP) Grp; ref(SEGMENT) Seg; ref(FRAME) Frm,x;
%+D   Byte p; p:=TrcBuf.Pos;
%+D   scanStat(4):=scanStat(4)+1;
      ScanIndex(Grpx,"GrpNamx");
      Ident:=NamTab(Grpx.HI).Elt(Grpx.LO);
      Grp:=FindGROUP(Ident);
%+D   if TrcSw > 2 then ShowGrp(Grp) endif;
      last:=RecLast-2; repeat while CBUF.nxt < last
      do
%+D      if TrcBuf.Pos>40 then OutTrace; SetPos(TrcBuf,p) endif;
         InByte(%n%); ScanIndex(Segx,"Segx");
         Seg:=SegTab(Segx.HI).Elt(Segx.LO);
         Frm:=FindFRAME(Seg.Ident);
         if Frm.Grp <> Grp
         then if Frm.Grp <> none
              then MODERR("Frame already part of another Group")
              else Frm.Grp:=Grp; x:=Grp.Frm;
                   if x=none then Grp.Frm:=Frm
                   else repeat while x.GrpLnk <> none 
                        do x:=x.GrpLnk endrepeat;
                        x.GrpLnk:=Frm;
                   endif;
              endif;
         endif;
      endrepeat;
%+D   if TrcSw > 2 then ShowGrp(Grp) endif;
      nLgr.val:=nLgr.val+1;
      if nLgr.HI >= MxpLgr then CAPERR("Local Group-Table Overflow") endif;
      if LgrTab(nLgr.HI)=none
      then LgrTab(nLgr.HI):=NEWOBJ(size(RefBlock)) endif;
      LgrTab(nLgr.HI).Elt(nLgr.LO):=Grp;
end;

%title ***   S E G D E F  ***
const infix(string) tCODE="CODE",
                    tLINE="LINE";
Routine SEGDEF;
begin ref(SEGMENT) Seg; ref(symbol) symb; Byte n,A,C,B,PP,LTL; infix(String) s;
      Word FrameNumber,Ofst,MaxLng,SegLng,Class,SegNamx,ClassNamx,OvlNamx;
%+D   Byte p; p:=TrcBuf.Pos;
%+D   scanStat(5):=scanStat(5)+1;
      InByte(%n%); -- FORMAT: <A>3<C>3<B>1<P>1
%+D   PP:=bAND(n,1);          B:=bAND(bSHR(n,1),1);
%+D   C:=bAND(bSHR(n,2),7);   A:=bAND(bSHR(n,5),7);
%+D   if TrcSw > 2
%+D   then Ed(TrcBuf," A:"); EdWrd(TrcBuf,A);
%+D        Ed(TrcBuf," C:"); EdWrd(TrcBuf,C);
%+D        Ed(TrcBuf," B:"); EdWrd(TrcBuf,B);
%+D        Ed(TrcBuf," P:"); EdWrd(TrcBuf,PP);
%+D        OutTrace; SetPos(TrcBuf,p);
%+D   endif;
%-D                           A:=bAND(bSHR(n,5),7);
      case 0:7 (A)
      when 0,5: ScanWord(FrameNumber,"FrameNumber"); ScanByte(n,"Offset");
      when   6: ScanByte(LTL,"LTL"); ScanWord(MaxLng,"MaxSegLength");
                ScanWord(Ofst,"GroupOffset");
      endcase;
      ScanWord(SegLng,"SegLength");
%+D   if CBUF.nxt < (RecLast-1)
%+D   then ScanIndex(SegNamx,"SegNamx");
%+D        if CBUF.nxt < (RecLast-1) then ScanIndex(ClassNamx,"ClassNamx") endif
%+D        if CBUF.nxt < (RecLast-1) then ScanIndex(OvlNamx,"OvlNamx") endif;
%+D   endif;
%-D   ScanIndex(SegNamx,"SegNamx");
%-D   ScanIndex(ClassNamx,"ClassNamx"); ScanIndex(OvlNamx,"OvlNamx");
      nSeg.val:=nSeg.val+1;
      if nSeg.HI >= MxpSeg then CAPERR("Segment-Table Overflow") endif;
      if SegTab(nSeg.HI)=none
      then SegTab(nSeg.HI):=NEWOBJ(size(RefBlock)) endif;
      ALLOC(Seg,Size(SEGMENT)); SegTab(nSeg.HI).Elt(nSeg.LO):=Seg;
      Seg.Ident:=NamTab(SegNamx.HI).Elt(SegNamx.LO); Seg.Align:=A;
      Seg.Length:=SegLng.val; Seg.Filled:=0; Seg.Modx:=nMod;
      Seg.Frm:=none; Seg.Suc:=none; Seg.First:=none; Seg.Last:=none; 
      Class:=NamTab(ClassNamx.HI).Elt(ClassNamx.LO);
      if Class=sSTACK then Seg.cType:=cSTACK
      else symb:=SMBTAB(class.HI).Elt(class.LO);
           if symb.nchr < 4 then Seg.cType:=cDATA
           elsif APX_SCMPEQ(4,name(symb.chr(symb.nchr-4)),tCODE.chradr)
           then symb:=SMBTAB(seg.ident.HI).Elt(seg.ident.LO);
                if symb.nchr < 4 then Seg.cType:=cCODE
                elsif APX_SCMPEQ(4,name(symb.chr(symb.nchr-4)),tLINE.chradr)
                then seg.cType:=cLINE else seg.cType:=cCODE endif
           else Seg.cType:=cDATA endif;
      endif;
end;

%title ***   L I D A T A / L E D A T A  ***
Routine ScanBlock; import Unsigned Rep;
begin Unsigned n,p; Word cnt,nBlk; Ref(DATABLK) Blk;
%+D   if TrcSw > 2 then OutTrace; SetPos(TrcBuf,18) endif;
      ScanWord(cnt,"RepCount"); Rep:=Rep*cnt.val;
      ScanWord(nBlk,"BlkCount");
      if nBlk.val = 0
      then
%+D        if CBUF.nxt > (RecLast-2) then MODERR("ScanBlock-1"); goto E endif;
           InByte(%n%);
           Blk:=ScanData(n); Blk.Ofst:=ScanOfst;
           n:=p:=Blk.Lng;
           repeat Rep:=Rep-1 while Rep > 0
           do if (p+n)>1024 then MODERR("Text Block Too Large"); Rep:=0;
              else APX_SMOVEI(n,@Blk.chr(p),@Blk.chr); p:=p+n endif;
           endrepeat;
           Blk.Lng:=p;
%+D        if TrcSw > 3 then ShowBlk(Blk) endif;
           if Blk.Lng+Blk.Ofst > CurSeg.Length
           then MODERR("Text Larger than Segment") endif;
           ChainBlock(Blk);
      else repeat while nBlk.val>0
           do ScanBlock(Rep); nBlk.val:=nBlk.val-1 endrepeat;
      endif;
%+D   if CBUF.nxt >= RecLast then MODERR("ScanBlock"); endif;  E:
end;

unsigned ScanOfst; -- implicit parameter to scanblock

Routine LIDATA;
begin Word Segx,Ofst; unsigned last;
%+D   loadStat(3):=loadStat(3)+1;
      ScanIndex(Segx,"Segx");
      CurSeg:=CurMod.SegTab.Elt(Segx.val-1); CurFrm:=CurSeg.Frm;
      ScanWord(Ofst,"Offset"); ScanOfst:=Ofst.val;
      last:=RecLast-2; repeat while CBUF.nxt < last
      do ScanBlock(1) endrepeat;
end;

Routine LEDATA;
begin Word Segx,Ofst; ref(DATABLK) Blk;
%+D   Byte p; p:=TrcBuf.Pos;
%+D   loadStat(2):=loadStat(2)+1;
      ScanIndex(Segx,"Segx"); ScanWord(Ofst,"Offset");
%+D   if TrcSw > 2 then OutTrace; SetPos(TrcBuf,p) endif;
      CurSeg:=CurMod.SegTab.Elt(Segx.val-1); CurFrm:=CurSeg.Frm;
      Blk:=ScanData(RecLast-CBUF.nxt-1); Blk.Ofst:=Ofst.val;
      if Blk.Lng+Ofst.val > CurSeg.Length
      then MODERR("Text Larger than Segment") endif;
      ChainBlock(Blk); CurBlk:=Blk; --- FIXUPP follows probably
%+D   if CBUF.nxt >= RecLast then MODERR("LEDATA"); endif;
end;
%title ***   D A T A B L K   ***
Routine OutputBlock; import ref(DATABLK) Blk;
begin Unsigned n; ref(DATABLK) x;
      ref(BANK) Bnk; ref(FRAME) Frm; Integer SegPos,FilPos,Loc,Org;
      Frm:=CurSeg.Frm;
%+C   if Frm = none then MODERR("OutputBlock-1"); goto E1 endif;
      Bnk:=Frm.Bnk;
%+C   if Bnk = none then MODERR("OutputBlock-2"); goto E2 endif;
      curHandle:=Bnk.Handle;
      SegPos:=Bnk.BnkDsc.TxtPos+EAddr(CurSeg.Start);
      if curHandle <> ExeFile
      then Org:=Bnk.BnkDsc.MemBase.val;
           Org:=Org*16; SegPos:=SegPos-Org;
      endif;
%+C   if curHandle=0 then MODERR("OutputBlock-3"); goto E3 endif;
%+D   if TrcSw > 1
%+D   then BegTrace("OutputBlock: Handle="); EdWrd(TrcBuf,curHandle);
%+D        Ed(TrcBuf,", Segment "); EdSymb(TrcBuf,CurSeg.Ident);
%+D        Ed(TrcBuf,", SegmentFilePos="); EdInt(TrcBuf,SegPos);
%+D        Ed(TrcBuf,", Filled="); EdInt(TrcBuf,CurSeg.Filled); OutTrace
%+D        if TrcSw > 4 then ShowBlk(Blk) endif;
%+D   endif;
      x:=Blk; repeat while x.Prd <> none do x:=x.Prd endrepeat;
      repeat curFpos:=SegPos+x.Ofst; writeRel(@x.Image,x.Lng);
             CurSeg.Filled:=CurSeg.Filled+x.lng;
             --- Chain DATABLK to Free List ---
             x.Prd:=FreeBlk; FreeBlk:=x;
      while x <> Blk do x:=x.Suc endrepeat;
      if Blk.Suc <> none then CurSeg.First:=Blk.Suc; Blk.Suc.Prd:=none
      else CurSeg.First:=none; CurSeg.Last:=none endif;
%+C E1:E2:E3:
end;

Routine ChainBlock; import ref(DATABLK) Blk;
begin ref(DATABLK) x,y; Unsigned OfsChk;
      x:=CurSeg.Last;
      if x=none then OfsChk:=0; CurSeg.First:=Blk
      else OfsChk:=x.Ofst+x.Lng; x.Suc:=Blk; Blk.Prd:=x;
           if x.Prd <> none then OutputBlock(x.Prd) endif;
      endif;
      CurSeg.Last:=Blk;
      if Blk.Ofst <> OfsChk
      then MODERR("Text is not Compact Monotone Increasing") endif;
end;
%title ***   F I X U P P  ***
Routine FIXUPP;
begin Byte n,M,S,D,Z,Thx,Fld; infix(MemAddr) adr; Word UnUsed,Pos;
      unsigned last;
%+D   Unsigned OldTrc;
%+D   loadStat(1):=loadStat(1)+1;
%+D   OldTrc:=TrcSw; if TrcSw < 4 then TrcSw:=0 endif;
      last:=RecLast-1; repeat while CBUF.nxt < last
      do inByte(%n%);
         if n < 128
         then adr.Ofst.val:=0;                             --- THREAD ---;
              -- FORMAT: n=<+0>1<D>1<Z>1<METHOD>3<THRED>2
              Thx:=bAND(n,3);
              adr.Kind:=bAND(bSHR(n,2),7);
%-D                                 D:=bAND(     n,  64);
%+D           Z:=bAND(bSHR(n,5),1); D:=bAND(bSHR(n,6),1);
%+D           if TrcSw > 3
%+D           then OutTrace; SetPos(TrcBuf,10);
%+D                Ed(TrcBuf,"THREAD D:");  EdWrd(TrcBuf,D);
%+D                Ed(TrcBuf," Z:");        EdWrd(TrcBuf,Z);
%+D                Ed(TrcBuf," METHOD:");   EdWrd(TrcBuf,adr.Kind);
%+D                Ed(TrcBuf," THRED:");    EdWrd(TrcBuf,Thx);
%+D           endif;
              if D = 0 then goto AD1 endif
              if adr.Kind < 4
              then AD1:
                   case 0:3 (adr.Kind)
                   when SegAddr: ScanIndex(adr.Segx,"Segx")
                   when GrpAddr: ScanIndex(adr.Grpx,"Grpx")
                   when ExtAddr: ScanIndex(adr.Extx,"Extx")
                   otherwise notImplFrameAddr endcase;
              endif;
              If D=0 then ImpTarget(Thx):=adr else ImpFrame(Thx):=adr endif
         else                                            --- FIXUPP ---;
              -- FORMAT: n=<+1>1<M>1<S>1<LOC>3<OFFSET-HI>2 <OFFSET-LO>8
              Pos.HI:=bAND(n,3); InByte(%Pos.LO%);
              Fld:=bAND(bSHR(n,2),7);
%+D           S:=bAND(bSHR(n,5),1); M:=bAND(bSHR(n,6),1);
%-D                                 M:=bAND(     n,  64);
              adr:=ScanLogicalAddr;
%+D           if TrcSw > 3
%+D           then OutTrace; SetPos(TrcBuf,10);
%+D                Ed(TrcBuf,"FIXUPP M:");  EdWrd(TrcBuf,M);
%+D                Ed(TrcBuf," S:");        EdWrd(TrcBuf,S);
%+D                Ed(TrcBuf," Fld:");      EdWrd(TrcBuf,Fld);
%+D                Ed(TrcBuf," OFFSET:");   EdWrd(TrcBuf,Pos.val);
%+D                OutTrace; SetPos(TrcBuf,10);
%+D                if    Fld=fLOBYTE  then Ed(TrcBuf,"LowByte(")
%+D                elsif Fld=fOFFSET  then Ed(TrcBuf,"Offset(")
%+D                elsif Fld=fBASE    then Ed(TrcBuf,"Base(")
%+D                elsif Fld=fPOINTER then Ed(TrcBuf,"Pointer(")
%+D                elsif Fld=fHIBYTE  then Ed(TrcBuf,"HighByte(")
%+D                else  Ed(TrcBuf,"????(") endif;
%+D                EdSymb(TrcBuf,CurSeg.Ident); EdChar(TrcBuf,'+');
%+D                EdWrd(TrcBuf,CurBlk.Ofst+Pos.val); Ed(TrcBuf,")  <= ");
%+D                if M=0 then Ed(TrcBuf,"Self")
%+D                       else Ed(TrcBuf,"Segm") endif;
%+D                Ed(TrcBuf,"Rel <=  "); EdAddr(TrcBuf,adr);
%+D                EdChar(TrcBuf,'='); EdAbsAddr(TrcBuf,Mem2AbsAddr(adr));
%+D           endif;
              if M=0 then SelfReloc(Pos.val,Fld,adr)
                     else SegmReloc(Pos.val,Fld,adr) endif;
         endif;
      endrepeat;
-- E1:E2:
%+D   TrcSw:=OldTrc;
end;


Routine SelfReloc; import Unsigned Pos; Byte Fld; infix(MemAddr) adx;
begin ref(WORDTYPE) x,ins; Dword adr;
      --- for use by macro mem2abs:
%-D   ref(SEGMENT) Seg; ref(GROUP) Grp; ref(PUBLIC) Pub; Word xSmb;
      if Fld <> fOFFSET
      then MODERR("Illegal Self Relocation"); goto E endif;
%+D   adr:=Mem2AbsAddr(adx);
%-D   mem2abs;
      x:=Name2Ref(name(CurBlk.Image(Pos)));
%+C   if Pos > 0 then ins:=Name2Ref(name(CurBlk.Image(Pos-1)))
%+C   else ins:=Name2Ref(name(CurBlk.Prd.Image(CurBlk.Prd.Lng-1))) endif
%+C   if ins.AsByte=iJMP then elsif ins.AsByte=iCALL then -- OK
%+C   else MODERR("Illegal Self-Relocation") endif;
      if (adr.val <> 0) and (adr.Segm <> CurFrm.Start.Segm)
      then Ed(ErrMsg,"Near JUMP/CALL "); EdAddr(ErrMsg,adx);
           EdChar(ErrMsg,'='); EdAbsAddr(ErrMsg,adr);
           MODERR(" is out of range");
      endif;
%+D   if TrcSw > 1
%+D   then BegTrace("Offset: "); EdWrd(TrcBuf,x.AsWord); OutTrace endif;
      x.AsWord:=(x.AsWord+adr.Ofst.val)
                         -(CurSeg.Start.Ofst.val+CurBlk.Ofst+Pos+2);
%+D   if TrcSw > 1
%+D   then BegTrace("Disp: "); EdWrd(TrcBuf,x.AsWord); OutTrace endif;
E:end;
%page

Routine SegmReloc; import Unsigned Pos; Byte Fld; infix(MemAddr) adx;
begin ref(DWORDTYPE) x,ins; Word xSmb;
      ref(BANK) Bnk; Dword adr;
      --- for use by macro mem2abs:
%-D   ref(SEGMENT) Seg; ref(GROUP) Grp; ref(PUBLIC) Pub;
      --- for use by Putrel:
      Unsigned Ofst; ref(RELOBLK) Blk,y; Unsigned nRel;
%+D   boolean traceit; traceit:=false;
%+D   if (TrcSw > 1) or ((curfrm.ctype=cLINE) and (Atrsw=1))
%+D   then traceit:=true endif;
%+D   adr:=Mem2AbsAddr(adx);
%-D   mem2abs;
      x:=Name2Ref(name(CurBlk.Image(Pos)));
      case 0:4 (Fld)
      when fLOBYTE:  x.AsByte:=x.AsByte+wAND(adr.Ofst.val,255);
      when fHIBYTE:  x.AsByte:=x.AsByte+wAND(wSHR(adr.Ofst.val,8),255);
      when fOFFSET:  x.AsWord.val:=x.AsWord.val+adr.Ofst.val;
%+D        if traceit
%+D        then BegTrace("Offset: ");
%+D             EdWrd(TrcBuf,x.AsWord.val); OutTrace;
%+D        endif;
      when fBASE:
           if x.AsWord.val <> 0 then
           WARNING("Constant ignored in External Base Relocation") endif
           x.AsWord:=adr.Segm;
%+D        if traceit
%+D        then BegTrace("Base: ");
%+D             EdWrd(TrcBuf,x.AsWord.val); OutTrace;
%+D        endif;
---        PutRel(CurSeg.Start.Ofst.val+CurBlk.Ofst+Pos);
           Ofst:=CurSeg.Start.Ofst.val+CurBlk.Ofst+Pos; goto PutRel1;
      when fPOINTER:
           if x.AsWord(1).val <> 0 then
           WARNING("Constant ignored in External Pointer Relocation")
           endif;
           adr.Ofst.val:=adr.Ofst.val+x.AsWord.val;
%+D        if traceit
%+D        then BegTrace("POINTER Relocation: "); EdAbsAddr(TrcBuf,adr);
%+D             EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D             EdChar(TrcBuf,'[');
%+D             EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D             Ed(TrcBuf,"] in "); EdSymb(TrcBuf,CurFrm.Ident);
%+D             EdChar(TrcBuf,'['); EdSymb(TrcBuf,CurFrm.Bnk.Ident);
%+D             EdChar(TrcBuf,']');
%+D             showType(TrcBuf,CurFrm.cType);
%+D             OutTrace;
%+D        endif;
           if mergeLinBnk then goto L0 endif
           if CurFrm.cType <> cCODE then goto L1 endif;
           if Pos > 0 then ins:=Name2Ref(name(CurBlk.Image(Pos-1)))
           else if CurBlk.Prd=none then goto L2 endif;
                ins:=Name2Ref(name(CurBlk.Prd.Image(CurBlk.Prd.Lng-1)));
           endif;
           if    ins.AsByte=iJMPF
           then if adx.Kind <> ExtAddr then xSmb.val:=0
                else xSmb:=CurMod.ExtTab.Elt(adx.Extx.val-1) endif;
                if xSmb=sEGOTO
                then
                -------------------------------------------------------
                -- GOTO Evaluated Label:    BX:AX = Address          --
                -- i-Code:  iJMPF  <ofst>2<segm>2+fPOINTER(E@GOTO)   --
                --   ===>   iINT  xGOTO  iNOP  iNOP  iNOP            --
                -------------------------------------------------------
                     ins.AsByte:=iINT; x.AsByte(0):=xGOTO;
                     x.AsByte(1):=iNOP; x.AsByte(2):=iNOP;
                     x.AsByte(3):=iNOP;
%+D                  if AtrSw > 0
%+D                  then BegTrace("JMPF "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xGOTO,2)
%+D                       Ed(TrcBuf," NOP NOP NOP"); OutTrace;
%+D                  endif;
                else
                -------------------------------------------------------
                -- GOTO Visible Label:                               --
                -- i-Code:  iJMPF  <ofst>2<segm>2+fPOINTER(adr)      --
                --   ===>   iINT  xJMPF  frmx  <offset>2             --
                -------------------------------------------------------
                     Bnk:=FrmTab(adr.Segm.LO).Bnk;
                     if (Bnk=RotBnk) or (Bnk=CurFrm.Bnk)
                     then
%+D                       if TrcSw > 1
%+D                       then BegTrace("JMPF "); EdAbsAddr(TrcBuf,adr);
%+D                            EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                            EdChar(TrcBuf,'[');
%+D                            EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident)
%+D                            Ed(TrcBuf,"] is not changed");
%+D                            OutTrace;
%+D                       endif;
                          goto L3; -- Keep instruction as it is !!!
                     endif;
                     ins.AsByte:=iINT; x.AsByte(0):=xJMPF;
                     x.AsByte(1):=adr.Segm.LO; x.AsWord(1):=adr.Ofst;
%+D                  if AtrSw > 0
%+D                  then BegTrace("JMPF "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xJMPF,2)
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Segm.LO,2);
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Ofst.val,4)
%+D                       OutTrace;
%+D                  endif;
                endif;
                goto E1;
           elsif ins.AsByte=iCALLF
           then if adx.Kind <> ExtAddr then xSmb.val:=0
                else xSmb:=CurMod.ExtTab.Elt(adx.Extx.val-1) endif;
                if xSmb=sECALL
                ------------------------------------------------------
                -- CALL Evaluated Routine:  BX:AX = Address         --
                -- i-Code: iCALLF <ofst>2<segm>2+fPOINTER(E@CALL)   --
                --   ===>  iINT  xCALL  iNOP  iNOP  iNOP            --
                ------------------------------------------------------
                then ins.AsByte:=iINT; x.AsByte(0):=xCALL;
                     x.AsByte(1):=iNOP; x.AsByte(2):=iNOP;
                     x.AsByte(3):=iNOP;
%+D                  if TrcSw > 0
%+D                  then BegTrace("CALL "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xCALL,2)
%+D                       Ed(TrcBuf," NOP NOP NOP"); OutTrace;
%+D                  endif;
                else
                ------------------------------------------------------
                -- CALL Visible Routine:                            --
                -- i-Code:  iCALL  <ofst>2<segm>2+fPOINTER(adr)     --
                --   ===>   iINT  xCALF  frmx  <offset>2            --
                ------------------------------------------------------
                     Bnk:=FrmTab(adr.Segm.LO).Bnk;
                     if (Bnk=RotBnk) or (Bnk=CurFrm.Bnk)
                     then
%+D                       if AtrSw > 0
%+D                       then BegTrace("CALL "); EdAbsAddr(TrcBuf,adr);
%+D                            EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                            EdChar(TrcBuf,'[');
%+D                            EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident)
%+D                            Ed(TrcBuf,"] is not changed");
%+D                            OutTrace;
%+D                       endif;
                          goto L4; -- Keep instruction as it is !!!
                     endif;
                     if EAddr(Bnk.Start)
                     < (EAddr(CurFrm.bnk.Start)+CurFrm.Bnk.Length)
                     then Ed(ErrMsg,"CALL "); EdAbsAddr(ErrMsg,adr);
                          EdChar(ErrMsg,'='); EdAddr(ErrMsg,adx);
                          EdChar(ErrMsg,'[');
                          EdSymb(ErrMsg,FrmTab(adr.Segm.LO).Bnk.Ident);
                          Ed(ErrMsg,"] Will Swap out ");
                          EdSymb(ErrMsg,CurFrm.Bnk.Ident);
                          WARNING(" "); SetPos(ErrMsg,16);
                          Ed(ErrMsg,"Routine Return may FAIL !");
                          PrintOut(ErrMsg);
                     endif;
                     ins.AsByte:=iINT; x.AsByte(0):=xCALF;
                     x.AsByte(1):=adr.Segm.LO; x.AsWord(1):=adr.Ofst;
%+D                  if AtrSw > 0
%+D                  then BegTrace("CALL "); EdAbsAddr(TrcBuf,adr);
%+D                       EdChar(TrcBuf,'='); EdAddr(TrcBuf,adx);
%+D                       EdChar(TrcBuf,'[');
%+D                       EdSymb(TrcBuf,FrmTab(adr.Segm.LO).Bnk.Ident);
%+D                       Ed(TrcBuf,"] ==> INT "); EdHex(TrcBuf,xCALF,2)
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Segm.LO,2);
%+D                       EdChar(TrcBuf,' '); EdHex(TrcBuf,adr.Ofst.val,4)
%+D                       OutTrace;
%+D                  endif;
                endif;
                goto E2;
%+C        else Ed(ErrMsg,"Unrecognized Instruction: ");
%+C             EdHex(ErrMsg,ins.AsByte,2); Ed(ErrMsg,"H ");
%+C             EdAbsAddr(ErrMsg,adr); WARNING(" -- Not Treated");
           endif;
L0:L1:L2:L3:L4: x.AsWord:=adr.Ofst; x.AsWord(1):=adr.Segm;
%+D        if TrcSw > 1
%+D        then BegTrace("Base:"); EdWrd(TrcBuf,x.AsWord(1).val);
%+D             Ed(TrcBuf,", Offset:"); EdWrd(TrcBuf,x.AsWord.val); OutTrace
%+D        endif;
           Ofst:=CurSeg.Start.Ofst.val+CurBlk.Ofst+Pos+2;
PutRel1:   --- PutRel(Ofst);
           Blk:=CurFrm.RelBlk;
           if Blk=none then goto A1 endif;
           nRel:=Blk.nRel;
           if nRel < 254 then Blk.nRel:=nRel+1
           else A1: ALLOC(y,Size(RELOBLK)); y.Suc:=Blk; Blk:=y;
                nRel:=0; Blk.nRel:=1; CurFrm.RelBlk:=Blk;
           endif;
           Blk.RELTAB(nRel).val:=Ofst;
%+D        if TrcSw > 1
%+D        then BegTrace("PutRel: "); EdWrd(TrcBuf,Ofst);
%+D             -- ... ... ...
%+D             OutTrace;
%+D        endif;
      endcase;
E1:E2:end;



--- Routine PutRel; import Unsigned Ofst;
--- begin ref(RELOBLK) Blk,x; Unsigned nRel;
---   Blk:=CurFrm.RelBlk;
---   if Blk=none then ALLOC(Blk,Size(RELOBLK)); Blk.nRel:=0; CurFrm.RelBlk:=Blk
---   elsif Blk.nRel>=254
---   then ALLOC(x,Size(RELOBLK)); x.Suc:=Blk; Blk:=x; Blk.nRel:=0;
---        CurFrm.RelBlk:=Blk;
---   endif;
---   nRel:=Blk.nRel;
---   Blk.RELTAB(nRel).val:=Ofst; Blk.nRel:=nRel+1;
--- %+D   if TrcSw > 1
--- %+D   then BegTrace("PutRel: "); EdWrd(TrcBuf,Ofst);
--- %+D        -- ... ... ...
--- %+D        OutTrace;
--- %+D   endif;
--- end;

%title ***    S  C  A  N  N  E  R    ***
Routine SCANNER; import ref(OBJMODULE) Mod
begin Word w; Unsigned i,k; integer Loc;
%-D   Byte RecTyp;                    -- Current Record Type
%+D   Integer TRCPOS;
%+D   if (AtrSw+TrcSw) > 1
%+D   then Ed(TrcBuf,"SCAN: "); EdModid(TrcBuf,Mod); OutTrace endif;

%+D   BytPos:=0;            -- Relative Input Byte number
%+D   RecPos:=0;            -- Relative Input Byte number
      w.val:=0;            -- Length of current record
%+D   ChkSum:=0;            -- Check-sum of current record
      RecTyp:=0;            -- Current Record Code
      nNam.val:=0; nSeg.val:=0; nLgr.val:=0; nExt.val:=0;
%+D   TRCPOS:=if LN1MOD=Mod.Ident then LN1POS else 0;
      curMod:=mod; InitObjCode;
N01:N02:N03:N04:N05:N06:N07:N08:N09:N10:N11:
%+D      if CBUF.nxt > RecLast then MODERR("Inconsistent record length");
%+D   elsif CBUF.nxt < RecLast then skipRecord(RecTyp) endif;
%+D   if ChkSum <> 0 then MODERR("Check-Sum Error") endif; ChkSum:=0;
%+D   if TrcSw > 2 then OutTrace endif;
%-D   skipRecord;
      InByte(RecTyp); if EndFile then goto FIN1 endif;
%+D   if TRCPOS <> 0
%+D   then if BytPos >= TRCPOS
%+D        then if LN1TRC=0 then TrcSw:=0; TRCPOS:=0
%+D             else TrcSw:=LN1TRC; 
%+D                  LN1TRC:=0; TRCPOS:=TRCPOS+LN1CNT;
%+D             endif;
%+D        endif;
%+D   endif;
%+D   RecPos:=BytPos;
      InByte(%w.LO%); InByte(%w.HI%); RecLast:=CBUF.nxt+w.val;
      --- ensure that record + head of next record is contained in buffer.
      --- thus, testing may be avoided in InByte if buffer is large enough!
      if RecLast >= (curClng-3)
      then i:=curClng-CBUF.nxt; curClng:=i+BufLng;
           if i>0 then APX_SMOVEI(i,@CBUF.chr,@CBUF.chr(CBUF.nxt)); endif
           READ(Inpt,BufLng,@CBUF.chr(i),k);
           if OsStat <> 0 then MODERR("SCANNER read") endif
           if k < BufLng then CBUF.byt(k+i):=0 endif;
           CBUF.nxt:=0; RecLast:=w.val;
      endif;
%+D   if TrcSw > 2
%+D   then EdInt(TrcBuf,RecPos); Ed(TrcBuf,": ");
%+D        EdRecType(TrcBuf,RecTyp);
%+D        EdChar(TrcBuf,'='); EdHex(TrcBuf,RecTyp,2);
%+D        Ed(TrcBuf,"H Lng:"); EdWrd(TrcBuf,w.val);
%+D   endif;
      case 0:255 (RecTyp)
%-D   when  136:              goto N02;
      when  148:              goto N05;   -- LINNUM treated by LOADER
      when  156:              goto N09;   -- FIXUPP treated by LOADER
      when  160:              goto N10;   -- LEDATA treated by LOADER
      when  162:              goto N11;   -- LIDATA treated by LOADER
      when  128: THEADR(Mod); goto N01;
%+D   when  136: COMENT;      goto N02;
      when  140: EXTDEF;      goto N03;
      when  144: PUBDEF;      goto N04;
      when  150: LNAMES;      goto N06;
      when  152: SEGDEF;      goto N07;
      when  154: GRPDEF;      goto N08;
      when  138:              goto FIN2;  -- MODEND  treated by LOADER
      otherwise MODERR("Unknown record type"); 
%+D             TERMIN(3,"Linker Terminated in Pass 1");
      endcase;

FIN1:FIN2:
      Mod.SegTab:=NewRefVector(nSeg.val); Mod.SegTab.nElt:=nSeg.val;
      repeat while nSeg.val > 0
      do Mod.SegTab.Elt(nSeg.val-1):=SegTab(nSeg.HI).Elt(nSeg.LO);
         nSeg.val:=nSeg.val-1;
      endrepeat
      Mod.LgrTab:=NewRefVector(nLgr.val); Mod.LgrTab.nElt:=nLgr.val;
      repeat while nLgr.val > 0
      do Mod.LgrTab.Elt(nLgr.val-1):=LgrTab(nLgr.HI).Elt(nLgr.LO);
         nLgr.val:=nLgr.val-1;
      endrepeat
      Mod.ExtTab:=NewWrdVector(nExt.val); Mod.ExtTab.nElt:=nExt.val;
      repeat while nExt.val > 0
      do Mod.ExtTab.Elt(nExt.val-1):=ExtTab(nExt.HI).Elt(nExt.LO);
         nExt.val:=nExt.val-1;
      endrepeat
%+D   if (AtrSw+TrcSw) > 0
%+D   then Ed(TrcBuf,"END SCAN: "); EdModid(TrcBuf,Mod);
%+D        Ed(TrcBuf,"  --  Bytes "); EdInt(TrcBuf,BytPos-1); OutTrace;
%+D   endif;
      CurMod:=none;
end;
%title ***    L  O  A  D  E  R    ***
Routine LOADER; import ref(OBJMODULE) Mod;
begin Unsigned i,k; Word xSmb,w; infix(string) F; integer Loc;
%-D   Byte RecTyp;                    -- Current Record Type
      ref(SEGMENT) Seg; ref(FRAME) Frm; ref(PUBLIC) Pub;
%+D   Integer TRCPOS;
%+D   if (AtrSw+TrcSw) > 0
%+D   then Ed(TrcBuf,"LOAD: "); EdModid(TrcBuf,Mod); OutTrace endif;
      --- Check Matching of External References ---
      i:=0; repeat while i < Mod.ExtTab.nElt
      do xSmb:=Mod.ExtTab.Elt(i); Pub:=PUBREF(xSmb.HI).Elt(xSmb.LO);
         if Pub.Seg = none then if xSmb <> sBNKTAB
         then Ed(ErrMsg,"Undefined External ");
              EdSymb(ErrMsg,xSmb); Ed(ErrMsg," Referenced from ");
              EdModid(ErrMsg,Mod); ERROR(" ");
         endif; endif;
         i:=i+1;
      endrepeat;
      --- Match Dummy Segments ---
      i:=0; repeat while i < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(i); i:=i+1;
         if Seg.Frm = none
         then Frm:=FindFRAME(Seg.Ident);
              Seg.Frm:=Frm; Seg.Start:=Frm.Start;
         endif;
      endrepeat;

%+D   BytPos:=0;            -- Relative Input Byte number
%+D   RecPos:=0;            -- Relative Input Byte number
%+D   ChkSum:=0;            -- Check-sum of current record
      RecTyp:=0;            -- Current Record Code
%+D   TRCPOS:=if LN2MOD=Mod.Ident then LN2POS else 0;
      CurMod:=Mod; InitObjCode;
N01:N02:N03:N04:N05:N06:N07:N08:N09:N10:N11:
%+D      if CBUF.nxt > RecLast then MODERR("Inconsistent record length");
%+D   elsif CBUF.nxt < RecLast then skipRecord(RecTyp) endif;
%+D   if ChkSum <> 0 then MODERR("Check-Sum Error") endif; ChkSum:=0;
%+D   if TrcSw > 2 then OutTrace endif;
%-D   if CBUF.nxt < RecLast then skipRecord endif;
      InByte(%RecTyp%); if EndFile then goto FIN1 endif;
%+D   if TRCPOS <> 0
%+D   then if BytPos >= TRCPOS
%+D        then if LN2TRC=0 then TrcSw:=0; TRCPOS:=0
%+D             else TrcSw:=LN2TRC; 
%+D                  LN2TRC:=0; TRCPOS:=TRCPOS+LN2CNT;
%+D             endif;
%+D        endif;
%+D   endif;
%+D   RecPos:=BytPos;
      InByte(%w.LO%); InByte(%w.HI%); RecLast:=CBUF.nxt+w.val;
      if RecLast >= (curClng-3)
      then i:=curClng-CBUF.nxt; curClng:=i+BufLng;
           if i>0 then APX_SMOVEI(i,@CBUF.chr,@CBUF.chr(CBUF.nxt)); endif
           READ(Inpt,BufLng,@CBUF.chr(i),k);
           if OsStat <> 0 then MODERR("LOADER read") endif
           if k < BufLng then CBUF.byt(k+i):=0 endif;
           CBUF.nxt:=0; RecLast:=w.val;
      endif;
%+D   if TrcSw > 2
%+D   then EdInt(TrcBuf,RecPos); Ed(TrcBuf,": ");
%+D        EdRecType(TrcBuf,RecTyp);
%+D        EdChar(TrcBuf,'='); EdHex(TrcBuf,RecTyp,2);
%+D        Ed(TrcBuf,"H Lng:"); EdWrd(TrcBuf,w.val);
%+D   endif;

      case 0:255 (RecTyp)
      when 128:         goto N01;  -- THEADR  treated by SCANNER
      when 136:         goto N02;  -- COMENT  treated by SCANNER
      when 140:         goto N03;  -- EXTDEF  treated by SCANNER
      when 144:         goto N04;  -- PUBDEF  treated by SCANNER
%-D   when 148:         goto N05;  -- LINNUM  skipped
      when 150:         goto N06;  -- LNAMES  treated by SCANNER
      when 152:         goto N07;  -- SEGDEF  treated by SCANNER
      when 154:         goto N08;  -- GRPDEF  treated by SCANNER
%+D   when 148: LINNUM; goto N05;
      when 156: FIXUPP; goto N09;
      when 160: LEDATA; goto N10;
      when 162: LIDATA; goto N11;
      when 138: MODEND; goto FIN2;
      otherwise MODERR("Unknown record type"); 
%+D             TERMIN(3,"Linker Terminated in Pass 2");
      endcase;

FIN1:FIN2:
      --- Terminate Output of all Segments ---
      i:=0; repeat while i < Mod.SegTab.nElt
      do CurSeg:=Mod.SegTab.Elt(i); i:=i+1;
         if CurSeg.Last <> none
         then CurFrm:=CurSeg.Frm; OutputBlock(CurSeg.Last) endif;
%+D      if CurSeg.Filled <> CurSeg.Length
%+D      then Ed(ErrMsg,"Segment "); EdSymb(ErrMsg,CurSeg.Ident);
%+D           Ed(ErrMsg,"(Filled="); EdWrd(ErrMsg,CurSeg.Filled);
%+D           Ed(ErrMsg,",Lng="); EdWrd(ErrMsg,CurSeg.Length);
%+D           WARNING(") Contains Uninitalized Data");
%+D      endif;
      endrepeat; 
%+D   if (AtrSw+TrcSw) > 0
%+D   then Ed(TrcBuf,"END LOAD: "); EdModid(TrcBuf,Mod);
%+D        Ed(TrcBuf,"  --  Bytes "); EdInt(TrcBuf,BytPos-1); OutTrace;
%+D   endif;
      CurMod:=none;
end;
%title ***    M  O  D  E  N  D    ***

Routine MODEND;
begin Byte n,Mattr,L;
%+D   Word UnUsed;
      InByte(%n%); -- FORMAT: <Mattr>2<-->5<L>1
      Mattr:=bAND(bSHR(n,6),3); L:=bAND(n,1);
      if (Mattr=1) or (Mattr=3)
      then --- Start Address ---;
           StartMod:=CurMod;
           if L=1 then StartAddr:=ScanLogicalAddr
%+D        else if CBUF.nxt>(RecLast-5) then MODERR("MODEND"); goto E endif;
%+D             ScanWord(UnUsed,"FrameNumber"); ScanWord(UnUsed,"Offset");
           endif;
      endif;
%+D   E:if TrcSw > 2
%+D   then Ed(TrcBuf," ModuleType:"); EdWrd(TrcBuf,Mattr);
%+D        Ed(TrcBuf," L:"); EdWrd(TrcBuf,L);
%+D        if StartMod=CurMod then if StartAddr.Kind <> NoAddr
%+D        then OutTrace; SetPos(TrcBuf,18);
%+D             Ed(TrcBuf,"Start Address: "); EdAddr(TrcBuf,StartAddr);
%+D        endif endif;
%+D   endif;
end;
%title ***  L I B R A R Y   S E A R C H I N G  ***
Routine LibrarySearch;
begin Unsigned nModBefore,nBlk,n,lng,p; Word libx,smbx,modx;
      ref(LIBRARY) Lib; Word EltRef; Integer FilPos,Loc; Character c;
      ref(PUBLIC) Pub; ref(OBJMODULE) Mod; infix(String) s;
                           unsigned nBuf,lbl,rel512;
AGAIN: nModBefore:=nMod.val; libx.val:=0; nBuf:=0;
      repeat while libx.val < nLib.val
      do libx.val:=libx.val+1; Lib:=LIBMAP(libx.HI).Elt(libx.LO);
         nBlk:=Lib.nBlk.val;
%+D      if TrcSw > 0
%+D      then OutTrace; Ed(TrcBuf,"SEARCH LIBRARY: ");
%+D           EdSymb(TrcBuf,Lib.Ident); OutTrace; EdLib(TrcBuf,Lib);
%+D      endif;
         openAfile(lib,".lib");
         --- Locate First Dictionary Block ---
         LOCATE(Inpt,0,Lib.BlkRef.val,Loc);
         if OsStat <> 0 then ERROR("FileTail-1"); OsStat:=0 endif;
         Repeat while nBlk <> 0
         do --- Read Next Dictionary Block ---
            if nBuf=0
            then if nBlk >= nBuffers then nbuf:=nBuffers; lbl:=CBUFsize;
                 else nBuf:=nBlk; lbl:=nBuf*512 endif;
                 READ(Inpt,lbl,@CBUF.chr,n);
                 if OsStat<>0 then ERROR("FileTail-2")
                 elsif n<>lbl then EndFile:=true endif;
                 rel512:=0;
            else rel512:=rel512+512 endif
            nBuf:=nBuf-1;
            p:=rel512+38;
            repeat p:=wAND(p+1,-2); lng:=CBuf.byt(p); p:=p+1;
            while lng <> 0
            do n:=p; p:=p+lng;
               if CBuf.chr(p-1) = '!' then N1:N2:N3:N4: p:=p+2
               else s.chradr:=name(Cbuf.chr(n)); s.nchr:=lng;
                    smbx:=LOOKUP(s); if smbx.val=0 then goto N1 endif;
                    if PUBREF(smbx.HI) = none then goto N2 endif -- not PUBLIC
                    Pub:=PUBREF(smbx.HI).elt(smbx.LO);
                    if Pub=none then goto N3 endif  -- Not a PUBLIC Symbol
                    if Pub.Seg<>none then goto N4
                    else -- I.e. Undefined Symbol --
                         -- Check if Module is registered --
                         EltRef.LO:=CBuf.byt(p); p:=p+1;
                         EltRef.HI:=CBuf.byt(p); p:=p+1;
                         modx:=Lib.FstElt;
                         repeat while modx.val <> 0
                         do Mod:=MODMAP(modx.HI).Elt(modx.LO);
                            modx:=Mod.EltLnk;
                            if Mod.EltRef=EltRef.val then goto L1 endif;
                         endrepeat;
                         -- Insert Module in Library's List --
                         modx.val:=0; modx:=NewMODULE(modx);
                         if modx.val <> 0
                         then Mod:=MODMAP(modx.HI).Elt(modx.LO);
                              Mod.EltRef:=EltRef.val; Mod.Libx:=libx;
                              Mod.EltLnk:=Lib.FstElt; Lib.FstElt:=modx
                         endif;
                    L1:
                    endif;
               endif;
            endrepeat;
            nBlk:=nBlk-1;
         endrepeat;
         modx:=Lib.FstElt;
         repeat while modx.val <> 0
         do Mod:=MODMAP(modx.HI).Elt(modx.LO); modx:=Mod.EltLnk;
            if Mod.Ident.val <> 0 then modx.val:=0
            else FilPos:=Mod.EltRef; FilPos:=FilPos*16;
                 LOCATE(Inpt,0,FilPos,Loc);
                 if OsStat<>0 then ERROR(" "); OsStat:=0; goto E0 endif;
                 SCANNER(Mod); InsertAllSeg(Mod,RotBnk);
            endif;
         endrepeat;
E0:      closeAfile(Lib,false); -- Close(Inpt); Inpt:=0;
      endrepeat;
      if (nUNDEF>0) and (nMod.val>nModBefore) then goto AGAIN endif;
end;
%title ***  B N K   F I L E   T E R M I N A T E  ***
Routine BnkTerm;
begin ref(BANK) Bnk; ref(FRAME) Frm; ref(RELOBLK) Blk;
      Integer Loc; Unsigned n,Lng; Word bnkx;

      if mergeLinBnk then goto L0 endif
      curHandle:=BnkFile; curFpos:=BnkFilLng;

      --- Scan Through all Banks <> RotBnk ---
      bnkx.val:=1; repeat while bnkx.val < nBnk.val
      do bnkx.val:=bnkx.val+1;
         Bnk:=BNKMAP(bnkx.HI).Elt(bnkx.LO);
         Bnk.BnkDsc.RelPos:=BnkFilLng;
         --- Write Relocation Table ---
%+D      if TrcSw>0
%+D      then BegTrace("*** Relocation Table ***"); OutTrace endif;
         Frm:=Bnk.FrmLnk;
         repeat while Frm <> none
         do Blk:=Frm.RelBlk;
            repeat while Blk <> none
            do Blk.Base:=Frm.Start.Segm.val; Lng:=(Blk.nRel*2)+4;
               if (Blk.Suc=none) and (Frm.Suc=none)
               then Blk.nRel:=Blk.nRel+65280 endif;
               writeRel(@Blk.nRel,Lng);
               BnkFilLng:=BnkFilLng+Lng; Blk:=Blk.Suc;
            endrepeat;
            Frm:=Frm.Suc;
         endrepeat;
      endrepeat;
      exhaustAll;
 L0:  Close(BnkFile); nOpen:=nOpen-1; --- Close BNK File ---
end;
%title ***  E X E   F I L E   T E R M I N A T E  ***
Routine ExeTerm; import ref(BANK) Bnk;
begin Unsigned i,j,n,Lng,nRel,dHed,nHed; Boolean Lower; ref(BankInfo) BnkInf;
      ref(BANK) Bnx; ref(FRAME) Frm; ref(DATABLK) Blk; ref(RELOBLK) relBlk;
      Integer xx,nTxt,nTxx,Loc,FilPos,p1,p2; Word w; Dword RelItm,adr;
      name(character) iobuffer;
      integer writeloc; ref(relBuffer) RB,r2;

      --- Calculate total number of Relocation Items ---
      Frm:=Bnk.FrmLnk; nRel:=NextFrmx+nBnk.val;
      repeat while Frm <> none
      do relBlk:=Frm.RelBlk; Frm:=Frm.Suc;
         repeat while relBlk <> none
         do nRel:=nRel+relBlk.nRel; relBlk:=relBlk.Suc endrepeat;
      endrepeat;

      --- Set Basic Variables ---
      nTxt:=EAddr(RotBnk.Start)
            + RotBnk.Length;  -- Size of Load Text Image (in Bytes)
      dHed:=HDSIZE;           -- Default size of Header (512-Byte Pages)
      xx:=nRel;
      nHed:=((xx*4)+541)/512; -- Actual size of Header (512-Byte Pages)
      lower:=false;

      --- Possible Move Text Image ---
      if nHed <> dHed
      then
%+D        Ed(ErrMsg,"HDSIZE does not fit. Set HDSIZE ");
%+D        EdWrd(ErrMsg,nHed); WARNING(" to Speed up Linker");
           nTxx:=nTxt;
           p1:=dHed; p1:=p1*512; p2:=nHed; p2:=p2*512;
           if nHed < dHed
           then lower:=true   -- move DOWN
                writeLoc:=p2     -- see below
           else               -- move UP, start at end
                p1:=p1+nTxt; p2:=p2+nTxt;
           endif;
           curHandle:=exefile;
           --- Write Buffers to file ---
     EXH:  exhaustAll;
           if lower
           then xx:=writeLoc-p2; p1:=p1+xx; p2:=p2+xx;
           else xx:=nTxx; if xx>BufTotal then xx:=BufTotal endif
                p1:=p1-xx; p2:=p2-xx;
           endif;
           --- Read Buffers from file ---
           writeLoc:=p2; r2:=none;
           LOCATE(ExeFile,0,p1,Loc);
           if OsStat <> 0  then ERROR("ExeTerm-1"); OsStat:=0;
           elsif Loc <> p1 then ERROR("ExeTerm-2") endif;
           repeat while nTxx > 0
           do RB:=freeRbuf; if RB=none then goto EXH endif; freeRbuf:=RB.suc;
              if r2=none then RBUFr:=RB else r2.suc:=RB endif; r2:=RB;
              Lng:=if nTxx>RelBufLng then RelBufLng else nTxx; nTxx:=nTxx-Lng;
              READ(ExeFile,Lng,name(RB.byt),RB.filled);
              if OsStat <> 0 then ERROR("ExeTerm-3"); OsStat:=0;
              elsif RB.filled <> Lng then ERROR("ExeTerm-4") endif;
              RB.filpos:=writeloc; writeLoc:=writeLoc+Lng; RB.handle:=exefile;
           endrepeat;
      endif;
      exhaustAll;
%+M   if Lower then WRITE(ExeFile,0,@n,n); OsStat:=0 endif; -- Truncate

      --- Fill EXE Label ---
      BnkInf:=Name2Ref(@BnkTab.Elt(0));
      if BnkInf.BnkLng <> 0 --- avoid LOAD HIGH
      then ExeLab.MinAlloc:=BnkInf.BnkLng;     -- Size of Bank area
           ExeLab.MaxAlloc:=BnkInf.BnkLng;     -- Size of Bank area
      endif;
      ExeLab.Nblp:=nTxt rem 512;          -- No-of Bytes in last page
      ExeLab.Lngp:=nHed+((nTxt+511)/512); -- File size in 512-Byte pages
      ExeLab.nRel:=nRel;                  -- No.of relocations in table
      ExeLab.Lngh:=nHed*32;               -- Header size (16-Byte para)

      if StackFrm=none then ERROR("No Stack Segment")
      else ExeLab.SS:=StackFrm.Start.Segm.val;  -- SS initial value (+reloc)
           ExeLab.SP:=StackFrm.Start.Ofst.val
                    + StackFrm.Length;      -- SP initial value
      endif;

      if StartAddr.Kind=NoAddr then ERROR("No Start Address")
      else CurMod:=StartMod; adr:=Mem2AbsAddr(StartAddr);
           ExeLab.IP:=adr.Ofst.val;   -- IP initial value
           ExeLab.CS:=adr.Segm.val;   -- CS initial value (+reloc)
      endif;

      --- Write Bank Info Table ---
      FilPos:=nHed; curFpos:=FilPos*512; curHandle:=exefile;
---   LOCATE(ExeFile,0,FilPos,Loc);
---   if OsStat <> 0 then ERROR("ExeTerm-9"); OsStat:=0;
---   elsif Loc <> FilPos then ERROR("ExeTerm-10") endif;
---   if TabLng > 0
---   then WRITE(ExeFile,TabLng,@BnkTab.Elt,n);
---        if OsStat <> 0 then ERROR("ExeTerm-11"); OsStat:=0;
---        elsif n <> TabLng then ERROR("ExeTerm-12") endif;
---   endif;
      writeRel(@BnkTab.Elt,TabLng);
      --- Write Relocation Table ---
%+D   if TrcSw>0
%+D   then BegTrace("*** Relocation Table ***"); OutTrace endif;
---   LOCATE(ExeFile,0,30,Loc);
---   if OsStat <> 0  then ERROR("ExeTerm-13"); OsStat:=0;
---   elsif Loc <> 30 then ERROR("ExeTerm-14") endif;
      curFpos:=30;
      RotBnk.BnkDsc.RelPos:=30;
      RelItm.Segm.val:=0;
      w.val:=0; repeat while w.val < nBnk.val
      do w.val:=w.val+1; Bnx:=BNKMAP(w.HI).Elt(w.LO);
         RelItm.Ofst.val:=Bnx.FrmPos-4; j:=Bnx.nFrmx+1;
         repeat while j > 0
         do
%+D         if TrcSw>0
%+D         then EdChar(TrcBuf,' '); EdAbsAddr(TrcBuf,RelItm) endif;
---         WRITE(ExeFile,4,@RelItm,n);
---         if OsStat <> 0 then ERROR("ExeTerm-15"); OsStat:=0;
---         elsif n <> 4   then ERROR("ExeTerm-16") endif;
            writeRel(@RelItm,4);
            j:=j-1; RelItm.Ofst.val:=RelItm.Ofst.val+2;
         endrepeat;
      endrepeat;
      Frm:=Bnk.FrmLnk;
      repeat while Frm <> none
      do RelItm.Segm:=Frm.Start.Segm; relBlk:=Frm.RelBlk; Frm:=Frm.Suc;
         repeat while relBlk <> none
         do i:=relBlk.nRel;
            repeat while i > 0
            do i:=i-1; RelItm.Ofst:=relBlk.RELTAB(i);
%+D            if TrcSw>0
%+D            then EdChar(TrcBuf,' '); EdAbsAddr(TrcBuf,RelItm) endif;
---            WRITE(ExeFile,4,@RelItm,n);
---            if OsStat <> 0 then ERROR("ExeTerm-17"); OsStat:=0;
---            elsif n <> 4   then ERROR("ExeTerm-18") endif;
               writeRel(@RelItm,4); FilPos:=FilPos+4;
            endrepeat
%+D         if TrcSw>0 then OutTrace endif;
            relBlk:=relBlk.Suc;
         endrepeat;
      endrepeat;
      exhaustAll;

      --- Zero-Fill Last Page in Header ---

      --- Write EXE Label ---
--??  ExeLab.ChkSum:=   ?????;   -- Check-Sum
      LOCATE(ExeFile,0,0,Loc);
      if OsStat <> 0 then ERROR("ExeTerm-19"); OsStat:=0;
      elsif Loc <> 0 then ERROR("ExeTerm-20") endif;
      WRITE(ExeFile,30,@ExeLab,n);
      if OsStat <> 0 then ERROR("ExeTerm-21"); OsStat:=0;
      elsif n <> 30  then ERROR("ExeTerm-22") endif;
%+D   if AtrSw > 0 then ShowExeLab endif;
      --- Close EXE File ---
%+D   if TrcSw > 1 then ShowFileSize(ExeFile,"ExeFile") endif;
      Close(ExeFile); nOpen:=nOpen-1;
end;
%title ***  M A P   L I S T I N G  ***
Routine PrtArc;
import Integer Scale,Start,Length; Word Ident; Character c;
begin Unsigned n; EdInt(EdtBuf,Start); SetPos(EdtBuf,8);
      EdInt(EdtBuf,Length); SetPos(EdtBuf,16); EdSymb(EdtBuf,Ident);
      n:=(Length/Scale); SetPos(EdtBuf,30+(Start/Scale));
%+D   if n > 60 then n:=60 endif;
      repeat EdChar(EdtBuf,c) while n>0 do n:=n-1 endrepeat;
      OutImage;
end;

Routine MapListing;
begin Integer Start; Unsigned Base,Ofst,Scale; Word i,xSmb,modx;
      ref(PUBLIC) Pub; Dword adr; ref(BANK) Bnk; ref(FRAME) Frm;
%+D   if LstSw > 0 then ShowBankInfo endif;
      if LstSw > 2
      then OutImage; Ed(EdtBuf,"***   M O D U L E    M A P   ***"); OutImage;
           i.val:=0; repeat while i.val < nMod.val
           do i.val:=i.val+1; Summary(MODMAP(i.HI).Elt(i.LO)) endrepeat;
      endif;
      if LstSw > 0
      then OutImage; Ed(EdtBuf,"***   M E M O R Y    M A P   ***"); OutImage;
           i.val:=0; repeat while i.val < nBnk.val
           do i.val:=i.val+1; ShowBnk(BNKMAP(i.HI).Elt(i.LO)) endrepeat;
           if StartAddr.Kind <> NoAddr
           then CurMod:=StartMod; adr:=Mem2AbsAddr(StartAddr);
                Ed(EdtBuf,"Start Address: "); EdAddr(EdtBuf,StartAddr);
                EdChar(EdtBuf,'='); EdSegAddr(EdtBuf,adr); OutImage;
           endif;
      endif;
      OutImage; Ed(EdtBuf,"start   length  name          ************");
      Ed(EdtBuf,"   M E M O R Y    M A P   ************"); OutImage;
      Scale:=Total/50; if Scale=0 then Scale:=1 endif;
      i.val:=0; repeat while i.val < nBnk.val
      do i.val:=i.val+1; Bnk:=BNKMAP(i.HI).Elt(i.LO); Frm:=Bnk.FrmLnk;
         PrtArc(Scale,EAddr(Bnk.Start),Bnk.Length,Bnk.Ident,'=');
         if LstSw > 0
         then repeat while Frm <> none
              do PrtArc(Scale,EAddr(Frm.Start),Frm.Length,Frm.Ident,'-')
                 Frm:=Frm.Suc;
              endrepeat;
         endif;
      endrepeat;
      if LstSw > 1
      then OutImage; Ed(EdtBuf,"***   P U B L I C    M A P   ***"); OutImage;
           xSmb.val:=0; repeat while xSmb.val < nSmb.val
           do if PUBREF(xSmb.HI)=none then Pub:=none
              else Pub:=PUBREF(xSmb.HI).elt(xSmb.LO) endif;
              if Pub <> none
              then if Pub.Seg=none
                   then Ed(EdtBuf,"00000(0000:0000)  ");
                        EdSymb(EdtBuf,xSmb); MovePos(EdtBuf,40);
                        if xSmb=sBNKTAB
                        then Ed(EdtBuf,"*** DEFINED BY LINKER");
                        else Ed(EdtBuf,"*** UNDEFINED") endif;
                   else adr:=Pub.Seg.Start;
                        adr.Ofst.val:=adr.Ofst.val+Pub.Ofst;
                        EdSegAddr(EdtBuf,adr); Ed(EdtBuf,"  ");
                        EdSymb(EdtBuf,xSmb);
                        MovePos(EdtBuf,40); modx:=Pub.Seg.Modx;
                        EdModid(EdtBuf,MODMAP(modx.HI).Elt(modx.LO));
                        EdChar(EdtBuf,'('); EdSymb(EdtBuf,Pub.Seg.Ident);
                        EdChar(EdtBuf,'+'); EdWrd(EdtBuf,Pub.Ofst);
                        EdChar(EdtBuf,')');
                   endif;
                   OutImage;
              endif;
              xSmb.val:=xSmb.val+1;
           endrepeat;
      endif; OutImage;
%+D   ShowExeLab;
end;

Routine Summary; import ref(OBJMODULE) Mod;
begin Word xSmb; Unsigned i; ref(PUBLIC) Pub;
      ref(BANK) Bnk; ref(FRAME) Frm; ref(SEGMENT) Seg; Dword adr;
      Ed(EdtBuf,"Module "); EdModid(EdtBuf,Mod); OutImage;
      i:=0; repeat while i < Mod.SegTab.nElt
      do Seg:=Mod.SegTab.Elt(i); i:=i+1;
         if Seg.Length > 0
         then EdSegAddr(EdtBuf,Seg.Start); Ed(EdtBuf,"  ");
              EdSymb(EdtBuf,Seg.Ident); MovePos(EdtBuf,35);
              Ed(EdtBuf,"SEGMENT LENGTH: "); EdHex(EdtBuf,Seg.Length,4);
              Frm:=Seg.Frm; Bnk:=if Frm=none then none else Frm.Bnk;
              if Bnk <> none
              then Ed(EdtBuf,"  Included in ");
                   EdSymb(EdtBuf,Bnk.Ident);
              endif;
              OutImage;
         endif;
      endrepeat;
      i:=0; repeat while i < Mod.ExtTab.nElt
      do xSmb:=Mod.ExtTab.Elt(i); i:=i+1;
         Pub:=PUBREF(xSmb.HI).Elt(xSmb.LO); Seg:=Pub.Seg;
         if Seg=none then adr.val:=0
         else adr:=Seg.Start; adr.Ofst.val:=adr.Ofst.val+Pub.Ofst endif;
         EdSegAddr(EdtBuf,adr); Ed(EdtBuf,"  "); EdSymb(EdtBuf,xSmb);
         MovePos(EdtBuf,35); Ed(EdtBuf,"EXTERN  ");
         if Seg=none then Ed(EdtBuf,"*** Undefined ***")
         else EdModid(EdtBuf,MODMAP(Seg.Modx.HI).Elt(Seg.Modx.LO));
              EdChar(EdtBuf,'('); EdSymb(EdtBuf,Seg.Ident);
              EdChar(EdtBuf,'+'); EdWrd(EdtBuf,Pub.Ofst);
              EdChar(EdtBuf,')');
         endif; OutImage;
      endrepeat; OutImage;
end;
%title ***  M O N I T O R   U T I L I T I E S  ***

infix(edbuff) source;

Routine InItem; export infix(string) itm;
begin character c;
      repeat while NextChar = ' ' do InChar endrepeat; c:=InChar;
      source.chr:=c; source.pos:=1;
      if (c='(') or (c=')') or (c=',') or (c='=') or (c='+') then goto F endif;
   L: c:=NextChar;
      if (c='(') or (c=')') or (c=',') or (c='=') or (c='+') then -- Nothing
      elsif c <> ' '
      then source.chr(source.pos):=c; source.pos:=source.pos+1;
           inchar; goto L endif;
   F: itm.chradr:=name(source.chr); itm.nchr:=source.pos;
%+D   if TrcSw > 1
%+D   then BegTrace("InItem: !"); Ed(TrcBuf,itm);
%+D        EdChar(TrcBuf,'!'); OutTrace;
%+D   endif;
end;

routine isComment; import infix(string) itm; export boolean res;
begin if SEQ(itm,"CC") then res:=true
      elsif itm.nchr>1
      then itm.nchr:=2; res:=SEQ(itm,"--")
      else res:=false endif
end

Routine instring; export infix(string) itm;
begin Unsigned n; character b;
      repeat itm:=InItem while isComment(itm)
      do repeat READ(Srcf,1,@b,n);
                if OsStat <> 0 then b:='!10!'; OsStat:=0;
                elsif n <> 1   then b:='!10!' endif;
                if Verbose then WRITE(kSYSOUT,1,@b,n); OsStat:=0 endif;
         while b <> '!10!' do endrepeat;
      endrepeat;
end;

Routine InSymb; export Word itm;
begin Unsigned n; character b;
      itm:=DICDEF(instring);
end;

Routine InBank; export Word itm;
begin Unsigned n; character b; infix(string) s;
      s:=instring;
      --- strip off possible extension ---
      n:=0; repeat while n<s.nchr
      do if var(s.chradr)(n)='.' then s.nchr:=n endif;
         n:=n+1 endrepeat;
      itm:=DICDEF(s) 
%+D   if TrcSw > 0
%+D   then BegTrace("InBank: "); Ed(TrcBuf,s);
%+D        EdChar(TrcBuf,'='); EdSymb(TrcBuf,itm); OutTrace;
%+D   endif;
end;

Routine ChkDir; import infix(string) itm; export infix(string) res
begin repeat
         if SEQ(itm,"HDSIZE")  then HDSIZE:=InWrd
%+D   elsif SEQ(itm,"INTGOTO") then xGOTO:=InWrd
%+D   elsif SEQ(itm,"INTJMPF") then xJMPF:=InWrd
%+D   elsif SEQ(itm,"INTCALL") then xCALL:=InWrd
%+D   elsif SEQ(itm,"INTCALF") then xCALF:=InWrd
%+D   elsif SEQ(itm,"TRACE")   then TrcSw:=InInt
%+D   elsif SEQ(itm,"ATRACE")  then AtrSw:=InInt
      elsif SEQ(itm,"LISTING") then LstSw:=InWrd
%+D   elsif SEQ(itm,"LN1TRC")  then LN1MOD:=InSymb; LN1POS:=InInt;
%+D                                 LN1CNT:=InWrd;  LN1TRC:=InWrd;
%+D   elsif SEQ(itm,"LN2TRC")  then LN2MOD:=InSymb; LN2POS:=InInt;
%+D                                 LN2CNT:=InWrd;  LN2TRC:=InWrd;
      else res:=itm; goto E endif;
      itm:=instring;
      while true do endrepeat;
E:end;

Routine InChar; export character c;
begin int n; c:=NextChar; L: EndFile:=false; READ(Srcf,1,@NextChar,n);
      if OsStat <> 0 then ERROR("InChar")
      elsif n <> 1   then EndFile:=true endif;
%+D   if TrcSw > 8
%+D   then BegTrace("*** NextChar: ");
%+D        EdWrd(TrcBuf,NextChar qua Integer); OutTrace;
%+D   endif;
      if EndFile then EndFile:=false; goto L; endif;
      if Verbose then WRITE(kSYSOUT,1,@NextChar,n); OsStat:=0 endif;
      if NextChar < ' ' then NextChar:=' ' endif;
end;

%+D Routine UpChar; import character c; export character u;
%+D begin Byte b; b:=c qua Integer;
%+D       u:=(if b>95 then b-32 else b) qua character;
%+D end;

%+D Routine InInt; export Integer i;
%+D begin character c; i:=0;
%+D       repeat while NextChar=' ' do InChar endrepeat;
%+D       repeat c:=NextChar while (c>='0') and (c<='9')
%+D       do i:=(i*10)+(c qua Integer -48); InChar endrepeat;
%+D end;

Routine InWrd; export Unsigned i;
begin character c; i:=0;
      repeat while NextChar=' ' do InChar endrepeat;
      repeat c:=NextChar while (c>='0') and (c<='9')
      do i:=(i*10)+(c qua Integer -48); InChar endrepeat;
end;

%+D Routine InHex; export Unsigned i;
%+D begin Byte d; character c; i:=0;
%+D       repeat while NextChar=' ' do InChar endrepeat;
%+D    L: c:=UpChar(NextChar); d:=c qua Integer;
%+D       if    (c>='0') and (c<='9') then d:=d-48
%+D       elsif (c>='A') and (c<='F') then d:=d-55 else goto E endif;
%+D       i:=(i*16)+d; InChar; goto L;
%+D E:end;
%title ***   I  N  I  T  I  A  T  E  R   ***

Routine INITIATER; export Word itm;
begin infix(String) s; Unsigned i; ref(relBuffer) RB;
      HDSIZE:=19;         -- Default size of .exe-File Header (in pages)
      xGOTO:=70; xJMPF:=71; xCALL:=72; xCALF:=73; -- INT-Vector indicies
      StartAddr.Kind:=NoAddr;

      curWhandle:=curHandle:=0;

      i:=nrelbuf; RBUFr:=none;
      RB:=NEWOBJ(size(relBuffer:relBufLng)); freeRbuf:=RB;
      repeat i:=i-1 while i<>0
      do RB.suc:=NEWOBJ(size(relBuffer:relBufLng)); RB:=RB.suc endrepeat;
      bufTotal:=nrelbuf; bufTotal:=bufTotal*relbuflng;

-- ?? FreeBlk:=none;      -- Free Code Buffer Chain
-- ?? CurBlk:=none;       -- Code Buffer during LOADER
-- ?? RotBnk:=none;       -- Root Bank (EXE part)
-- ?? LinBnk:=none;       -- LineNumber Bank
-- ?? BnkFilLng:=0;       -- BNK File length (in Bytes)
-- ?? Total:=0;           -- Total size in Bytes
-- ?? NextFrmx:=0;        -- Next available Frame index
-- ?? StartMod:=none;
-- ?? StackFrm:=none;
-- ?? CurMod:=none;         -- Current OBJMODULE
-- ?? CurFrm:=none;         -- Current FRAME
-- ?? CurSeg:=none;         -- Current SEGMENT
-- ?? BytPos:=0;            -- Input Byte number ;
-- ?? RecLng:=0;            -- Length of current record ;
-- ?? %+D   ChkSum:=0;      -- Check-sum of current record ;
-- ?? RecTyp:=0;            -- Current Record Code ;
-- ?? Inpt:=0;              -- OBJ-Input file Handle
-- ?? Oupt:=0;              -- Created Listing File Handle
-- ?? ExeFile:=0;           -- Created .exe File Handle
-- ?? BnkFile:=0;           -- Created .bnk File Handle
-- ?? nUNDEF:=0;            -- No.of UNDEFINED PUBLICs

      --- Initiate EXE Label ---
      ExeLab.ChkCode:=  23117;   -- EXE-File Check code
      ExeLab.Nblp:=     00000;   -- Number of Bytes in last page
      ExeLab.Lngp:=     00000;   -- File size in 512-Byte pages
      ExeLab.nRel:=     00000;   -- No.of relocation entries in table
      ExeLab.Lngh:=     00000;   -- Size of header in 16-Byte paragraphs
      ExeLab.MinAlloc:= 0;
      ExeLab.MaxAlloc:= 1;
      ExeLab.SS:=       00000;   -- SS initial value (+reloc)
      ExeLab.SP:=       00000;   -- SP initial value
      ExeLab.ChkSum:=   00000;   -- Check-Sum
      ExeLab.IP:=       00000;   -- IP initial value
      ExeLab.CS:=       00000;   -- CS initial value (+reloc)
      ExeLab.Relo:=     30;      -- Rel. Byte offset of Relocation Table
      ExeLab.Ovln:=     0;       -- Overlay number
      ExeLab.Uknw:=     1;       -- Unknown

      InChar; -- Initiate Standard Input
      -- sHDSIZE:=  DICDEF("HDSIZE");   sLISTING:= DICDEF("LISTING");
      -- sINTGOTO:= DICDEF("INTGOTO");  sINTJMPF:= DICDEF("INTJMPF");
      -- sINTCALL:= DICDEF("INTCALL");  sINTCALF:= DICDEF("INTCALF");
      -- sLBRK:=    DICDEF("(");        sRBRK:=    DICDEF(")");
      -- sCOMA:=    DICDEF(",");        sBNK:=     DICDEF("BNK");
      -- sEQUAL:=   DICDEF("=");        sPLUS:=    DICDEF("+");
      -- sEXE:=     DICDEF("EXE");      sLIB:=     DICDEF("LIB");
      -- sDEF:=     DICDEF("DEF");      sEXT:=     DICDEF("EXT");
      -- sEND:=     DICDEF("END");
      sSTACK:=   DICDEF("STACK");
      sEGOTO:=   DICDEF("E@GOTO");   sECALL:=   DICDEF("E@CALL");
      sBNKTAB:=  DICDEF("S@BNKTAB"); -- sCOMMENT:= DICDEF("--");
%+D   -- sLN1TRC:=  DICDEF("LN1TRC");   sLN2TRC:=  DICDEF("LN2TRC");
%+D   -- sTRACE:=   DICDEF("TRACE");    sATRACE:=  DICDEF("ATRACE");

      OsStat:=0; Endfile:=false;
 end;

%title ***   L  I  N  K  R   ***

Routine LINKR;
begin Unsigned nPrd; Integer FilPos,Loc,n;
      Word i,smb,BnkNam,bnkx,modx; infix(string) instr,itm,cstr;
      ref(LIBRARY) Lib; ref(BANK) Bnk,PrdBnk(100);
      ref(FRAME) Frm; ref(SEGMENT) Seg; ref(OBJMODULE) Mod;
      byte dirCode;

      itm:=instring;
      repeat instr:=ChkDir(itm);
                if SEQ(instr,"EXE") then dirCode:=1
             elsif SEQ(instr,"BNK") then dirCode:=2
%+D          elsif SEQ(instr,"DEF") then dirCode:=3
%+D          elsif SEQ(instr,"EXT") then dirCode:=4
             else dirCode:=0 endif
      while dirCode > 0
      do -----------------------------------------------------------
         -- Treat: EXE/DEF BankName                               --
         --   or   BNK/EXT BankName < ( PredBankName , ... ) >?   --
         -----------------------------------------------------------
         nPrd:=0;
         BnkNam:=InBank; itm:=instring;
         if FindBank(BnkNam) <> none
         then Ed(ErrMsg,"Bank "); EdSymb(ErrMsg,BnkNam);
              ERROR(" Already Defined");
         endif;
         if SEQ(itm,"(")
         then repeat
                 smb:=InSymb; itm:=instring;
                 Bnk:=FindBank(smb);
                 if Bnk = none
                 then Ed(ErrMsg,"Bank "); Edsymb(ErrMsg,smb);
                      ERROR(" is not Defined");
                 elsif nPrd >= 100 then ERROR("Too many preceding banks")
                 else PrdBnk(nPrd):=Bnk; nPrd:=nPrd+1 endif;
              while SEQ(itm,",") do endrepeat;
              if SEQ(itm,")") then itm:=instring else ERROR("Missing )") endif;
         endif;
%+D      if dirCode=4 -- EXT
%+D      then if RotBnk <> none
%+D           then if nPrd=0 then nPrd:=1; PrdBnk(0):=RotBnk endif;
%+D           else ERROR("No ROOT specified") endif;
%+D           Bnk:=NewBANK(Size(XBANK),BnkNam,nPrd);
%+D           repeat while nPrd > 0
%+D           do nPrd:=nPrd-1; Bnk.PrdBnk.Elt(nPrd):=PrdBnk(nPrd) endrepeat;
%+D           ---------------------------------------------------------------
%+D           -- Treat: = FileName                                         --
%+D           ---------------------------------------------------------------
%+D           -- ...  ...  ...  ...
%+D           -- ...  ...  ...  ...
%+D           -- ...  ...  ...  ...
%+D           -- ...  ...  ...  ...
%+D           -- ...  ...  ...  ...
%+D      else
              if dirCode=1 -- EXE
              then Bnk:=NewBANK(Size(BANK),BnkNam,0);
                   if nPrd <> 0 then ERROR("Relation(s) ignored for EXE") endif;
                   if RotBnk=none then RotBnk:=Bnk
                   else ERROR("ROOT is already specified") endif;
%+D                BankDefining:=false;
%+D           elsif dirCode=3 -- DEF
%+D           then Bnk:=NewBANK(Size(BANK),BnkNam,0);
%+D                if nPrd <> 0 then ERROR("Relation(s) ignored for DEF") endif;
%+D                if RotBnk=none then RotBnk:=Bnk
%+D                else ERROR("ROOT is already specified") endif;
%+D                BankDefining:=true;
              elsif dirCode=2 -- BNK
              then if RotBnk <> none
                   then if nPrd=0 then nPrd:=1; PrdBnk(0):=RotBnk endif;
                   else ERROR("No ROOT specified") endif;
                   Bnk:=NewBANK(Size(BANK),BnkNam,nPrd);
                   repeat while nPrd > 0 do nPrd:=nPrd-1;
                          Bnk.PrdBnk.Elt(nPrd):=PrdBnk(nPrd) endrepeat;
              endif;

              ---------------------------------------------------------------
              -- Treat: = Module<(Seg,... )>? < + Module<( Seg,... )>? >*  --
              ---------------------------------------------------------------
              repeat cstr:=ChkDir(itm)
%+D                  if trcsw > 1 then begtrace(cstr); outtrace endif;
              while SEQ(cstr,"=") or SEQ(itm,"+")
              do Mod:=FindModule(InSymb); itm:=instring;
                 if Mod = none then goto E1 endif;
%+D              if SEQ(itm,"(")
%+D              then L2: smb:=InSymb;
%+D                   i.val:=Mod.SegTab.nElt;
%+D                   repeat while i.val > 0
%+D                   do i.val:=i.val-1; Seg:=Mod.SegTab.Elt(i.val);
%+D                      if smb=Seg.Ident
%+D                      then InsertSegment(Seg,Bnk); goto Ls endif;
%+D                   endrepeat;
%+D                   Ed(ErrMsg,"Segment "); EdSymb(ErrMsg,smb);
%+D                   Ed(ErrMsg," not in "); EdModid(ErrMsg,Mod); MODERR(" ");
%+D             Ls:   itm:=instring;
%+D                   if SEQ(itm,",") then goto L2 endif;
%+D                   if SEQ(itm,")") then itm:=instring
%+D                   else ERROR("Missing )") endif;
%+D              else
                      InsertAllSeg(Mod,Bnk);
%+D              endif;
          E1: endrepeat;
%+D      endif;
%+D      if TrcSw > 1 then ShowBnk(Bnk) endif;
      endrepeat;

      --------------------------------------------------
      -- Treat: LIB LibraryName < + LibraryName >*    --
      --------------------------------------------------
      repeat cstr:=ChkDir(itm)
%+D          if trcsw > 1 then begtrace(cstr); outtrace endif;
      while SEQ(cstr,"LIB") or SEQ(itm,"+")
      do NewLIBRARY(InSymb); itm:=instring endrepeat;

      if Verbose then SYSPRI(nostring) endif;
      if not SEQ(cstr,"END")
      then WARNING("Linker: parameter file not END terminated") endif;
      close(Srcf); Srcf:=0; nOpen:=nOpen-1;

      if nUNDEF > 0 then LibrarySearch endif;

      i.val:=0; repeat while i.val < nMod.val
      do i.val:=i.val+1; ChkInsert(MODMAP(i.HI).Elt(i.LO)) endrepeat;

      if    nBnk.val=0 then ERROR("No Bank Defined"); goto T1 endif;
      if    nBnk.val = 1 then -- no bankfile
      elsif nBnk.val = 2 and mergeLinBnk then -- no bankfile
      else EdSymb(EdtBuf,RotBnk.Ident); Ed(EdtBuf,".bnk");
           BnkFilNam:=DICDEF(PickUp(EdtBuf));
           BnkFile:=checkOpen(BnkFilNam,".bnk",accwrite);
%+M        WRITE(BnkFile,0,@n,n); OsStat:=0; -- Truncate File
           bnkx:=nBnk; repeat while bnkx.val > 0
           do Bnk:=BNKMAP(bnkx.HI).Elt(bnkx.LO); bnkx.val:=bnkx.val-1;
              Bnk.Handle:=BnkFile;
           endrepeat;
      endif;
      if RotBnk <> none
      then EdSymb(EdtBuf,RotBnk.Ident); Ed(EdtBuf,".exe");
           ExeFilNam:=DICDEF(PickUp(EdtBuf));
           ExeFile:=checkOpen(ExeFilNam,".exe",accrw);
           RotBnk.Handle:=ExeFile;
%+M        WRITE(ExeFile,0,@n,n); OsStat:=0; -- Truncate Existing File
      endif;

      MakeBankInfoTable;
      RotBnk.BnkDsc.TxtPos:=HDSIZE;
      RotBnk.BnkDsc.TxtPos:=RotBnk.BnkDsc.TxtPos*512;

      i.val:=0; repeat while i.val < nMod.val
      do i.val:=i.val+1; Mod:=MODMAP(i.HI).Elt(i.LO);
         if Mod.Libx.val=0
         then openMod(Mod); LOADER(Mod); closeAfile(Mod,true) endif;
      endrepeat;

      i.val:=0; repeat while i.val < nLib.val
      do i.val:=i.val+1 Lib:=LIBMAP(i.HI).Elt(i.LO);
         openAfile(lib,".lib");
         modx:=Lib.FstElt;
         repeat while modx.val <> 0
         do Mod:=MODMAP(modx.HI).Elt(modx.LO); modx:=Mod.EltLnk;
            FilPos:=Mod.EltRef; FilPos:=FilPos*16;
            LOCATE(Inpt,0,FilPos,Loc);
            if OsStat<>0 then ERROR("Load-LOCATE"); OsStat:=0; goto LE2 endif;
            LOADER(Mod);
         endrepeat;
  LE2:   closeAfile(Lib,true); -- Close(Inpt); Inpt:=0;
      endrepeat;
 
      if BnkFile <> 0 then BnkTerm endif;

      if ExeFile <> 0 then ExeTerm(BNKMAP.Elt(1)) else exhaustAll endif;

      if Verbose then MapListing endif;

      if Verbose
      then T1: Ed(EdtBuf,"End SIMULA Multi-Linker,  Errors: ");
           EdWrd(EdtBuf,ErrCnt); OutImage;
      endif;
end;
%title ***   M  O  N  I  T  O  R   ***

Routine GetInt; import infix(String) itm; export Unsigned val;
begin character c; Unsigned i; i:=0; val:=0;
      repeat c:=if i<itm.nchr then var(itm.chradr)(i) else 'x'
      while c=' ' do i:=i+1 endrepeat;
      repeat c:=if i<itm.nchr then var(itm.chradr)(i) else 'x'
      while (c>='0') and (c<='9')
      do val:=(val*10)+(c qua integer -48); i:=i+1 endrepeat;
end;

Visible Routine MONITOR; import infix(String) verid;
begin Unsigned i; infix(String) par,val; Character opt;
      boolean noP2,giveVersion;
      Word InFileName;

      INITIATE; InFileName.val:=0; Verbose:=false; noP2:=true;
      giveVersion:=false; mergeLinBnk:=true;
      relbuflng:=16384; nrelbuf:=7;
      i:=1; repeat par:=GetPar(i); i:=i+1 while par.nchr <> 0
      do
-- ???   Ed(EdtBuf,"Parameter: "); Ed(EdtBuf,par); OutImage; 
         if    SEQ(par,"/P2") then
%+D                                TrcSw:=0;
                    noP2:=false;
         elsif SEQ(par,"/p2") then
%+D                                TrcSw:=0;
                    noP2:=false;
         elsif (par.nchr > 1) and (var(par.chradr) = '-')
         then opt:=var(par.chradr)(1);   
              val.chradr:=name(var(par.chradr)(2)); val.nchr:=par.nchr-2;
-- ???        Ed(EdtBuf,"Option: "); EdChar(EdtBuf,opt); OutImage;
              if    opt='V' then giveVersion:=true;
              elsif opt='v' then Verbose:=true; giveVersion:=true;
              elsif opt='B' then mergeLinbnk:=false
              elsif opt='b' then relbuflng:=getint(val)
              elsif opt='n' then nrelbuf:=getint(val)
              elsif noP2
              then if (par.nchr > 2) then 
                   ---- val.chradr:=name(var(par.chradr)(2));
                   ---- val.nchr:=par.nchr-2;
                   else i:=i+1; val:=GetPar(i) endif;
-- ???             Ed(EdtBuf,"  Value: "); Ed(EdtBuf,val); OutImage; 
%+D                if opt='t' then TrcSw:=GetInt(val)
%+D                else
                        Ed(EdtBuf,"Lnk: Illegal option: -");
                        EdChar(EdtBuf,opt); Ed(EdtBuf,val); OutImage; 
%+D                endif;
              endif;
         elsif noP2
         then if InFileName.val=0 then InFileName:=DICDEF(par)
              else Ed(EdtBuf,"Lnk: Illegal parameter: ");
                   Ed(EdtBuf,par); OutImage;
              endif;
         endif;
      endrepeat;

      if giveVersion
      then Ed(EdtBuf,"SIMULA (R) Linker  Version "); Ed(EdtBuf,verid); OutImage;
           Ed(EdtBuf,"Copyright (C) Simula a.s. 1989,91."); OutImage;
      endif;

      if noP2
      then if InFileName.val=0
           then Prt("Lnk: insufficient arguments");
                Prt("Usage: lnk {opt}.. file");
                Prt("       -V         # Print Version Ident");
                Prt("       -v         # Set Verbose Mode");
%+D             Prt("       -t level   # Tracing Dumps");
                Prt("       -B         # Link with banks");
                Prt("       -b integer # Set buffer size");
                Prt("       -n integer # Set number of buffers");
                Prt(" - file assumed to be AUTOLINK.PAR");
                InFileName:=DICDEF("autolink")
           endif
      else InFileName:=DICDEF("autolink") endif;
      Srcf:=checkOpen(InFileName,".par",accread); nOpen:=1;
      INITIATER; LINKR;

      if Verbose then Ed(EdtBuf,"End Linker"); OutImage endif;

%+D   if trcsw > 0
%+D   then ed(edtbuf,"THEADDR: "); edint(edtbuf,scanStat(0)); outimage;
%+D        ed(edtbuf,"COMENT:  "); edint(edtbuf,scanStat(1)); outimage;
%+D        ed(edtbuf,"EXTDEF:  "); edint(edtbuf,scanStat(2)); outimage;
%+D        ed(edtbuf,"PUBDEF:  "); edint(edtbuf,scanStat(3)); outimage;
%+D        ed(edtbuf,"LNAMES:  "); edint(edtbuf,scanStat(4)); outimage;
%+D        ed(edtbuf,"SEGDEF:  "); edint(edtbuf,scanStat(5)); outimage;
%+D        ed(edtbuf,"GRPDEF:  "); edint(edtbuf,scanStat(6)); outimage;
%+D        ed(edtbuf,"LINNUM:  "); edint(edtbuf,loadStat(0)); outimage;
%+D        ed(edtbuf,"FIXUPP:  "); edint(edtbuf,loadStat(1)); outimage;
%+D        ed(edtbuf,"LEDATA:  "); edint(edtbuf,loadStat(2)); outimage;
%+D        ed(edtbuf,"LIDATA:  "); edint(edtbuf,loadStat(3)); outimage;
%+D   endif
end;

end;
